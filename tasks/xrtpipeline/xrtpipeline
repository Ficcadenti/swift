#!/usr/bin/perl 
# File name: xrtpipeline
# 
# Task name: xrtpipeline
# 
# Description:	
#
#              Script to perform XRT Data Reduction.
#		   
# 
# Author/Date: Italian Swift Archive Center (Frascati)
# 
# History:
# 
#      0.1.0 : FT 15/03/2002 - Build 1 Release
#      0.2.0 : FT 25/07/2002 - customized perl script as HEADAS 'dumperltool'
#                              using pquery2 in place of "getparam.pl" utiles.
#                            - added calls to 'coordinator' and 'xrtcalcpi' tasks
#                            - added the generation of a plot of event file list PHA
#                              and PI Counts.
#                            - use lheasoft fkeypar in place of ftkeypar
#      0.2.1 : FT 30/08/2002 - SPR_XRT_004 removed the "ok" parameter in the 
#                              ftchecksum call
#      0.2.2 : FT 22/11/2002 - removed input parameters: aboveflag, maxgrade
#      0.3.0 : FT 17/02/2003 - Added 'xrttimetag', 'xrtfilter' and 'xrtscreen' tasks
#      0.3.1 : FT 24/02/2003 - Added stage 3
#      0.4.0 : FT 15/05/2003 - Added 'xrtimage', 'xrtpdcorr','xrtevtrec' calls;
#                              Changes on input parameters; extended xrtcalcpi to
#                              timing modes; added plot of phapi for timing modes.
#                              Added check on filtered event file. If it does not exists
#                              do not generate products and exit with error.
#      0.4.1 : FT 15/05/2003 - Changed call to xrtevtrec. Deleted 'calc1', 
#                              'calc3' parameters and added 'event' parameter
#      0.5.0 : FT 28/07/2003 - Added input parameters: hkdir,unfiltdir,auxdir,
#                              filtdir,proddir,imgdir,ascagrade,gradefile,
#                              wtouter,wtguardflag,pdevent,pdsplit,addcol,
#                              delnull, cleanbp, subbias
#                              Deleted parameters: rawx,rawy
#      0.5.1 : FT 03/09/2003 - Call 'xrtfilter' also for imaging mode (to be 
#                              completed with HK GTI generation); 
#                              Bug fixed on input file search.
#                              Added 'regionfile','filelc', 'filepha',
#                              'filespectrum' patrameters to xrtproducts 
#                              call (TBC values)
#      0.5.2 : FT 23/09/2003 - Added 'creategti', 'screenevtgti' and 
#                              'screenevtexpr' to the 'xrtscreen' task call
#      0.5.3 : FT 16/10/2003 - deleted 'guardflag', 'outer' parameters;
#                              added 'npixels' and 'percent' parameters (xrttimetag task);
#                              added call to fselect for PD mode before 'xrtevtrec' task
#                              to filter the level 1 event file by corrected GTIs produced by
#                              'xrttimetag' (event file extension) (needed to clean event
#                              file by events not fully exposed or by frames too piled-up)
#      0.5.4 : FT 22/10/2003 - Changed 'xrtproducts' input parameter 'filespectrum' into 'fileimage'
#      0.5.5 : FT 24/10/2003 - Muved CallQuzcif subroutine to libxrtperl.pl module
#                              Changed handle of CallQuzcif function
#                              Added keywords for new 'xrtscreen' query
#                              Added handle of empty files
#      0.5.6 : FT 20/11/2003 - Added 'mkfconfigfile' input parameter for
#                              'xrtfilter' task
#      0.5.7 : FT 21/11/2003 - Added new 'xrtproducts' input parameters: 
#                              pcregionfile, wtregionfile, pcbinsize, wtbinsize,
#                              pdbinsize,pcrmffile,wtrmffile,pdrmffile,mirfile,
#                              fltfile,psffile,vigfile,psfflag
#                              Added 'xrthkproc' call
#                              Added DEC_NOM keyword in pc event files (
#                              the 'coordinator' tasks writes into the file the wrong
#                              'DE_CNOM' keyword in place of the DEC_NOM ones).
#      0.5.8 : FT 26/11/2003 - Added 'xrtimage2cnt', 'swiftxform' calls
#      0.5.9 : FT 27/11/2003 - Added missing parameters
#      0.6.0 : FT 11/03/2004 - Added 'alignfile' input parameter to 'xrtfilter' 
#                              call, needed by prefilter v3.2 ; changed defaults
#                              for 'orbmode' and 'orbname' in xrtpipeline.par.
#                            - Updated Call to 'xrtproducts'
#                            - Compute ranom and decnom with 'aspect' (added RunAspect 
#                              subroutine) and use srcra and srcdec
#                              from input only to generate products
#                            - Added the generation of a temporary gti (RunMaketime) with 
#                              only "Settled" data to be input to 'aspect'
#                              routine 
#                            - set DETX and DETY input patameter to 'xrthkproc' to the
#                              CCD center
#                            - removed 'srcdetx' and 'srcdety' input parameters
#                            - changed 'srcra' and 'srcdet' from number to string
#                              to allow the input of the coordinates in "hh mm ss".
#                              Performed cheks on 'srcra' and 'srcdet' with library funtions
#                            - updated call to 'xrttimetag'
#                            - updated call to 'xrtproducts'
#                            - Added check on Maketime input file. If only one row available
#                              do not use makefilter because it generates an empty git file
#                              event if the row is good for that expression
#                            - Added 'xrttam' call with input parameters 'applytamcorr',
#                              'caldbtamfile', 'attcorrout', 'ledfile', 'tamrefx1', 'tamrefy1',
#                              'tamrefx2', 'tamrefy2'
#                            - added 'cleanup' input parameter
#                            - added parameters to 'swiftxform' call
#                            - changed 'xrtph2br' call to 'xrtpcgrade'
#                            - added 'xrthotpix' call for Photon Counting Data,
#                              added input parameter: 'runxrthotpix', 'cellsize', 'impfac',
#                              'logpos', 'bthresh', 'cleanflick', 'iterate'
#                            - Added TNULL keyword to X,Y columns after 'coordinator' run
#                            - Changed handle of 'attitude' file. If the file does not exist
#                              and stage 1/2 requested, exit with error
#      0.6.1 : RP 19/04/2004 - Change calls to TableEmpty and GetKeyword
#      0.6.2 : FT 27/04/2004 - Cancelled DE_CNOM check and keywords TCTYPEX/Y update
#                            - Changed input parameters name to some tasks
#                            - Uptade all Tasks call with new or changed input
#                              parameters
#                            - Substituted 'swiftxform' call with 'swifttrans'
#                            - deleted 'xrtimage2cnt' from pipeline
#      0.6.3 : FT 12/05/2004 - Updated 'xrtproduct' call and Naming Convention changes
#                            - added flagneigh' to xrtevtrec call
#                            - bug fixed on srcra, srcdec GetInputParameters
#                            - changed input parameters:
#                              screenevtgti  -> gtiscreen
#                              screenevtexpr -> exprscreen
#      0.6.4 : FT 19/05/2004 - Do not allowe to overwrite archive directory
#                              (outdir cannot be equal to NONE)
#      0.6.5 : FT 20/05/2004 - Added parameter 'transmfile' to xrtproducts call
#                              when datamode = 'lr' or 'pu'
#      0.6.6 : BS 24/06/2004 - Modified 'fits_update_key' call when keyword type is LOGICAL 
#      0.6.7 : FT 27/07/2004 - Changed 'swifttrans' call to 'swiftxform' and added 'zeronulls'
#                              input parameter
#                            - Removed input parameters 'usehkrangefile' 'useevtrangefile'
#                            - Added 'runaspect' input parameter
#                            - Added 'GetPntFromExt' and 'GetObjFromExt' calls and the
#                              possibility to define input srcra and srcdec equal to 'OBJECT"
#                              to get the information from the RA_OBJ and DEC_OBJ keywords
#                            - Added 'imgtiscreen' input parameter to allow users to do not
#                              perform the GTI screening on images
#                            - Changed 'gtiscreen' into 'evtgtiscreen'
#                            - erased parameters for Input and Output directories. Now files are
#                              found recursiveli into directories under TARGET dir
#                              Now only one ouptut directory is used
#      0.6.8 : FT 03/08/2004 - Implemented 'xrtpdcorr' changes
#      0.6.9 : FT 04/08/2004 - Check on OBS_MODE to discriminate if the the file has to
#                              be processed or not. Only LR taken during Slews (OBS_MODE set to
#                              SLEW) and in 10 arcmin (OBS_MODE set to SETTLING) should be
#                              processed
#      0.7.0 : FT 05/08/2004 - Added Clean of event L1a and L2 event files by coluns no more
#                              useful. The files cleaning is performed if the input parameter
#                              'cleancols' is set to 'yes'
#      0.7.1 : FT 01/09/2004 - Improved naming convention handle with the possibility
#                              to introduce one or more characters before the two digit
#                              level flag
#      0.7.2 : FT 29/09/2004 - Bug fixed in 'outdir' specification. The output directory
#                              cannot be a subdirectory of the input one.
#                            - added DEFAULT to 'orbfile' input parameter. With DEFAULT
#                              the pipeline searches the orbit file under the
#                              input directory tree with stem SWIFT_XRT_ORBIT.txt 
#                            - changed 'applytamcorr' default. Now set to 'no' because
#                              the data distributed by SDC should have the TAM
#                              correction applied. Added a warning if the tam corrction
#                              is requested by user and the attitude is not re-calculated
#                              ('runaspect=no')
#                            - changed xrtproducts input 'height' from 10 to 100
#                            - bug fixed on Image Level 2 file name definition (error
#                              found when the input file is not compressed)
#      0.7.3 : FT 07/10/2004 - Added initialization of $fptr and $status to 0,
#                              this change has been suggested by Bob Wiegand
#                              (undefined variables give warnings with
#                              Astro::FITS::CFITSIO library)
#      0.7.4 : FT 10/12/2004 - Added CALDB query for sc alignment teldef file
#      0.7.5 : FT 17/12/2004 - Added suport to PD new naming convention
#      0.7.6 : FT 20/12/2004 - Run a partial processing of all data modes during
#                              slews and a compete processing during 10 arminutes
#      0.7.7 : BS 28/12/2004 - Bug fixed. Replaced teldef with scteldef in xrtfilter run 
#      0.7.8 : FT 14/01/2005 - Changed XRTDETXY and XRTSKYXY keywords comments
#      0.7.9 : FT 27/01/2005 - Bug fixed on GTI generation (createattgti was not correctly handled
#      0.8.0 : FT 31/01/2005 - Deleted 'ledfile' input parameter from xrttam call
#                              Added input paramaters: 'pntra', 'pntdec', 'pntroll', 'phamin',
#                              'phamax'
#                            - Do not End With Error if there is a fatal error on an event 
#                              file processing but go on with the next event file;
#                            - changes  xrtproducts input 'height' from 100 to 20                                
#                            - added 'attinterpol' and 'aberratin' to 'xrttimetag' and 
#                              'xrthkproc' calls 
#      0.8.1 : FT 10/02/2005 - Added 'nonulls' to 'xrtfilter' call
#                            - Added fselect on event files gtis for windowed timing mode
#      0.8.2 : FT 10/02/2005 - screen the hkfile before create GTIs for 'runaspect' input
#      0.8.3 :               - bug fixed on hk temporary file generation
#      0.8.4 : BS 16/02/2005 - Added 'inarffile' input parameter for xrtproducts task
#      0.8.5 :    17/02/2005 - Bug fixed                  
#      0.8.6 : FT 22/03/2005 - Added 'obsmode' input parameter to process ALL obs_modes
#                              or only the selected one (this allows to specify a user input
#                              screening selection different for pointing, slew and settling data)
#                              allowed values for tis parameters are (ALL,POINTING,SLEW,SETTLING)
#                            - Do not delete the "ROTIME" column ti Lev 1 fits files
#                              needed to take the frame LLD and ULD
#                              (the LLD and ULD now are not fixed but temperature dependent dur to
#                               a change in the on-board software). The ROTIME is now deleted from
#                              the Lev2 files.
#                            - pilow set to 30 in the xrtproducts call
#                            - added 'srcdetx' and 'srcdety' input parameters to xrthkproc and xrttimetag calls
#                            - added 'usesrcdettimetag' input parameter to xrttimetag 
#                            - added 'usesrcdethkproc' input parameter to discreminate
#                              if timetag the Hk Header Packet file using the source 
#                              position in detector or sky
#                            - added input parameter 'obsmodescreen' parameter needed to 'xrtscreen'.
#                              This parameter allows to add to the GTI generation expression
#                              the selection based on the columns SETTLED and TEN_ARCMIN.
#                            - added 'evtfromarc' input parameter. This parameter 
#                              allows to take input event files from the archive or from 
#                              the users output directory. The user can now run only stage 2 or 3
#                              (entrystage = 2 or entrystage = 3 ) on data archive.
#                              It is also useful if the user needs to run for the second time
#                              the stage 1 of the pipeline: the first time should set evtfromarc=yes
#                              to take event files from archive; the second one he can set this
#                              parameter to "no" and take inputs from the output directory
#                              without unzip again the level 1 files.
#                            - addede 'createmkffile' input parameter. This parameter allows
#                              to use the 'mkf' file distributed with the data without
#                              recreate it.
#                            - added 'phas1thr' input parameter to 'xrtfilter' task.
#                              This parameter is used only for PC mode and is 
#                              used by the task to flag events with the central PHA<'phas1thr'
#                              as bed. It is a sort of event threshold.
#                            - added 'hdfile' to 'xrtscreen' and 'xrtevtrec' calls 
#      0.8.7 : BS 23/03/2005 - Added 'hdfile' input parameter to 'xrtpcgrade'
#      0.8.8 : BS 23/03/2005 - Added 'usegoodevt' input parameter to 'xrthotpix'
#      0.8.9 : FT 20/05/2005 - Added trailer file as pipeline input and to the xrttimetg 
#                              (needed for WT data processing)
#                            - Added 'allempty' and 'extempty' input parameters to swiftxform call
#                              (The parameters have not been added to the xrtpipeline input)
#                              and set the 'copyall' swiftxform input parameter to yes. Changes
#                              requested by the new swiftxform task version
#                            - Set the default 'pdbiasth' to '300'. The 'old' value -99
#                              cannot be used because the LLVLTHR keyword is no more available
#                              in the event file
#                            - Added 'pdbiasdiff' input parameter that corresponds to the
#                              xrtpdcorr 'biasdiff' input one. If the
#                              'pdbiasdiff' parameter is set to 0 the xrtpdcorr task
#                              does not correct the bias subtracted on-board
#      0.9.0 : FT 06/06/2005 - Added 'aspectgtiexpr' to allow user to specify the
#                              espression to generate GTIs for the aspect run
#                            - Do not create the .mkf file if only images have to be
#                              processed for that observation and 'imgtiecreen=no'
#                            - Check the existence of TIME values set to NULL in the 
#                              howskeeping header file before running 'ftselect' to erase
#                              rows with TIME == NULL (nonulls=yes)
#      0.9.1 : FT 22/06/2005 - changed GetAttOrbFileName Call
#                            - changed corrected HK Header output file name construction
#                              (SetHkFileCorr subroutine)
#                            - changed Makefilter Output file Name construction
#                            - added 'imbiasdiff' and 'immaxtemp' input parameters 
#                              (needed to the xrtimage task) and 'hdfile' to the 
#                              xrtimage call
#                            - substituted the input parameter 'inarffile' with 
#                              'pcinarffile', 'wtinarffile' and 'pdinarffile' to allow 
#                              to input different ARF for different modes
#                            - added 'pcmaxtemp' input parameter (needed to the
#                              xrtflagpix task)
#                            - added call to the 'xrtwtcorr' task and 
#                              'wtbiasnevents' and 'wtbiasdiff' input arameters needed
#      0.9.2 : BS 01/07/2005 - Bug fixed building output hd  filename 
#      0.9.3 : FT 26/07/2005 - Changed calls with outfile = 'NONE' 
#                              to avoid problems on Cygwin
#      0.9.4 : FT 09/09/2005 - Added 'interpolation' input parameter to 'coordinator'
#                              call
#                            - Added 'interpolation' and 'alignfile' input parameters
#                              to xrttam call
#      0.9.5 : BS 25/10/2005 - Used new input parameter: 'skytime' in swiftxform
#                            -                           'expofile' in xrtproducts
#                            -                           
#                            - Added call to the 'xrtexpomap' task and new input parameters
#                              'energy', 'vigflag'  and 'exponframe'
#                            - Added hotneigh new input parameter, needed for 'xrthotpix'
#                            - Added new input parameter 'useexpomap' and 'createexpomap'
#     0.9.6       26/10/2005 - Modified expomap default file name  
#                            - set to yes overstatus input parameter for xrthotpix task
#     0.9.7                  - use 'expofile' xrtproducts input par only for PC mode 
#     0.9.8       10/11/2005 - Exit with error if 'xtr.hk' file not found and
#                              datamode is WT
#     0.9.9                  - Added window dimension and obsmode in
#                              the standard exposure map filename
#     0.10.0      28/11/2005 - Use ra, dec and radius 'xrtproducts' input parameters
#                              only if (wt/pc)regionfile set to DEFAULT
#     0.10.1      10/03/2006 - Added 'xrttimetag' and 'xrtwtcorr' 'colfile' input parameter
#                              and deleted RAWXTL column from cleaned wt event file 
#                            - added call to 'xrtlccorr' new task
#                            - new input parameter:
#                              * mkfgtiexpr - new xrtfilter input parameter
#                              * colfile - new xrttimetag/xrtwtcorr input parameter
#                              * pccorrectlc
#     0.10.2      15/03/2006 - added "" to xrtfilter 'gtiexpr' input parameter to
#                              allow the input of espressions
#     0.10.3      16/03/2006 - Changed handle of useexpomap,createexpomap,pccorrectlc
#                              input parameters
#     0.10.4      12/05/2006 - PC and WT: before running stage 1 clean the input unfiltered event file
#                              from previous processing results (set STATUS = 0 and erase the
#                              BADPIX extension) 
#     0.10.5   NS 31/10/2006 - Query to CALDB for teldef file with 'DATE-OBS' and 'TIME-OBS'
#                              of input hd file
#                            - Changed RunSwiftXform and RunCoordinator to add 'ATTFLAG' keyword
#                              in output file
#                            - Added 'wtnframe' and 'wtbiasmode' for xrtwtcorr call
#     0.10.6      06/11/2006 - Bug fixed. Skip 'xrtproducts' when datamode=IM and exitstage<3
#     0.10.7      09/02/2007 - Added 'wtbiath' and 'wtnpixels' for xrtwtcorr call
#     0.10.8      08/03/2007 - Added 'usecleanmap' for xrthotpix call
#                            - Modified stdout message from ERROR to WARNING for aspect warnings
#                            - Added 'acsscreen' for xrtscreen call
#     0.10.9      03/04/2007 - Removed 'usecleanmap' for xrthotpix call
#                            - Added 'gradeiterate' for xrthotpix call
#     0.11.0      18/04/2007 - Changed 'pccorrectlc' parameter to 'correctlc'
#                            - Correct Light Curve for PC and WT mode
#                            - Delete col 'PHASO' in L1a and L2 event files if the input parameter
#                              'cleancols' is set to 'yes'
#     0.11.1      26/04/2007 - Added 'xrtpcbias' task call
#     0.11.2      02/05/2007 - Execute pquery2 first for asked input parameters
#                            - Added 'pcbiascorr' input parameter
#     0.11.3      24/05/2007 - Added 'checkattitude' input parameter for xrtexpomap call
#     0.11.4      12/07/2007 - Added 'thrfile' input parameter
#     0.11.5      23/08/2007 - Read 'XPHASCO' keyword to check on-ground bias correction
#                              for PC mode
#     0.11.6      05/11/2007 - Added 'enfile' input parameter for xrtfilter call
#     0.11.7      19/12/2007 - Changed xrtpcbias task call
#     0.11.8      28/03/2008 - Implemented 'xrtlccorr' changes
#                            - Changed RunXrtLcCorr routine to create small instrument map
#                              if input parameter 'createexpomap'="no"
#     0.11.9      21/04/2008 - Ignore files starting with a dot (MAC OSX "AppleDouble" files prob.)
#                            - Fixed 'trailing garbage ignored' problem in gunzip command
#     0.12.0      06/05/2008 - Handle xrtproducts task changes in default WT region
#                            - Removed 'tprec' input parameter
#     0.12.1      06/10/2008 - Added 'lcwtnframe' and 'lcpcnframe' for xrtlccorr call
#                            - Changed RunXrtLcCorr routine to create always a small instrument map
#     0.12.2      12/03/2009 - Added new input parameters to xrtcalcpi task call
#                            - Added 'picorrtype' and 'savepinom' input parameters
#     0.12.3      30/04/2009 - Added 'xrtphascorr' task call
#                            - Added 'pcphasconffile' input parameter
#     0.12.4      25/08/2009 - Added check on light curve file. If it does not exists
#                              do not execute xrtlccorr call.
#     0.12.5      19/05/2010 - Create exposure map and correct light curve also for data in SETTLING mode
#                            - Use uvot attitude file for data in SETTLING mode
#     0.12.6      01/07/2010 - Added 'extended' and 'arfboxsize' input parameters
#     0.12.7      19/04/2013 - Handle SLEW and SETTLING mode while executing 'xrtpcbias' task
#     0.12.8      10/06/2013 - Changed handle of 'attitude' file. attitude like 'sw00000000000pat.fits' is used
#                              if exists in the archive instead of the 'sw00000000000sat.fits' file
#     0.12.9      17/12/2013 - Changed RunSwiftXform and RunCoordinator to add 'ATTFLAG' keyword also in primary header;
#                            - Added check of the 'ATTFLAG' keyword of the input attitude file
#                            - Use 'sw00000000000pat.fits' attitude file for data in SETTLING mode
#     0.13.0      17/02/2014 - Modified check of the 'ATTFLAG' keyword of the input attitude file
#                            - Update ATTFLAG keyword in all extensions of the output PC evt file
#     0.13.1      12/06/2014 - Removed use of deprecated 'define' PERL function
#                            - Updated xrtproducts task call
#                            - Added 'extractproducts' input parameter
#                            - Added support of multiple 'datamode' values comma separated
#                            - Replaced 'exponframe' input parameter with 'expopcnframe' and 'expowtnframe'
#     0.13.2      20/01/2015 - Update 'SOFTVER' and 'CALDBVER' keywords in output event files 
#
# Notes:	
#
#              "fhelp xrtpipeline" for help
# 
# Usage:     
#   xrtpipeline  indir=  <archive directory path> outdir= <output directory>
#            steminputs= <input dataset stem> srcra= <target right ascension> 
#            srcdec= <target declination> [parameter= < value > .. ]
# 
# Input files:  XRT Level 1 Photon Counting, Windowed Timing, Photodiode or Imaging mode file; 
#		XRT Bad Pixel Calibration File; 
#		XRT On Board Bad Pixel Calibration File; 
#		XRT Gain Calibration files (for each readout mode); 
#		XRT Bias Calibration files (for Photodiode and Imaging mode); 
#		XRT teldef file which is a FITS file containing the instrument 
#		    and telescope properties and the coordinate systems definition;
#               XRT Grades Calibration File;
#               XRT Effective Area Calibration Files (for each readout mode);
#               XRT Filter Transmission Calibration File
#               XRT Point Spread Function Calibration File
#               XRT Vignetting Calibration File
#               XRT Makefilter Parameters Calibration File
#               XRT Housekeeping Ranges Calibration File
#               XRT Events Related Parameters Ranges Calibration File
#		XRT attitude file;
#		XRT Housekeeping Frame Header file; 
#		TLE_dummy.fits, leapsec.fits, rigidity.data; 
#
#    
# Output files: 
#              
# Photon Counting (PC):
#                 - XRT event list file level 1 with;
#                   * STATUS, GRADE, PixsAbove,  PI, X, Y, DETX and DETY columns filled.
#                 - XRT Sky Coordinates Image
#
# Windowed Timing (WT):
#                 - XRT event list level 1 file with:
#                   * Photon arrival times computed;
#                   * TIME, STATUS, DETX and DETY columns filled
#                 - XRT event list level 1a file with:
#                   * Event reconstruction performed, columns RAWPHA, 
#                     PHAS, GRADE, PixsAbove and PI added and filled.
#
# Photodiode Low Rate (LrPD) and Piled Up (PuPD)
#                 - XRT event list level 1 file with:
#                   * Photon arrival times computed and TIME column filled;
#                   * DETX and DETY columns filled with source position;
#                   * PHA column filled with bias subtracted values.
#                 - XRT event list level 1a file with:
#                   * Screened by Piled-up frames and pixels not 
#                     fully exposed;
#                   * Event reconstruction performed, columns PHA; 
#                     PHAS, GRADE, PixsAbove and PI added and filled.
#                   * PI column added and filled; 
#
# Imaging Mode (IM) 
#                 - Raw Coordinates Imaging Fits File Level 2 with:
#                   * PHA value of each pixel corrected for bias;
#                   * Image screened by bad pixels
#                   * Image screened by calibration sources
#                   * Image screened by GTIs
#                 - Sky Coordinates Imaging Fits File Level 2 with:
#                   * PHA value of each pixel corrected for bias;
#                   * Image screened by bad pixels
#                   * Image screened by calibration sources
#                   * Image screened by GTIs
#                 - Counts Sky Coordinate image
#                  
# Common output files:
#                 - XRT screened Level 2 Event list (PD,WT,PD)
#                 - (optional) XRT Bad Pixel file with all bad pixels taken
#                   into consideration to flag events.
#                 - 'makefilter' configuration file
#                 - XRT HK file with frames header informations with 
#                   columns TIME,TIME-END corrected for Timing modes frames 
#                 - Fits file with attitude and orbit information (snone001.attorb)
#                 - Filter FITS file containing part of the houskeeping 
#                   information necessary for screening (snone001.mkf) 
#                 - GTI file (one for event file)
#                 - Ancillary Response file (one for event file)
#                 - Light Curve (one for event file)
#                 - Spectrum (one for event file)
#
#               GIF or PS files:
#                 - PC Counts Image
#                 - PC Light Curve
#                 - PC Spectrum 
#                 - WT Light Curve
#                 - WT Spectrum 
#                 - PD Light Curve
#                 - PD Spectrum  
#               
# HEADAS tasks needed:
#               - pquery2
#               - ftchecksum
#               - ftdiff
#               - prefilter
#               - swiftxform
#               - coordinator
#               - makefilter
#  
#
# LHEASOFT tasks needed:
#               - fparkey
#               - ximage
#               - fhisto
#               - fstatistic
#               - fkeypar
#               - fplot
#               - quzcif
#               - fselect
#               - maketime
#               - xselect
#               - xspec
#
#============================================================#

require "libswxrtperl.pl";
#require "/data2/nino/build19/headas-6.1/swift/xrt/lib/xrtperl/libswxrtperl.pl";
#require "/home/tamburelli/src/xrt/lib/xrtperl/libswxrtperl.pl";
#require "/home/primavera/src/xrt/lib/xrtperl/libswxrtperl.pl";
use strict;
use File::Find ();

use Astro::FITS::CFITSIO qw(:longnames :constants);

#use diagnostics -verbose;
#enable  diagnostics;

use vars qw(%Task %Common %Default %InFiles %OutFiles %Parms_str %Parms_num %Parms_bool @PlotGifList @PlotPsList $HEADAS  $Viewer %EvtFiles %DataFiles %Modes $Report);

$Report = "";


my ($name,$par,$IntBool);

#
#  Defaults
#
%Default = (
	    DEFAULT => "DEFAULT",
	    CALDB   => "CALDB",
	    NONE    => "NONE",
	    EVENTS         => "EVENTS",
	    POINTSLEWPOS   => 18,
	    POINTSLEWLEN   =>  2,
	    POINTSTEM      => "po",
	    POINTVALUE      => "POINTING",
	    SLEWSTEM       => "sl",
	    SLEWVALUE       => "SLEW",
	    SETTLINGSTEM   => "st",
	    SETTLINGVALUE   => "SETTLING",
	    XRTIMAGEOUTSTEM => "cl",
	    NOTVALDPARNUMB  => -9999999999,
	    NOTVALDPARBOOL  => "",
	    TCDLT4_KEY_NAME => "TCDLT3",
	    TARGET_KEY_NAME => "OBJECT",
	    OBSID_KEY_NAME  => "OBS_ID",
	    KEYPAR_COMMAND  => "fkeypar",
	    XRTDETXY_KEY_NAME => "XRTDETXY",
	    XRTDETXY_KEY_VAL  => 1,
	    XRTSKYXY_KEY_NAME => "XRTSKYXY",
	    XRTSKYXY_KEY_VAL  => 1,
	    TCTYPX_KEY_VAL  => "RA---TAN",
	    TCTYPY_KEY_VAL  => "DEC--TAN",
	    MISSIONEPOCH    => "2001-01-01T00:00:00.000",
	    KNM_TSTART      => "TSTART",
	    KNM_TSTOP       => "TSTOP",
	    KNM_TELESCOP    => "TELESCOP",
	    KNM_RA_PNT      =>  "RA_PNT",
	    KNM_DEC_PNT     =>  "DEC_PNT",
	    ATTORBEXTENSION => "s.attorb",
	    MKCONFEXTENSION => "smkf.conf",
	    MKFILEEXTENSION => "s.mkf",
	    TLEFILENAME     => "TLE_dummy.fits",
	    CCDCENTERDETX   => 300,
	    CCDCENTERDETY   => 300,
	    XRTSEGMENT      => "AMP",
	    NOTVALIDRADEC   => -91,
	    POINTING        => "POINT",
	    OBJECT          => "OBJECT",
	    XRTPRODUCTS_radius => 20,
#	    XRTPRODUCTS_width  => 40,
#	    XRTPRODUCTS_height => 20,
	    GTI_EXTNAME        => "STDGTI", # extension name used by maketime when generating
                                            # a GTI file. For event file GTI extension name
                                            # use the input paramete 'gtiext' as default
                                            # set fir Swift FITS file to "GTI"
	    LLINE              => "-----------------------------------------------------------\n",
	    SLINE              => "-----------------",
	    SKYNULL            => -1,
	    );
#
# Specific of the task
#
%Task = (
	 start   => `date`,
	 name    => "xrtpipeline",
	 version => "0.13.2",
	 releasedate => "2015-01-20",
	 stem        => "xrtpipeline_0.13.2",
	 emptystem   => "                 ",
	 clobber         => 0,  # it means 'clobber=no'
	 evtfromarc      => 0,  # it means 'evtfromarc=no'
	 createmkffile   => 0,  # it means 'createmkffile=no'
	 usesrcdethkproc => 0,
	 usesrcdettimetag => 0,
	 chatter     => 3,
	 status      => 0,
	 errmess     => "",
	 ranom       => $Default{NOTVALIDRADEC},
	 decnom      => $Default{NOTVALIDRADEC},
	 rollnom     => $Default{NOTVALIDRADEC},
	 srcra       => $Default{NOTVALIDRADEC},
	 srcdec      => $Default{NOTVALIDRADEC},
	 attfile       => "",
	 attflag       => "",
	 stattfile     => "",
	 attfilecorr   => "",
	 hkfile     => "",
	 hkfilecorr => "",
	 trfile     => "",
	 enfile     => "",
	 applytamcorr  => "",
	 runxrthotpix  => "",
	 runaspect     => "",
	 imgtiscreen   => "",
	 teldef        => "",
	 scteldef      => "",
	 useexpomap    => 0,
	 createexpomap => 0,
	 pcbiascorr    => 0,
	 correctlc   => 0,
	 pcexpofile      => "NONE",
	 wtexpofile      => "NONE",

	 evtobsmode   => "", # updated with the observation mode of the event in processing
	 evtattfile   => "", # name of the attitude file to use for the event in processing
	 );

$Default{DUMMY_KEY_COMM} = "Added by $Task{stem}";


#
# Specific of XRT Files
#
%InFiles = (
	    imstem      => "xim",
	    pcstem      => "xpc",
	    wtstem      => "xwt",
	    pdstem1     => "xpu",
	    pdstem2     => "xlr", 
	    biasmapstem => "xbs", # TBD
	    headstem    => "xhd",
	    trstem      => "xtr",
	    orbitfile   => "SWIFT_TLE",
	    );
#
#  Parameters
#
%Parms_str = (
	      # common parameters
	      indir       => "",
	      outdir      => "",
	      steminputs  => "",
	      stemoutputs => "",
	      datamode    => "",
	      obsmode     => "",
	      plotdevice  => "",
	      thrfile     => "",
	      # Parameters for S/C Nominal Direction 
	      pntra       => "",
	      pntdec      => "",
	      pntroll     => "",
	      # Parameters for 'xrtflagpix' task
	      bpfile => "",
	      bptable     => "",
	      srcfile => "",
	      userbpfile  => "",
	      teldef      => "",  # needed by 'coordinator' too
	      # Parameters for 'xrtpcgrade' task
	      gradefile => "",
	      # Parameters for 'xrtphascorr' task
	      pcphasconffile  => "",
	      # Parameters for 'coordinator' task
	      eventext    => "",
	      timecol     => "",
	      attfile     => "",
	      stattfile   => "",
	      # Parameters for 'xrtcalcpi' task
	      pcgainfile    => "",
	      wtgainfile  => "",
	      pdgainfile  => "",
	      picorrtype  => "",
	      # Parameters for images generation and plot
	      # Parameters for 'xrtfilter/prefilter' task
	      hdfile   => "",
	      trfile   => "",
	      outfile     => "",
	      outcols     => "",
	      orbmode     => "",
	      orbfile     => "",
	      leapfile    => "",
	      rigfile     => "",
	      origin      => "",
	      # Parameters for 'xrtfilter/makefilter' task
	      enfile        => "",
	      mkfconfigfile => "",
	      configfile   => "",
	      mkffile     => "",
	      mkfgtiexpr  => "",
	      # Parameters for 'xrtscreen/maketime' task
	      gtiexpr      => "",
	      usrgtifile   => "",
	      hkrangefile  => "",
	      evtrangefile => "",
	      # Parameters for 'xrtscreen/extractor' task
	      gtiext       => "",
	      # Parameters for 'xrtscreen/fselect task
	      exprpc      => "",
	      exprwt  	  => "",
,	      exprpd  	  => "",
	      exprpcgrade => "",
	      exprwtgrade => "",
,	      exprpdgrade => "",
	      # Parameters for xrtpdcorr
	      biaspdfile   => "",
	      pdbiasmethod => "",
	      # Parameters for xrtpcbias
	      pcbiasmethod   => "",
	      # Parameters for xrtwtcorr
	      wtbiasmode    => "",
	      # Parameters for xrttimetag and xrtwtcorr
	      colfile      => "",
	      # Parameters for xrtimage
	      biasimfile     => "",
	      # Parameters for xrtevtrec
	      # Parameters for xrtproducts
	      srcra         => "",
	      srcdec        => "",
	      pcregionfile   => "",
	      wtregionfile   => "",
	      pcrmffile      => "",
	      wtrmffile      => "",
	      pdrmffile      => "",
	      mirfile        => "",
	      transmfile     => "",
	      pcinarffile      =>"",
	      wtinarffile      =>"",
	      pdinarffile      =>"",
	      psffile        => "",
	      vigfile        => "",
	      # Parameters for xrttam
	      tamfile   => "",
	      attcorrout     => "",
	      # Parameters for swiftxform
	      method         => "",
	      scteldef       => "",  # needed by 'aspect' and xrtfilter
	      # Parameters for aspect
	      aspectgtiexpr  => "",
	  );

%Parms_num = (
	      # common parameters
	      chatter    => $Default{'NOTVALDPARNUMB'},
	      entrystage => $Default{'NOTVALDPARNUMB'},
	      exitstage  => $Default{'NOTVALDPARNUMB'},
	      # Parameters for 'xrtflagpix' task
	      phas1thr   => $Default{'NOTVALDPARNUMB'},
	      pcmaxtemp  => $Default{'NOTVALDPARNUMB'},
	      # Parameters for 'xrtpcgrade' task
	      pcsplit    => $Default{'NOTVALDPARNUMB'},
	      # Parameters for 'coordinator' task
	      seedcoordinator => $Default{'NOTVALDPARNUMB'},
	      timemargin      => $Default{'NOTVALDPARNUMB'},
	      # Parameters for 'xrtcalcpi' task
	      seedxrtcalcpi => $Default{'NOTVALDPARNUMB'},
	      pcgainnom       => $Default{'NOTVALDPARNUMB'},
	      wtgainnom       => $Default{'NOTVALDPARNUMB'},
	      pdgainnom       => $Default{'NOTVALDPARNUMB'},
	      pcoffset        => $Default{'NOTVALDPARNUMB'},
	      wtoffset        => $Default{'NOTVALDPARNUMB'},
	      pdoffset        => $Default{'NOTVALDPARNUMB'},
	      # Parameters for 'prefilter' task
	      interval      => $Default{NOTVALDPARNUMB},
#	      tprec         => $Default{NOTVALDPARNUMB},
	      # Parameters for 'xrttimetag'
	      npixels       => $Default{NOTVALDPARNUMB},
	      percent       => $Default{NOTVALDPARNUMB},
	      srcdetx       => $Default{NOTVALDPARNUMB},
	      srcdety       => $Default{NOTVALDPARNUMB},
	      # Parameters for images generation and plo
	      # Parameters for xrtpdcorr
	      pdbias        => $Default{NOTVALDPARNUMB},
	      pdbiasnevents => $Default{NOTVALDPARNUMB},
	      pdbiasnclip   => $Default{NOTVALDPARNUMB},
	      pdbiasnsigma  => $Default{NOTVALDPARNUMB},
	      pdbiasnevents => $Default{NOTVALDPARNUMB},
	      pdbiasth      => $Default{NOTVALDPARNUMB},
	      pdbiasdiff    => $Default{NOTVALDPARNUMB},
	      pdbiasfittol  => $Default{NOTVALDPARNUMB},
	      pdbiasnframe  => $Default{NOTVALDPARNUMB},
	      # Parameters for xrtwtcorr
	      wtbiasnevents => $Default{NOTVALDPARNUMB},
	      wtbiasdiff    => $Default{NOTVALDPARNUMB},
	      wtnframe      => $Default{NOTVALDPARNUMB},
	      wtbiasth      => $Default{NOTVALDPARNUMB},
	      wtnpixels     => $Default{NOTVALDPARNUMB},
	      # Parameters for xrtpcbias
	      pcbiassubimgsize  => $Default{NOTVALDPARNUMB},
	      pcbiasnevents     => $Default{NOTVALDPARNUMB},
	      pcbiasgrademin    => $Default{NOTVALDPARNUMB},
	      pcbiasgrademax    => $Default{NOTVALDPARNUMB},
	      pcbiasevtthr      => $Default{NOTVALDPARNUMB},
	      pcbiassplitthr    => $Default{NOTVALDPARNUMB},
	      # Parameters for xrtimage
	      imbias        => $Default{NOTVALDPARNUMB},
	      imbiasdiff    => $Default{NOTVALDPARNUMB},
	      immaxtemp     => $Default{NOTVALDPARNUMB},
	      # Parameters for 'xrtpcgrade' task
	      wtevent       => $Default{NOTVALDPARNUMB},
	      wtsplit       => $Default{NOTVALDPARNUMB},
	      pdevent       => $Default{NOTVALDPARNUMB},
	      pdsplit       => $Default{NOTVALDPARNUMB},
	      # Parameters for 'xrtproducts' task
	      pcbinsize     => $Default{NOTVALDPARNUMB},
	      wtbinsize     => $Default{NOTVALDPARNUMB},
	      stwtbinsize   => $Default{NOTVALDPARNUMB},
	      pdbinsize     => $Default{NOTVALDPARNUMB},
	      arfboxsize    => $Default{NOTVALDPARNUMB},
	      # Parameters for 'xrttam' task
	      tamrefx1      => $Default{NOTVALDPARNUMB},
	      tamrefy1      => $Default{NOTVALDPARNUMB},
	      tamrefx2      => $Default{NOTVALDPARNUMB},
	      tamrefy2      => $Default{NOTVALDPARNUMB},
	      # Parameters for 'xrthotpix'
	      cellsize      => $Default{NOTVALDPARNUMB},
	      impfac        => $Default{NOTVALDPARNUMB},
	      logpos        => $Default{NOTVALDPARNUMB},
	      bthresh       => $Default{NOTVALDPARNUMB},
	      phamin        => $Default{NOTVALDPARNUMB},
	      phamax        => $Default{NOTVALDPARNUMB},
	      cellsize      => $Default{NOTVALDPARNUMB},
	      # Parameters for 'xrtexpomap'
	      energy        => $Default{NOTVALDPARNUMB},
	      expopcnframe  => $Default{NOTVALDPARNUMB},
	      expowtnframe  => $Default{NOTVALDPARNUMB},
	      # Parameters for 'xrtlccorr'
	      lcwtnframe    => $Default{NOTVALDPARNUMB},
	      lcpcnframe    => $Default{NOTVALDPARNUMB},
	      );

%Parms_bool = (
           # common parameters
	   display   => $Default{'NOTVALDPARBOOL'},
	   clobber   => $Default{'NOTVALDPARBOOL'},
	   evtfilesfromarchive => $Default{'NOTVALDPARBOOL'},
	   createmkffile       => $Default{'NOTVALDPARBOOL'},
	   history   => $Default{'NOTVALDPARBOOL'},
	   cleanup   => $Default{'NOTVALDPARBOOL'},
	   cleancols => $Default{'NOTVALDPARBOOL'},
	   extractproducts     => $Default{'NOTVALDPARBOOL'},
           # Parameters for 'xrtflagpix' task
	   overstatus           => $Default{'NOTVALDPARBOOL'},
           # Parameters for 'coordinator' task
	   runcoordinator       => $Default{'NOTVALDPARBOOL'},
	   aberration           => $Default{'NOTVALDPARBOOL'},
	   follow_sun           => $Default{'NOTVALDPARBOOL'},
	   randomizecoordinator => $Default{'NOTVALDPARBOOL'},
	   # Parameters for xrtpcbias
	   pcbiascorr          => $Default{'NOTVALDPARBOOL'},
	   pcbiassubimage      => $Default{'NOTVALDPARBOOL'},
	   pcbiaslessevents    => $Default{'NOTVALDPARBOOL'},
	   pcbiasbadpix        => $Default{'NOTVALDPARBOOL'},
           # Parameters for 'xcalcpi' task
	   randomizexrtcalcpi  => $Default{'NOTVALDPARBOOL'},
	   savepinom           => $Default{'NOTVALDPARBOOL'},
	   # Parameters for 'xrtpcgrade','xrtevtrec' tasks
	   ascagrade           => $Default{'NOTVALDPARBOOL'},
	   # Parameters for 'xrtevtrec' task
           addcol              => $Default{'NOTVALDPARBOOL'},
           delnull             => $Default{'NOTVALDPARBOOL'},
	   flagneigh           => $Default{'NOTVALDPARBOOL'},
	   # Parameters for 'xrtscreen' task
	   createattgti        => $Default{'NOTVALDPARBOOL'},
	   createinstrgti      => $Default{'NOTVALDPARBOOL'},
           evtgtiscreen        => $Default{'NOTVALDPARBOOL'},
           evtscreen           => $Default{'NOTVALDPARBOOL'},
	   obsmodescreen       => $Default{'NOTVALDPARBOOL'},
 	   acsscreen           => $Default{'NOTVALDPARBOOL'},
	   # Paremeters for 'xrtimage' task
	   imcleansrc           => $Default{'NOTVALDPARBOOL'},
	   cleanbp             => $Default{'NOTVALDPARBOOL'},
	   subbias             => $Default{'NOTVALDPARBOOL'}, 
	   imgtiscreen          => $Default{'NOTVALDPARBOOL'},
	   # Paremeters for 'xrtimage' task
	   psfflag             => $Default{'NOTVALDPARBOOL'}, 
	   # Paremeters for 'xrttam' task
	   applytamcorr        => $Default{'NOTVALDPARBOOL'}, 
           # Parameters for 'xrthotpix'
	   runxrthotpix        => $Default{'NOTVALDPARBOOL'}, 
           gradeiterate         => $Default{'NOTVALDPARBOOL'},
           cleanflick          => $Default{'NOTVALDPARBOOL'}, 
           iterate             => $Default{'NOTVALDPARBOOL'}, 
	   hotneigh            => $Default{'NOTVALDPARBOOL'}, 
	   # Parameters for swiftxform
	   aberration          => $Default{'NOTVALDPARBOOL'}, 
	   zeronulls           => $Default{'NOTVALDPARBOOL'}, 
	   # Parameters for aspect
	   runaspect           => $Default{'NOTVALDPARBOOL'}, 
	   # parameters fro xrttimetag and xrthotpix
	   attinterpol         => $Default{'NOTVALDPARBOOL'}, 
	   usesrcdettimetag    => $Default{'NOTVALDPARBOOL'}, 
	   usesrcdethkproc     => $Default{'NOTVALDPARBOOL'},
	   # Parameter for xrtexpomap
	   vigflag             => $Default{'NOTVALDPARBOOL'}, 
	   createexpomap       => $Default{'NOTVALDPARBOOL'},
	   checkattitude       => $Default{'NOTVALDPARBOOL'},
	   # Parameter for xrtproducts
           useexpomap          => $Default{'NOTVALDPARBOOL'},
	   correctlc           => $Default{'NOTVALDPARBOOL'},   
	   extended            => $Default{'NOTVALDPARBOOL'},

	    );


    %EvtFiles = (
		  pc => {
		      # File name match string: sw00000000000xpcw0[p/s]l1.evt
		      fnamemtc => "xpcw(\\d|n|u)(po|sl|st)(\\w+|)uf.evt",
		      nfiles => 0,
		  },
		  wt => {
		      # File name match string: sw00000000000xwtw0[p/s]l1.evt
		      fnamemtc => "xwtw(\\d|n|u)(po|sl|st)(\\w+|)uf.evt",
		      nfiles => 0,
		  },
		  lr => {
		      # File name match string: sw00000000000xlr00[p/s]l1.evt
		      fnamemtc => "xlr(wn|b0|b1)(po|sl|st)(\\w+|)uf.evt",
		      nfiles => 0,
		  },
		  pu => {
		      # File name match string: sw00000000000xpu00[p/s]l1.evt
		      fnamemtc => "xpu(wn|b0|b1)(po|sl|st)(\\w+|)uf.evt",
		      nfiles => 0,
		  },
		  im => {
		      # File name match string: sw00000000000xim00[p/s]raw.img
		      fnamemtc => "xim(\\w+|)rw.img",
		      indir => "",
		      nfiles => 0,
		  },
		  );


    %DataFiles = (
		  hk => {
		      # File name match string: sw00000000000xhead.hk
		      fnamemtc => "xhd.hk",
		      nfiles => 0,
		  },
		  tr => {
		      # File name match string: sw00000000000xtr.hk
		      fnamemtc => "xtr.hk",
		      nfiles => 0,
		  },
		  att => {
		      # File name match string: sw00000000000snone000.att
		      fnamemtc => "sat.fits",
		      nfiles => 0,
		  },
		  statt => {
		      # File name match string: sw00000000000pat.fits
		      fnamemtc => "pat.fits",
		      nfiles => 0,
		  },
		  patt => {
		      # File name match string: sw00000000000pat.fits
		      fnamemtc => "pat.fits",
		      nfiles => 0,
		  },
		  tle => {
		      # File name match string:
		      fnamemtc => "SWIFT_TLE_ARCHIVE.txt.(\\w+).(\\w+)",
		      nfiles => 0,

		  },
		  mkf => {
		      # File name match string:
		      fnamemtc => "s.mkf",
		      nfiles => 0,

		  },
		  en => {
		      # File name match string: sw00000000000sen.hk
		      fnamemtc => "sen.hk",
		      nfiles => 0,
		  }
		  );


%Modes = (
	  pc => "Photon Counting",
	  im => "Imaging",
	  wt => "Windowed Timing",
	  lr => "Lowrate Photodiode",
	  pu => "Piledup Photodiode",
	  );


#######################################################
# List of columns to be erased from l1a, l2 Event Files
# from each Data Modes event files before put the files 
# into the archive. The files will be cleaned if the
# 'cleancols' input parameter is set to 'yes' (default
# for standard analysis)
#######################################################

my @pc_l2_collist = ( "CCDFrame", "PHAS", "Amp", "PixsAbove", "PHASO", "TLMPHAS");
my @wt_l1a_collist = ( "EVTPHA" );
my @wt_l2_collist = ( "ROTIME", "CCDFrame", "PHAS", "Amp", "PixsAbove" , "RAWXTL", "PHASO");
my @pd_l1a_collist = ( "RAWPHA", "EVTPHA");
my @pd_l2_collist = ( "ROTIME", "CCDFrame", "OFFSET", "PHAS", "Amp", "PixsAbove" );

#
# Get Input Parameters 
#

print"\n============================================================\n";
print"                Running SWIFT XRT pipeline\n";
print" Task: $Task{'name'} Version: $Task{'version'} Release Date: $Task{'releasedate'}\n";
print"============================================================\n";


if ( &GetInputParameters ) {
    $Task{errmess} = "Error parsing input parameters";
    goto EXITWITHERROR;
}

$Task{chatter} = $Parms_num{chatter};
if ( $Parms_bool{clobber} =~ /[yY]/ ) {
    $Task{clobber} = 1;
}
if ( $Parms_bool{evtfilesfromarchive} =~ /[yY]/ ) {
    $Task{evtfromarc} = 1;
}
if ( $Parms_bool{createmkffile} =~ /[yY]/ ) {
    $Task{createmkffile} = 1;
}
if ( $Parms_bool{usesrcdethkproc} =~ /[yY]/ ) {
    $Task{usesrcdethkproc} = 1;
}
if ( $Parms_bool{usesrcdettimetag} =~ /[yY]/ ) {
    $Task{usesrcdettimetag} = 1;
}
if ( $Parms_bool{applytamcorr} =~ /[yY]/ ) {
    $Task{applytamcorr} = 1;
}
if ( $Parms_bool{runxrthotpix} =~ /[yY]/ ) {
    $Task{runxrthotpix} = 1;
}
if ( $Parms_bool{cleanup} =~ /[yY]/ ) {
    $Task{cleanup} = 1;
}
if ( $Parms_bool{runaspect} =~ /[yY]/ ) {
    $Task{runaspect} = 1;
}
if ( $Parms_bool{imgtiscreen} =~ /[yY]/ ) {
    $Task{imgtiscreen} = 1;
}
if ( $Parms_bool{attinterpol} =~ /[yY]/ ) {
    $Task{interpolation}="LINEAR";
}
else {
    $Task{interpolation}="CONSTANT";
}

if ( $Parms_bool{createexpomap} =~ /[yY]/ ) {
    $Task{createexpomap} = 1;
}
if ( $Parms_bool{useexpomap} =~ /[yY]/ ) {
    $Task{useexpomap} = 1;
}

if ( $Parms_bool{pcbiascorr} =~ /[yY]/ ) {
    $Task{pcbiascorr} = 1;
}

if ( $Parms_bool{correctlc} =~ /[yY]/ ) {
    $Task{correctlc} = 1;
}
$Task{entrrstage} = $Parms_num{entrystage};
$Task{exitstage} = $Parms_num{exitstage};


my ( $obsmodes ) = $Parms_str{obsmode};

if ( !&CompUL($obsmodes,"ALL") && !&CompUL($obsmodes,$Default{POINTVALUE}) && 
     !&CompUL($obsmodes, $Default{SETTLINGVALUE}) &&
     !&CompUL($obsmodes,$Default{SLEWVALUE}) ) {
    $Task{errmess} = "Error on 'obsmode' input parameter, '$Parms_str{obsmode}' value not allowed";
    goto EXITWITHERROR;
}

#
# Start Report Messages
#

$Report = "";
&AddReport(3,"\n============================================================\n");
&AddReport(3,"                SWIFT XRT pipeline Report\n");
&AddReport(3," Task: $Task{'name'} Version: $Task{'version'} Release Date: $Task{'releasedate'}\n");
&AddReport(3,"============================================================\n");

#########################################################
# Get Input information names needed to run the pipeline,
# perform some checks and set common variables
##########################################################

&InitRun();
if ( $Task{status} == 1 ) { goto EXITWITHERROR; }


&AddReport(3,"$Default{SLINE}        PROCESSING HK     $Default{SLINE}\n");

if ( $Task{applytamcorr} ) {

    ##########################################
    # Correct 'attitude' file using TAM values
    ##########################################

    $Task{attfilecorr} = &SetAttFileCorr($Task{attfile});

    if ( $Task{status} == 1 ) {goto EXITWITHERROR;}
    # Apply TAM correction on Attitude Data
    if ( $Task{entrystage} == 1) {
	&RunXrtTam();
	if ( $Task{status} ) { goto EXITWITHERROR; }
    }

    if ( !$Task{runaspect} ) {
	&AddReport(2,"hk: .... WARNING: TAM correction applyed on attitude\n");
	&AddReport(2,"hk: .... WARNING: but spacecraft attitude not calculated on the\n");
	&AddReport(2,"hk: .... WARNING: attitude corrected by TAM\n");
	&AddReport(2,"hk: .... WARNING: set the 'runaspect' input parameter to 'yes'\n");
	&AddReport(2,"hk: .... WARNING: to use the direction calculated on the attitude corrected by TAM\n");
    }


} else { $Task{attfilecorr} = $Task{attfile}; }

if ( ! -f $Task{attfilecorr} ) {
    &PrntChty(2,"$Task{stem}: ERROR Attitude File: '$Task{attfilecorr}' file not found\n");
    $Task{errmess} = "File '$Task{attfilecorr}' not found";
    &AddReport(2,"hk: .... ERROR: File '$Task{attfilecorr}' not found\n");
    goto EXITWITHERROR;
}

$Task{evtattfile} = $Task{attfilecorr};


#################################################
# Set $Task{ranom}, $Task{decnom}, $Task{rollnom}
# $Task{srcra}, $Task{srcdec}
#################################################

&SetPointingAndSourceInfo;
if ( $Task{status} ) { goto EXITWITHERROR; }


$Task{hkfilecorr} = &SetHkfileCorr($Task{hkfile});    
##########;;;;;;;;
if ( $Task{status} == 1 ) {goto EXITWITHERROR;}

if ( $Task{entrystage} == 1 ) {

    #############################
    # TIME and ENDTIME correction
    #############################

#    my ( $runxrthkproc ) = 1;
#    my ( $xrttimes );
#    &GetKeyword ($Task{hkfile}, "FRAME", undef, "XRTTIMES",\$xrttimes, 1 );
#    if ( $Task{status} && $Task{status} != KEY_NO_EXIST ) {goto EXITWITHERROR;}
#    elsif ( $xrttimes eq 'T' ) {
#	 my ( $xra_obj, $xdec_obj, $xra_pnt, $xdec_pnt );
#	 if ( !&GetKeyword ($Task{hkfile}, "FRAME", undef, "XRA_OBJ",\$xra_obj ) &&
#	      !&GetKeyword ($Task{hkfile}, "FRAME", undef, "XDEC_OBJ",\$xdec_obj ) &&
#	      !&GetKeyword ($Task{hkfile}, "FRAME", undef, "XRA_PNT",\$xra_pnt ) &&
#	      !&GetKeyword ($Task{hkfile}, "FRAME", undef, "XDEC_PNT",\$xdec_pnt ) ) {
#	     my ( $sens ) = 0.00001;
#	     if ( abs ( $xra_obj - $Task{srcra} ) < $sens &&
#		  abs ( $xdec_obj - $Task{srcdec} ) < $sens &&
#		  abs ( $xra_pnt - $Task{ranom} ) < $sens &&
#		  abs ( $xdec_pnt - $Task{decnom} ) < $sens ) {
#
#	 }
#    }
#
#    exit;

    &RunXrtHkProc();
    if ( $Task{status} ) { goto EXITWITHERROR; }
}
else {
    $Task{hkfilecorr}=$Task{hkfile};
}


if ( ! -f $Task{hkfilecorr} ) {
    &PrntChty(2,"$Task{stem}: ERROR Housekeeping Header Packets: '$Task{hkfilecorr}' file not found\n");
    $Task{errmess} = "File '$Task{hkfilecorr}' not found";
    &AddReport(2,"hk: .... ERROR: File '$Task{hkfilecorr}' not found\n");
    goto EXITWITHERROR;
}
else {

    &AddReport(2,"hk: .... Using Housekeeping Header Packet file: '$Task{hkfilecorr}' processed with:\n");

    my ( $xra_obj, $xdec_obj, $xra_pnt, $xdec_pnt, $xrtdetx, $xrtdety );

    &GetKeyword ($Task{hkfilecorr}, "FRAME", undef, "XRA_OBJ",\$xra_obj, 1);
    if ( $Task{status} && $Task{status}!= KEY_NO_EXIST ) { goto  EXITWITHERROR; }
    else { $Task{status} = 0 };

    &GetKeyword ($Task{hkfilecorr}, "FRAME", undef, "XDEC_OBJ",\$xdec_obj, 1 );
    if ( $Task{status} && $Task{status}!= KEY_NO_EXIST ) { goto  EXITWITHERROR; }
    else { $Task{status} = 0 };

    &GetKeyword ($Task{hkfilecorr}, "FRAME", undef, "XRA_PNT",\$xra_pnt, 1 );
    if ( $Task{status} && $Task{status}!= KEY_NO_EXIST ) { goto  EXITWITHERROR; }
    else { $Task{status} = 0 };

    &GetKeyword ($Task{hkfilecorr}, "FRAME", undef, "XDEC_PNT",\$xdec_pnt, 1 );
    if ( $Task{status} && $Task{status}!= KEY_NO_EXIST ) { goto  EXITWITHERROR; }
    else { $Task{status} = 0 };

    &GetKeyword ($Task{hkfilecorr}, "FRAME", undef, "XRTDETX",\$xrtdetx, 1 );
    if ( $Task{status} && $Task{status}!= KEY_NO_EXIST ) { goto  EXITWITHERROR; }
    else { $Task{status} = 0 };

    &GetKeyword ($Task{hkfilecorr}, "FRAME", undef, "XRTDETY",\$xrtdety, 1 );
    if ( $Task{status} && $Task{status}!= KEY_NO_EXIST ) { goto  EXITWITHERROR; }
    else { $Task{status} = 0 };

    if ( $xrtdetx != undef && $xrtdety != undef ) {
	&AddReport(2,"hk: ....                                      : srcdetx = $xrtdetx srcdety = $xrtdety\n");
    }
    if ( $xra_obj != undef && $xdec_obj != undef ) {
	&AddReport(2,"hk: ....                                      : srcra = $xra_obj srcdec = $xdec_obj\n");
    }
    if ( $xra_pnt != undef && $xdec_pnt != undef ) {
	&AddReport(2,"hk: ....                                      : pntra = $xra_pnt pntdec = $xdec_pnt\n");
    }
    if ( $xrtdetx == undef && $xrtdety == undef && $xra_obj == undef && $xdec_obj == undef ) {
	&AddReport(2,"hk: ....                              WARNING : Housekeeping Header Packet file not processed by pipeline\n");
    }

    $Task{status} = 0;
    $Task{message} = " ";

}

if ( &DoStage(2) &&
     ( $Parms_bool{createattgti} =~ /[yY]/ ||
       $Parms_bool{createinstrgti} =~ /[yY]/ ) && 
     ( !&OnlyImages ||
       &OnlyImages && &CompUL($Parms_bool{imgtiscreen},"yes") ) ) {

    ######################################
    # Create Attorbit and Makefilter file
    ######################################
    if ( $Task{createmkffile} ) {
	if ( &RunXrtfilter("hk",$Task{ranom}, $Task{decnom}) ) {
	    &AddReport(3,"hk: .... Processig Att/HK : Error Creating 'makefilter' output file\n");
	    goto EXITWITHERROR;
	}
    }
    else {
	if ( $#{$InFiles{mkf}} == -1 ) {
	    &PrntChty(2,"$Task{stem}: ERROR: No attitudeFilter file found in '$Parms_str{indir}' directory tree\n");
	    &PrntChty(2,"$Task{stem}: ERROR: with '$Parms_str{steminputs}' stem\n");
	    $Task{errmess} = "Filter File not found in the target directory";
	    $Task{status} = 1;
	    &AddReport(2,"................. : ERROR attitude file not found\n");
	    return;
	}
	elsif ( $#{$InFiles{mkf}} > 0 ) {
	    &PrntChty(2,"$Task{stem}: ERROR: Found more than one filter file in '$Parms_str{indir}' directory tree\n");
	    &PrntChty(2,"$Task{stem}: ERROR: This case is not supported.\n"); 
	    $Task{errmess} = "Found more than one filter file in the target directory";
	    $Task{status} = 1;
	    &AddReport(2,"................. : ERROR more than one filter file found\n");
	    return;
	}
	else {
	    $Parms_str{mkffile} = "$InFiles{mkf}[0]";
	    &AddReport(2,"hk: .... Using Makefilter Configuration File $Parms_str{mkffile}\n");
	}
    }
}

my ( $outlev1file, $evtfile );
my ( $mode );

my ( $Procmade ) = 0;
my ( $PipelineError ) = 0;

&AddReport(3,"$Default{SLINE}  PROCESSING EVENT FILES  $Default{SLINE}\n");

##########################################
# Loop on datamodes andprocess event files
##########################################

foreach $mode ( @{$InFiles{'modelist'}} ) {

    if ( $EvtFiles{$mode}{nfiles} == 0 ) { next; } 

    $Procmade=1;

    my ( $GtiFile );
    my ( $who );

    for $who ( @{ $EvtFiles{$mode}{filelist} } ) {

	$Task{status} = 0;
	$Task{errmess} = "";

	&AddReport(3,"$mode: Processing $who->{lev1}\n");

	#################################################
	# Check The Observation Mode (OBS_MODE keyword)
	# only LR SLEW and SETTLING data have to be processed
	# 20/12/2004 - FT:
        # but to support calibrations all datamades will be
	# partially processed during slews and processed
	# during settling.
	################################################
	
	my ( $obs_mode, $next );
	$next = 0;
	&CheckObsMode($who->{lev1},$mode,\$obs_mode,\$next);
	if ( $Task{status} ) { goto EXITWITHERROR; }
	if ( $next ) { next; }

	$Task{evtobsmode} = $obs_mode;

	# Attitude file to use for the selected event file processing
	if( ($obs_mode eq $Default{SETTLINGVALUE}) && ( $mode eq "wt" ) ) {

	    $Task{evtattfile} = $Task{stattfile};
	    if ( ! -f $Task{evtattfile} ) {
		&PrntChty(3,"$Task{stem}: ERROR: No attitude file found for file: $who->{lev1}\n");
		$Task{errmess} = "ERROR No attitude file found for file: $who->{lev1}";		
		&AddReport(3,"$mode: .... Stage  I/II: ERROR: No attitude file found for file: $who->{lev1}\n");
		&AddReport(3,"$mode: .... Stage  I/II: ERROR: no '$who->{lev2}' created\n");
		$PipelineError=1;
		next;
	    }
	}
	else{
	    $Task{evtattfile} = $Task{attfilecorr};
	}

	my $tmpstr1 = substr(&ErasePath($who->{lev1}),$Default{POINTSLEWPOS},$Default{POINTSLEWLEN});

	if ( $mode eq "im" ) {

	    ###############################
	    # Process imaging mode data
	    ###############################

	    if ( &DoStage(1) ) {

		&PrntChty(3,"\n============================================================\n");
		&PrntChty(3,"$Task{stem}: Imaging Stage I/II: Calibrating $who->{lev1}\n");
		&PrntChty(3,"============================================================\n\n");
		
		# Set GTI file name
		$GtiFile = &SetGtiFileName( $who->{lev2}, $Parms_str{outdir} );
	
		if ( &DoStage(2) && $Task{imgtiscreen} ) {		   
		    # to screen Imaging files we need GTIs generated on HK (XRTfscreen run)
		    if ( &RunXrtscreen($who->{lev1}, "NONE", $mode, $Parms_bool{createattgti}, $Parms_bool{createinstrgti},'no','no', $GtiFile, $obs_mode) ) {
			if ( !$Task{errmess} ) {
			    $Task{errmess} = "ERROR running Stage II on $Modes{$mode}"; }
			&AddReport(3,"$mode: .... Stage  I/II: ERROR\n");

			$PipelineError=1;
			next;
#			goto EXITWITHERROR;

		    }
		}
		
		if ( &RunXrtImage($who->{lev2}, $who->{lev1}, $GtiFile ) ) {
		    &PrntChty(3,"$Task{stem}: ERROR: running xrtimage\n");
		    $Task{errmess} = "ERROR running 'xrtimage' on $evtfile";		
		    &AddReport(3,"$mode: .... Stage  I/II: ERROR\n");
		    $PipelineError=1;
		    next;
#		    goto EXITWITHERROR;
		} # runxrtimage
		if ( -f $who->{lev2} ) {
		    &AddReport(3,"$mode: .... Stage  I/II: created calibrated and cleaned event file: $who->{lev2}\n");
		}
		else {
		    &AddReport(3,"$mode: .... Stage  I/II: WARNING: empty selection for file: $who->{lev1}\n");
		    &AddReport(3,"$mode: .... Stage  I/II: WARNING: no '$who->{lev2}' created\n");
		    next;
		}


		##################################################
		# Update SOFTVER and CALDBVER keywords on Lev2 files 
		##################################################

		if( &UpdateEvtPipeKeys($mode,$who->{lev2}) ){
		    goto EXITWITHERROR;
		}


	        my ( $SkyImageFileName ) = $who->{lev2};
		$SkyImageFileName =~ s/rw/sk/ ;
		$SkyImageFileName =~ s/$Default{XRTIMAGEOUTSTEM}// ;
		# call SwiftXform to transform images coordinates from raw to sky
		if ( &RunSwiftXform($who->{lev2}, $SkyImageFileName) ){
		    &PrntChty(3,"$Task{stem}: ERROR: running swiftxform\n");
		    $Task{errmess} = "ERROR running 'swiftxform' on $evtfile";		
		    &AddReport(3,"$mode: .... Stage  I/II: ERROR\n");
		    $PipelineError=1;
		    next;
#		    goto EXITWITHERROR;
		} # runswiftxform

		&PrntChty(3,"\n============================================================\n");
		&PrntChty(3,"$Task{stem}: Stage I/II: $who->{lev2} calibrated\n");
		&PrntChty(3,"============================================================\n\n");
		
	    } # first stage
	    
	    if ( &DoStage(3) ) {
		
		my ( $SkyImageFileName ) = $who->{lev2};
		$SkyImageFileName =~ s/rw/sk/ ;
		$SkyImageFileName =~ s/$Default{XRTIMAGEOUTSTEM}// ;

		if ( $mode ne "im" ){
		    &PrntChty(3,"\n============================================================\n");
		    &PrntChty(3,"$Task{stem}: Stage III: Creating $SkyImageFileName image\n");
		    &PrntChty(3,"============================================================\n\n");
		}

#		$Task{pcexpofile} = "NONE";
		
		if ( &RunXrtProducts($SkyImageFileName,$mode) ) {
		    &AddReport(3,"$mode: .... Stage   III: ERROR 'xrtproducts', no image generated for '$SkyImageFileName'\n");
		    goto STAGEIIIERROR;
		}
		
		if ( $mode ne "im" ){
		    &PrntChty(3,"\n============================================================\n");
		    &PrntChty(3,"$Task{stem}: Stage III: Created $SkyImageFileName image\n");
		    &PrntChty(3,"============================================================\n\n");
		}

	    } # third stage
	    
	} # imaging processing
	

	else {    

	    if ( &DoStage(1) ) {
		
		&PrntChty(3,"\n============================================================\n");
		&PrntChty(3,"$Task{stem}: Stage I: Calibrating $who->{lev1out}\n");
		&PrntChty(3,"============================================================\n\n");


		##################################################
		# Update SOFTVER and CALDBVER keywords on Lev1 files 
		##################################################

		if( &UpdateEvtPipeKeys($mode,$who->{lev1out}) ){
		    goto EXITWITHERROR;
		}


		&ResetStatusAndBp($who->{lev1out}, $mode);
		if ( $Task{status} ) {
		    $Task{errmess} = "ERROR cannot clean '$who->{lev1out}' from previous runs";
		    &AddReport(3,"$mode: .... Stage   I: ERROR\n");
		    $PipelineError=1;
		    next;
		}

		if ( &RunStageI($who->{lev1out}, $who->{lev1a}, $mode ) ) {
		    if ( !$Task{errmess} ) {
			$Task{errmess} = "ERROR running Stage 1 on $Modes{$mode}"; }
		    &AddReport(3,"$mode: .... Stage   I: ERROR\n");
		    $PipelineError=1;
		    next;
#		    goto EXITWITHERROR;
		}
		elsif ( $Task{status} == 2 ) { 
		    if ( &DoStage(2) ) { &AddReport(3,"$mode: .... Stage III: WARNING: no screening performed on '$who->{lev1out}' file\n");}
		    if ( &DoStage(3) ) { &AddReport(3,"$mode: .... Stage III: WARNING: no products generated for '$who->{lev1out}' file\n");}
		    next; }

		if ( $mode eq "pc" ) {
		    &AddReport(3,"$mode: .... Stage   I: Calibrated Event File: $who->{lev1out}\n");
		    $outlev1file =$who->{lev1out};}
		else {
		    &AddReport(3,"$mode: .... Stage   I: Calibrated Event File: $who->{lev1a}\n");
		    $outlev1file =$who->{lev1a}}

		##################################################
		# Clean Lev1a files 
		##################################################

		if ( &CompUL( $Parms_bool{cleancols}, "yes" ) ) { 

		    my @columns ;

		    if ( $mode eq "wt" ) { @columns = @wt_l1a_collist; }
		    elsif ( $mode eq "lr" || $mode eq "pu" ) { @columns = @pd_l1a_collist; }

		    &PrntChty(3,"$Task{stem}: Info: Cleaning $outlev1file from columns\n");
		    &delFitsCol($outlev1file,"EVENTS",@columns);
##########;;;;;;;
		    if ( $Task{status} ) { goto EXITWITHERROR; }

		}

		&PrntChty(3,"\n============================================================\n");
		&PrntChty(3,"$Task{stem}: Stage I: $who->{lev1out} calibrated\n");
		&PrntChty(3,"============================================================\n\n");
		
	    } # Stage I

	    if ( $mode eq "pc" ) {$outlev1file =$who->{lev1out};}
	    elsif ( $mode ne "im" ) {$outlev1file =$who->{lev1a}}
	    
	    if ( &DoStage(2) ) {
		&PrntChty(3,"============================================================\n");
		&PrntChty(3,"$Task{stem}: Stage II: Screening $outlev1file\n");
		&PrntChty(3,"============================================================\n");
		
		if ( ! -f $outlev1file ) {
		    &PrntChty(3,"$Task{stem}: ERROR: $outlev1file not found\n");
		    $Task{errmess} = "ERROR running Stage II on $Modes{$mode}";		
		    &AddReport(3,"$mode: .... Stage  II: ERROR\n");
		    $PipelineError=1;
		    next;
#		    goto EXITWITHERROR;
		}

		# Set GTI file name
		$GtiFile = &SetGtiFileName( $who->{lev2}, $Parms_str{outdir} );

		if ( &RunXrtscreen($outlev1file, $who->{lev2}, $mode, $Parms_bool{createattgti}, $Parms_bool{createinstrgti},$Parms_bool{evtgtiscreen},$Parms_bool{evtscreen},$GtiFile, $obs_mode) ) {
		    if ( !$Task{errmess} ) {
			$Task{errmess} = "ERROR running Stage II on $Modes{$mode}"; }
		    &AddReport(3,"$mode: .... Stage  II: ERROR\n");
		    $PipelineError=1;
		    next;
#		    goto EXITWITHERROR;
		}
		elsif ( $Task{status} == 2 ) {
		    &PrntChty(3,"\n============================================================\n");
		    &PrntChty(3,"$Task{stem}: Stage II: Empty Screening for $outlev1file\n");
		    &PrntChty(3,"============================================================\n\n");
		    &AddReport(3,"$mode: .... Stage  II: WARNING: empty Screening for '$who->{lev1out}' file\n");
		    if ( &DoStage(3) ) { &AddReport(3,"$mode: .... Stage III: WARNING: No products generated for '$who->{lev1out}' file\n");}
		    next;
		}
		elsif ( $Task{status} == 3 ) {
		    &PrntChty(3,"\n============================================================\n");
		    &PrntChty(3,"$Task{stem}: Stage II: No screening performed on '$who->{lev1out}' file\n");
		    &PrntChty(3,"============================================================\n\n");
		    &AddReport(3,"$mode: .... Stage  II: WARNING: No screening performed on '$who->{lev1out}' file\n");
		    if ( &DoStage(3) ) { &AddReport(3,"$mode: .... Stage III: WARNING: No products generated for '$who->{lev1out}' file\n");}
		    next;
		}
		else {
		    &PrntChty(3,"\n============================================================\n");
		    &PrntChty(3,"$Task{stem}: Stage II: $outlev1file Screened\n");
		    &PrntChty(3,"============================================================\n\n");
		}

		##################################################
		# Clean Lev2 files 
		##################################################

		if ( &CompUL( $Parms_bool{cleancols}, "yes" ) ) { 

		    my @columns ;

		    if ( $mode eq "wt" ) { @columns = @wt_l2_collist; }
		    elsif ( $mode eq "lr" || $mode eq "pu" ) { @columns = @pd_l2_collist; }
		    elsif ( $mode eq "pc" ) { @columns = @pc_l2_collist; }

		    &PrntChty(3,"$Task{stem}: Info: Cleaning $who->{lev2} from columns\n");
		    &delFitsCol($who->{lev2},"EVENTS",@columns);

		    if ( $Task{status} ) { goto EXITWITHERROR; }

		}

	    } # Stage II

	    if ( &DoStage(3) ) {

		&PrntChty(3,"===================================================================\n");
		&PrntChty(3,"$Task{stem}: Stage III: Generating '$who->{lev2}' products and images\n");
		&PrntChty(3,"===================================================================\n");

		if ( !-f $who->{lev2} ) {
		    &PrntChty(2,"$Task{stem}: ERROR: '$who->{lev2}' not found\n");
		    $Task{errmess} = "ERROR '$who->{lev2}' not found. Cannot generate products";
		    &AddReport(3,"$mode: .... Stage III: Cannot generate products on '$who->{lev2}'\n");
		    goto STAGEIIIERROR;
		}

                # If datamode PC and obs mode pointing create expomap if createexpomap set to yes
		my ($ExpoFile, $InstrMap);

		if ( (($mode eq "pc" ) || ($mode eq "wt")) )
		{
		    if ( $obs_mode eq $Default{POINTVALUE} || $obs_mode eq $Default{SETTLINGVALUE} ) {
		    
			if ( $Task{createexpomap} ) {

			    my ($ExpoFile, $InstrMap) = &RunXrtExpoMap($who->{lev2},$mode);
			    if($Task{status})
			    {			
				&AddReport(2,"$mode: .... Stage III: ERROR 'xrtexpomap', no exposure map generated for '$who->{lev2}'\n");
				goto STAGEIIIERROR;
			    } 
			    
			    $Task{pcexpofile} = "NONE";
			    $Task{wtexpofile} = "NONE";
			    $Task{instrmap} = "NONE";
			    
			    if($mode eq "pc" )
			    {
				$Task{pcexpofile}=$ExpoFile;
				$Task{instrmap}=$InstrMap;
			    }
			    else
			    {
				$Task{wtexpofile}=$ExpoFile;
				$Task{instrmap}=$InstrMap;
			    }
			}
			elsif ( $Task{useexpomap} ) {
		
			    &PrntChty(2,"$Task{stem}: Error: 'createexpomap' input parameter set to no,\n");
			    &PrntChty(2,"$Task{stem}: Error: but 'useexpomap' input parameter set to yes\n");
			    &PrntChty(2,"$Task{stem}: Error: cannot correct ARF by the exposure map\n");
			    &AddReport(2,"$mode: .... Stage III: ERROR no exposure map generated for '$who->{lev2}' but 'useexpomap' set to yes\n");
			    goto STAGEIIIERROR;
			}
		    } 
		    else {
			&AddReport(3,"$mode: .... Stage III: No Exposure Map Generated for '$obs_mode' data\n");
			$Task{pcexpofile} = "NONE";
			$Task{wtexpofile} = "NONE";
			$Task{instrmap} = "NONE";
		    }
		}

#
#  20/12/2004 FT - Allow processing of slewing data for all datamodes
#
#		if ( $obs_mode eq $Default{POINTVALUE} || ( $obs_mode eq $Default{SETTLINGVALUE} && $mode eq "lr" ) ) {
		if ( ( $obs_mode ne $Default{SLEWVALUE} ) && ( &CompUL($Parms_bool{extractproducts},"yes") ) ) {
		    if ( &RunXrtProducts($who->{lev2},$mode) ) {
			&AddReport(3,"$mode: .... Stage III: ERROR 'xrtproducts', no products generated for '$who->{lev2}'\n");
			goto STAGEIIIERROR;
		    }
		    else {
			&AddReport(3,"$mode: .... Stage III: Processed '$who->{lev2}'\n");
		    }
		    
		    if( ($mode eq "pc" || $mode eq "wt") && $Task{correctlc} )
		    {

			if( $Parms_bool{extended} =~ /[yY]/ ){
			    &AddReport(3,"$mode: .... Stage III: Light-curve not corrected\n");
			}
			else{
			    if ( $obs_mode eq $Default{POINTVALUE} || $obs_mode eq $Default{SETTLINGVALUE} ) 
			    {
				if ( &RunXrtLcCorr($who->{lev2},$mode) ) 
				{
				    &AddReport(3,"$mode: .... Stage III: ERROR 'xrtlccorr', no corrected Light Curve generated for '$who->{lev2}'\n");
				    goto STAGEIIIERROR;
				}
			    }
			    
			    else {
				&AddReport(3,"$mode: .... Stage III: No correction of lc foreseen for '$obs_mode' data\n");
			    }
			}

		    }
		
		    &PrntChty(3,"\n============================================================\n");
		    &PrntChty(3,"$Task{stem}: Stage III: '$who->{lev2}'\n");
		    &PrntChty(3,"============================================================\n\n");
		}
	    
		else {
		    &AddReport(3,"$mode: .... Stage III: No products foreseen for '$obs_mode' data\n");
		}
		next;
	      STAGEIIIERROR:
		&PrntChty(3,"\n============================================================\n");
		&PrntChty(3,"$Task{stem}: Stage III: ERROR: generating '$who->{lev2}' Products\n");
		if ( $Task{errmess} ) {
		    &PrntChty(3,"$Task{stem}: Stage III: $Task{errmess}\n");
		}
		$PipelineError = 1;
		&PrntChty(3,"============================================================\n\n");
		&PrntChty(3,"$Default{LLINE}");
		}# Stage III
	    } # Event file processing
	} # Loop on event files
}	# Loop on datamode

if ( !$Procmade ) {
    &PrntChty(2,"$Task{stem}: WARNING No Event File(s) found\n"); 
    &PrntChty(2,"$Task{stem}: WARNING Notting to be done\n");
    &AddReport(3,"WARNING No Event File(s) found\n"); 
    &AddReport(3,"WARNING Nothing to be done\n");
}


 ENDPIPELINE:
    #
    # end of xrtpipeline
    #
    my ( $EndDate ) = `date`;
    print $Report;
    if ( $PipelineError ) { 
    	print"=============================================================================================\n";
    	print"$Task{'stem'}: ERROR: Pipeline exit with errors - $EndDate";
    	print"=============================================================================================\n";
    	print"=============================================================================================\n\n";
	print"  If the XRTDAS software was helpful for your research work, the following\n";
	print"  acknowledgement would be appreciated: \"This research has made use of the\n";
	print"  XRT Data Analysis Software (XRTDAS) developed under the responsibility\n";
	print"  of the ASI Science Data Center (ASDC), Italy.\"\n\n";
    	print"=============================================================================================\n";
    	print"=============================================================================================\n\n";
    	exit(1);
    }
else {
    print"=============================================================================================\n";
    print"$Task{'stem'}: Exit with no errors - $EndDate";
    print"=============================================================================================\n";
    print"=============================================================================================\n\n";
    print"  If the XRTDAS software was helpful for your research work, the following\n";
    print"  acknowledgement would be appreciated: \"This research has made use of the\n";
    print"  XRT Data Analysis Software (XRTDAS) developed under the responsibility\n";
    print"  of the ASI Science Data Center (ASDC), Italy.\"\n\n";
    print"=============================================================================================\n";
    print"=============================================================================================\n\n";
    exit (0);
    }


EXITWITHERROR:
    print $Report;
    print"==================================== xrtpipeline error ======================================\n";
    print"$Task{'stem'} $Task{errmess}\n";
    print"=============================================================================================\n";
    print"=============================================================================================\n\n";
    print"  If the XRTDAS software was helpful for your research work, the following\n";
    print"  acknowledgement would be appreciated: \"This research has made use of the\n";
    print"  XRT Data Analysis Software (XRTDAS) developed under the responsibility\n";
    print"  of the ASI Science Data Center (ASDC), Italy.\"\n\n";
    print"=============================================================================================\n";
    print"=============================================================================================\n\n";
    exit(1);

#-------------------------------------------------------------------


sub GetInputParameters {

    use vars qw( %Task  %Parms_str %Parms_num %Parms_bool );

# Scan input for indir parameters

    foreach $name (@ARGV) {
	
	my $Found = 0;
    

	# check into string parameter list
	for $par ( keys %Parms_str ) {
	    if ( $name =~ /^$par=/ ) {
		$Parms_str{$par} = GetInputParam ( $name );
		if ( $Task{status} ) { return 1; }
		$Found = 1;
		last;
	    }
	}
	
	# if !$Found check into integer parameter list
	if ( !$Found ) {
	    for $par ( keys %Parms_num ) {
		if ( $name =~ /^$par=/ ) {
		    $Found = 1;
		    $Parms_num{$par} = GetInputParam ( $name );
		    if ( $Task{status} ) { return 1; }
		    if ( $par =~ "chatter" ) {
			if ( $Parms_num{$par} < 0 ) {$Parms_num{$par} = 0;}
			if ( $Parms_num{$par} > 5 ) {$Parms_num{$par} = 5;}
		    }
		    elsif ( $par =~ "entrystage" || $par =~ "exitstage") {
			if ( $Parms_num{$par} <= 0 || $Parms_num{$par} > 3 ) {
			    &PrntCkty(2,"$Task{'stem'}: ERROR: Input parameter '$par' out of range [1,3].\n");
			    exit (1);
			}
		    }
		    last;
		}
	    }
	} 
	
	# if !$Found check into boolean parameter list
	if ( !$Found ) {
	    for $par ( keys %Parms_bool ) {
		if ( $name =~ /^$par=/ ) {
		    $Found = 1;
		    $Parms_bool{$par} = GetInputParam ( $name );
		    if ( $Task{status} ) { return 1; }
		    last;
		}
	    }
	}
	
	if (!$Found) {
	    print"\n$Task{'stem'}: ERROR: parsing input parameter '$name'\n";
	    print"$Task{'stem'}: ERROR: Parameter name '$name' not found or sintax error\n";
	    print"$Task{'stem'}: ERROR: Please specify input parameters with format: \n";
	    print"$Task{'stem'}: ERROR: <parametername>=<value> without blanks\n";
	    print"\nType 'fhelp $Task{'name'}' for more information on parameters\n\n";
	    return 1;
	}
    }


# get the invoking string, if it exists, to pass to pquery2 for parsing
    
# We quote each element since existing quotes have been stripped and we
# need to pass this on to pquery with quotes intact

    my ($i,$invokestring);
    $invokestring = "";
    if( @ARGV ) {
	foreach $i (0 .. $#ARGV) {
	    $ARGV[$i] = "\"".$ARGV[$i]."\"";
	}
	$invokestring = join(' ',@ARGV);
    }

#
# pquery2 returns the value of the named parameter on
# stdout, prompting if necessary directly to /dev/tty
# Any command line arguments must be passed along.
#
    
# Get input 'srcra'

    if ( !$Parms_str{srcra} && $Parms_str{srcra} !~ "0" ) {
	my ($Stringa) = "";
	chop($Stringa = qx(pquery2 xrtpipeline srcra $invokestring));
	if ( !$Stringa && $Stringa !~ "0" ) {
	    print "ERROR: error running: 'pquery2 xrtpipeline srcra $invokestring'\n";
	    return 1;
	}
	$Parms_str{srcra} = $Stringa;
    }

# Get Input 'srcdec'

    if ( !$Parms_str{srcdec} && $Parms_str{srcdec} !~ "0" ) {
	my ($Stringa) = "";
	chop($Stringa = qx(pquery2 xrtpipeline srcdec $invokestring));
	if ( !$Stringa && $Stringa !~ "0" ) {
	    print "ERROR: error running: 'pquery2 xrtpipeline srcdec $invokestring'\n";
	    return 1;
	}
	$Parms_str{srcdec} = $Stringa;
    }

# Get Input 'indir'

    if ( !$Parms_str{indir} && $Parms_str{indir} !~ "0" ) {
	my ($Stringa) = "";
	chop($Stringa = qx(pquery2 xrtpipeline indir $invokestring));
	if ( !$Stringa && $Stringa !~ "0" ) {
	    print "ERROR: error running: 'pquery2 xrtpipeline indir $invokestring'\n";
	    return 1;
	}
	$Parms_str{indir} = $Stringa;
    }

# Get Input 'steminputs'

    if ( !$Parms_str{steminputs} && $Parms_str{steminputs} !~ "0" ) {
	my ($Stringa) = "";
	chop($Stringa = qx(pquery2 xrtpipeline steminputs $invokestring));
	if ( !$Stringa && $Stringa !~ "0" ) {
	    print "ERROR: error running: 'pquery2 xrtpipeline steminputs $invokestring'\n";
	    return 1;
	}
	$Parms_str{steminputs} = $Stringa;
    }

# Get Input 'outdir'

    if ( !$Parms_str{outdir} && $Parms_str{outdir} !~ "0" ) {
	my ($Stringa) = "";
	chop($Stringa = qx(pquery2 xrtpipeline outdir $invokestring));
	if ( !$Stringa && $Stringa !~ "0" ) {
	    print "ERROR: error running: 'pquery2 xrtpipeline outdir $invokestring'\n";
	    return 1;
	}
	$Parms_str{outdir} = $Stringa;
    }

    for $par ( keys %Parms_str ) {
	if ( !$Parms_str{$par} && $Parms_str{$par} !~ "0" ) {
	    my ($Stringa) = "";
	    chop($Stringa = qx(pquery2 xrtpipeline $par $invokestring));
	    if ( !$Stringa && $Stringa !~ "0" ) {
		print "ERROR: error running: 'pquery2 xrtpipeline $par $invokestring'\n";
		return 1;
	    }
	    $Parms_str{$par} = $Stringa;
	}
    }

    for $par ( keys %Parms_num ) {
	if ( (!$Parms_num{$par} && $Parms_num{$par}!=0 ) || $Parms_num{$par} == $Default{'NOTVALDPARNUMB'} ) {
#	print "$par: $Parms_num{$par}\n";
	    $IntBool = "";
	    chop($IntBool = `pquery2 xrtpipeline $par`);
	    if ( !$IntBool && $IntBool != 0 ) {
		print "ERROR: error running: 'pquery2 xrtpipeline $par'\n";
		return 1;
	    }
	    $Parms_num{$par} = $IntBool;
	}
    }
    
    for $par ( keys %Parms_bool ) {
	if ( !$Parms_bool{$par} || ($Parms_bool{$par} eq $Default{'NOTVALDPARBOOL'})) {
#	print "$par: $Parms_bool{$par}\n";
	    $IntBool = "";
	    chop($IntBool = `pquery2 xrtpipeline $par`);
	    if ( !$IntBool ) {
		print "ERROR: error running: 'pquery2 xrtpipeline $par'\n";
		return 1;
	    }
	    $Parms_bool{$par} = $IntBool;
	}
    }
    
    $Task{status} = 0;
    $Parms_bool{runcoordinator} = &SetBool ( $Parms_bool{runcoordinator});
    if ( $Task{status} ) {
	print"\n$Task{'stem'}: ERROR: on 'runcoordinator' specification\n";
	return 1;
    }
    $Task{display} = &SetBool ( $Parms_bool{display});
    if ( $Task{status} ) {
	print"\n$Task{'stem'}: ERROR: on 'display' parameter specification\n";
	return 1;
    }

#
# Check directories existence
#

# cut off the last '/'
    $Parms_str{indir} =~ s/\/$// ;
    $Parms_str{outdir} =~ s/\/$// ;
    
    if ( $Parms_str{indir} !~ /^\// && $Parms_str{indir} !~ /^\./ ) {
	$Parms_str{indir} = "./".$Parms_str{indir};
    }
    
    if ( $Parms_str{outdir} !~ /^\// && $Parms_str{outdir} !~ /^\./ ) {
	$Parms_str{outdir} = "./".$Parms_str{outdir};
    }
    
    if ( !-d  $Parms_str{indir} ) {
	print"\n$Task{'stem'}: ERROR: Input Directory '$Parms_str{indir}' not found\n";
	return 1;
    }
    
    if ( $Parms_str{outdir} eq $Parms_str{indir} ) {
	print"$Task{'stem'}: ERROR: Please do not specify the 'outdir' same as 'indir'\n";
    return 1;
    }

    if ( !-d $Parms_str{outdir} ) {
	if ( &CreateDir($Parms_str{outdir}) ) { return 1; }
    }

    return 0;

} # GetInputParameters


sub RunStageI {

# Return $Task{status}:
#          0 - no errors
#          1 - errors fond: break xrtpipeline run
#          2 - empty file generated: do not continue
#              processing on this file

    my ( $outevtfile, $lev1afile, $mode ) = @_;
    my ( $par, $ret );
    my ( $command, $Tcdlt4 );

    use vars qw( %Task  %InFiles  %Parms_str  %Parms_num  %Parms_bool  %Default );


    &AddReport(3,"$mode: .... Stage   I: Calibrating Level 1 Event File: $outevtfile\n");


    if ( $mode eq "pc" ) {

	if ( &RunXrtPhasCorr($outevtfile) ) { $Task{status} = 1; return 1; }

	# Run coordinator on data modes supported (PC)
	if ($Parms_bool{runcoordinator}) {
	    if ( &RunCoordinator($outevtfile, $mode) ) { $Task{status} = 1; return 1;}
	}
	else {
	    &PrntChty(3,"\n$Task{stem}: WARNING Input parameter 'runcoordinator' set to 'no\n");
	    &PrntChty(3,"$Task{stem}: WARNING task 'coordinator' not run on '$outevtfile'\n");
	}
    } # run coordinator on photon counting if 'runcoordinator=yes'

    # Run 'xrtpcbias' on Photon Counting Mode
    if ( $mode eq "pc" ) {

	if ( &RunXrtPcBias($outevtfile) ) { $Task{status} = 1; return 1; }

	my $xphasco;

	&GetKeyword($outevtfile, "EVENTS" , undef ,"XPHASCO" ,\$xphasco, 1);
	
	if ($Task{status} && $Task{status} != KEY_NO_EXIST) { 
	    &PrntChty(3,"$Task{stem}: WARNING cannot read XPHASCO keyword in file '$outevtfile'\n");
	    $Task{status}=0;
	}
	else{    
	    $Task{status}=0;
	}

	if(!($xphasco =~ /[tT]/)){  
	    &AddReport(3,"$mode: .... Stage   I: WARNING: On-Ground Bias Correction NOT performed\n"); 
	}
	
    }

    # Run xrttimetag on data modes supported
    if ( $mode eq "wt" || $mode eq "lr" || $mode eq "pu") {
	if ( &RunXrttimetag($outevtfile, $mode) ) { $Task{status} = 1; return 1; }
    }

    # Run xrtflagpix on data modes supported
    if ( $mode eq "pc" || $mode eq "wt") {
	if ( &RunXrtflagpix($outevtfile, $mode) ) { $Task{status} = 1; return 1; }
    }
    
    # call fselect to select events for 
    # GTIs computed by xrttimetag task and
    # Run xrtpdcorr on data modes supported

    if ( $mode eq "lr" || $mode eq "pu" || $mode eq "wt" ) {

	if ( &RunFselect($outevtfile,$lev1afile,"gtifilter()") ) { return 1; } 
	# chek if we have generated an empty output file
	if ( &TableEmpty("$lev1afile","EVENTS") ) {
	    if ( $Task{status} ) { return 1; }
	    &AddReport(3,"$mode: .... Stage   I: WARNING: Empty selection for GTIs, break pipeline\n");
	    $Task{status} = 2;
	    return 0;
	}
	# Run 'xrtpdcorr' on LOWRATE and PILEDUP Modes
	if ( $mode eq "lr" || $mode eq "pu" ) {
	    if ( &RunXrtPdCorr($lev1afile, $mode) ) { $Task{status} = 1; return 1; }
	}
	# Run 'xrtwtcorr' on WINDOWED Timing Mode
	if ( $mode eq "wt") {
	    if ( &RunXrtWtCorr($lev1afile) ) { $Task{status} = 1; return 1; }
	}

	# Run xrtevtrec on datamodes supported
	if ( &RunXrtEvtRec($outevtfile, $lev1afile, $mode) ) { $Task{status} = 1; return 1; }
	&AddReport(3,"$mode: .... Stage   I: Created Level 1a Event File: $lev1afile\n");
    }

    # Run xrtpcgrade on data modes supported
    if ( $mode eq "pc") {
	if ( &RunXrtPcGrade($outevtfile, $mode) ) { $Task{status} = 1; return 1; }
	if ( $Task{runxrthotpix} ) {
	    if ( &RunXrtHotPix($outevtfile, $mode) ) { $Task{status} = 1; return 1; }
	}
    } 

    # Run xrtcalcpi on all data modes
    if ( $mode eq "pc" ) { if ( &RunXrtCalcPi($outevtfile, $mode) ) { $Task{status} = 1; return 1; } }
    else { if ( &RunXrtCalcPi($lev1afile, $mode) ) { $Task{status} = 1;	return 1; } }

} # RunStageI


sub SetAttFileName {

    my ( $attfile, $attflag );
    use vars qw ( %InFiles  %Default  %Parms_str %Parms_num %Task);

    if ( &CompUL($Parms_str{attfile},$Default{DEFAULT})) {


	if ( $#{$InFiles{patt}} == 0 ) {
	    $attfile = "$InFiles{patt}[0]";
	}
	else {
	    if ( $#{$InFiles{att}} == -1 ) {
		&PrntChty(2,"$Task{stem}: ERROR: No attitude file found in '$Parms_str{indir}' directory tree\n");
		&PrntChty(2,"$Task{stem}: ERROR: with '$Parms_str{steminputs}' stem\n");
		&PrntChty(2,"$Task{stem}: ERROR: Please set the input parameter 'attfile' to the observation attitude file\n"); 
		$Task{errmess} = "Attitude File not found";
		$Task{status} = 1;
		&AddReport(2,"................. : ERROR attitude file not found\n");
		return;
	    }
	    elsif ( $#{$InFiles{att}} > 0 ) {
		&PrntChty(2,"$Task{stem}: ERROR: Found more than one attitude file in '$Parms_str{indir}' directory tree\n");
		&PrntChty(2,"$Task{stem}: ERROR: This case is not supported.\n"); 
		&PrntChty(2,"$Task{stem}: ERROR: Please set the input parameter 'attfile' to the observation attitude file\n"); 
		$Task{errmess} = "Found more than one attitude file";
		$Task{status} = 1;
		&AddReport(2,"................. : ERROR more than one attitude file found\n");
		return;
	    }
	    else {
		$attfile = "$InFiles{att}[0]";
	    }
	}
    }
    else {
	$attfile = "$Parms_str{attfile}";
    }
    
    &PrntChty(4,"$Task{stem}: Info: The Attitude File will be '$attfile'\n");

    if ( !-f $attfile ) {
	&AddReport(2,"................. : ERROR attitude file '$attfile' not found\n");
	$Task{errmess} = "Attitude File '$attfile' not found";
	$Task{status} = 1;
	return;
    }

    &GetAttitudeATTFLAG($attfile, \$attflag);
    if ($Task{status}){ 
	return;
    }
    
    if( $attflag eq "111" || $attflag eq "101" ){
	&PrntChty(2,"$Task{stem}: ERROR: input attitude file sw*uat.fits not suitable for XRT data processing, use the sw*sat.fits or sw*pat.fits one.\n");
	$Task{errmess} = "Attitude File not appropriate";
	$Task{status} = 1;
	&AddReport(2,"................. : ERROR attitude file '$attfile' not appropriate.\n");
	return;
    }


    return $attfile;

} # SetAttFileName

sub SetStAttFileName {

    my ( $attfile, $attflag );
    use vars qw ( %InFiles  %Default  %Parms_str %Parms_num %Task);

    if ( &CompUL($Parms_str{stattfile},$Default{DEFAULT})) {
	if ( $#{$InFiles{statt}} == -1 ) {
	    &PrntChty(2,"$Task{stem}: WARNING: No attitude file for settling found in '$Parms_str{indir}' directory tree\n");
	    &PrntChty(2,"$Task{stem}: WARNING: with '$Parms_str{steminputs}' stem\n");
	    return;
	}
	elsif ( $#{$InFiles{statt}} > 0 ) {
	    &PrntChty(2,"$Task{stem}: WARNING: Found more than one attitude file for settling in '$Parms_str{indir}' directory tree\n");
	    &PrntChty(2,"$Task{stem}: WARNING: This case is not supported.\n"); 
	    return;
	}
	else {
	    $attfile = "$InFiles{statt}[0]";
	}
    }
    else {
	$attfile = "$Parms_str{stattfile}";
    }
    &PrntChty(4,"$Task{stem}: Info: The Attitude File for SETTLING data will be '$attfile'\n");


    if ( !-f $attfile ) {
	&AddReport(2,"................. : ERROR attitude file '$attfile' not found\n");
	$Task{errmess} = "Attitude File '$attfile' not found";
	$Task{status} = 1;
	return;
    }

    &GetAttitudeATTFLAG($attfile, \$attflag);
    if ($Task{status}){ 
	return;
    }
    
    if( ($attflag eq "111") || ($attflag eq "101") || ($attflag eq "100") ){
	&PrntChty(2,"$Task{stem}: ERROR: input attitude file not suitable for XRT settling data processing, use the the sw*pat.fits one.\n");
	$Task{errmess} = "Attitude File not appropriate";
	$Task{status} = 1;
	&AddReport(2,"................. : ERROR attitude file '$attfile' not appropriate.\n");
	return;
    }

    return $attfile;

} # SetStAttFileName


sub SetTeldefFileName {

    my ( $teldeffile ) = @_;

    use vars qw ( %Task  %InFiles  %Default  %Parms_str );

    if ( &CompUL($Parms_str{teldef},$Default{CALDB}) ) {

	my ($refa,$refb) = &CallQuzcif("TELDEF",$Task{StartDate},$Task{StartTime},"-",1);
	if ( $Task{status} ) {
	    &PrntChty(2,"$Task{stem}: ERROR: cannot retrieve TELDEF file name from CALDB\n");
	    return;
	}
	if ( @$refb[0] != 0 ) {
	    &PrntChty(2,"$Task{stem}: ERROR: on 'teldef' file format\n");
	    $Task{status} = 1;
	    return;
	}
	$teldeffile = @$refa[0];
    }
    else {
	$teldeffile = $Parms_str{teldef};
    }

    if ( !-f $teldeffile ) {
	&AddReport(2,"................. : ERROR teldef file '$teldeffile' not found\n");
	$Task{errmess} = "Telescope Definition File '$teldeffile' not found";
	$Task{status} = 1;
	return;
    }

    return $teldeffile;

} # SetTeldefFileName


sub SetLev1EvtFileName {

    my ( $filename, $mode ) = @_;
    my ( $totevtfile, $totevtfilenozip ); 
    my ( $dummy );
    my ( $zipevt ) = 0;
    use vars qw (%Task  %Parms_str  %Parms_num %Default  %InFiles );

    my ( $filenopath ) = &ErasePath($filename);

    if ( !&CompUL($Parms_str{stemoutputs},$Default{DEFAULT})) {
	$totevtfile = &SetLev1EvtStem( $filenopath, $mode );
	$totevtfile = "$Parms_str{outdir}/$totevtfile";
    }
    else {
	$totevtfile = "$Parms_str{outdir}/$filenopath";
    }

    # Set no compressed output file name
    if ( $totevtfile =~ /(.gz|.Z)$/ ) {
	$totevtfilenozip = substr($totevtfile,0,rindex($totevtfile,'.'));
	$zipevt = 1;
    }
    else { $totevtfilenozip = $totevtfile; }

    if ( $Parms_num{entrystage} == 1 ) {
	if ( $mode eq "im" ) {
	    my ( $imoutstem ) = $Default{XRTIMAGEOUTSTEM};
	    my ( $extension ) = ".img"; 
	    # erase the file extension
	    if ( rindex($totevtfilenozip,'.') >= 1 ) {
		$totevtfile = substr($totevtfilenozip,0,rindex($totevtfilenozip,'.'));
		$extension = substr($totevtfilenozip,rindex($totevtfilenozip,'.')+1);
	    }
	    else { $totevtfile = $totevtfilenozip; }

	    # add subfiz and extension
	    $totevtfile = $totevtfile.$imoutstem.".".$extension;

	    # check file existence and clobber
	    if ( -f $totevtfile && !$Task{clobber} ) {
		&PrntChty(3, "$Task{stem}: ERROR: the '$totevtfile' exists\n");
		&PrntChty(3, "$Task{stem}: ERROR: please delete '$totevtfile' or\n");
		&PrntChty(3, "$Task{stem}: ERROR: set the input parameter 'clobber' to 'yes'\n");
		$Task{errmess} = "'clobber' parameter set to 'no'";
		$Task{status} = 1;
		return ;
	    }
	    return $totevtfile;
	}
    }

    if ( $Parms_num{entrystage} == 1 ) {

	&PrntChty(3,"$Task{stem}: Info: output event file name: $totevtfile\n");

	if ( $Task{evtfromarc} ) {

	    if ( ! -f $totevtfile || ( -f $totevtfile && $Task{clobber} )) {
		if ( system("/bin/cp -f $filename $totevtfile") ) {
		    &PrntChty(3, "$Task{stem}: ERROR: copying '$filename' in $totevtfile\n");
		    $Task{status} = 1;
		    return ;
		}
		if ( ! chmod 0644 , $totevtfile)  {
		    &PrntChty(3, "$Task{stem}: ERROR: changing priority on '$totevtfile' file: $!\n");
		    $Task{status} = 1;
		    return ;
	    }
		
	    }
	    elsif ( -f $totevtfile ) {
		&PrntChty(3, "$Task{stem}: ERROR: cannot overwrite output file '$totevtfile'\n");
		&PrntChty(3, "$Task{stem}: ERROR: Please set input parameter 'clobber' to yes\n");
		$Task{errmess} = "Cannot overwrite output file '$totevtfile'";
		$Task{status} = 1;
		return;
	    }
	    if ( $zipevt ) {
		&PrntChty(3,"$Task{stem}: Info: The input Level 1 event file is compressed\n");
		&PrntChty(3,"$Task{stem}: Info: Unzip the file to allow FTOOLS processing\n");
		if ( -f $totevtfilenozip && !$Task{clobber} ) {
		    &PrntChty(3, "$Task{stem}: ERROR: the '$totevtfilenozip' exists\n");
		    &PrntChty(3, "$Task{stem}: ERROR: cannot unzip $totevtfile\n");
		    &PrntChty(3, "$Task{stem}: ERROR: please delete '$totevtfilenozip' or\n");
		    &PrntChty(3, "$Task{stem}: ERROR: set the input parameter 'clobber' to 'yes'\n");
		    $Task{errmess} = "'clobber' parameter set to 'no'";
		    $Task{status} = 1;
		    return ;
		}

		if ( system("gunzip -fq $totevtfile") ) {
		    if($? != 512){
			&PrntChty(3, "$Task{stem}: ERROR: cannot unzip the file $totevtfile\n");
			&PrntChty(3, "$Task{stem}: ERROR: command: gunzip -fq $totevtfile : $!\n");
			$Task{status} = 1;
			return ;
		    }
		}
		$totevtfile = $totevtfilenozip;
	    }
	}
    } # If EntryStage == 1
    else {
	if ( $zipevt ) {
	    $totevtfile = $totevtfilenozip;
	}
    }
#    if ( ! -f $totevtfile ) {
#	 &PrntChty(1,"$Task{stem}: ERROR: file '$totevtfile' not found, please run stage 1\n");
#	 $Task{errmess} = "$Task{stem}: ERROR file '$totevtfile' not found, please run stage 1 first";
#	 $Task{status} = 1;
#	 return ;
#    }
    return $totevtfile;

} # SetLev1EvtFileName

sub RunCoordinator {

    my ( $outevtfile, $mode ) = @_;
    my ( $command, $ret, $Tcdlt4, $attflag);

    &RunningSub("RunCoordinator","coordinator","on '$outevtfile'");

    # Set the coordinator input teldef file (coordinator does not
    # support teldef=CALDB)
    
    &PrntChty(3,"RunCoordinator: input 'coordinator' teldef file: $Task{teldef}\n");

    my ( %coordinator ) = (
			   eventfile       => $outevtfile,
			   eventext        => $Parms_str{eventext},
			   timecol         => $Parms_str{timecol},
			   skyxnull        => $Default{SKYNULL},
			   skyynull        => $Default{SKYNULL},
			   attfile         => $Task{evtattfile},
			   teldef          => $Task{teldef},
			   aberration      => $Parms_bool{aberration},
			   follow_sun      => $Parms_bool{follow_sun},
			   ra              => $Task{ranom},
			   dec             => $Task{decnom},
			   randomize       => $Parms_bool{randomizecoordinator},
			   seed            => $Parms_num{seedcoordinator},
			   timemargin      => $Parms_num{timemargin},
			   interpolation   => $Task{interpolation},
			   history         => $Parms_bool{history},
			   );

    $command = "coordinator";
    for $par ( keys %coordinator ) { $command .= " $par=$coordinator{$par}"; } 
	
    if ( $Task{ranom} == $Default{NOTVALDPARNUMB} || 
	 $Task{decnom} == $Default{NOTVALDPARNUMB} ) {
	&PrntChty(2,"$Task{stem}: WARNING cannot run coordinator\n");
	&PrntChty(4,"$Task{stem}: WARNING coordinator command was: $command\n");
	$Parms_num{runcoordinator} = 0;
	return 0;
    }

    &RunningComm("RunCoordinator",$command);
	
    $ret = 0;
    $ret = system( $command );
	
    if ( $ret != 0 ) {
	&ErrorComm("RunCoordinator","coordinator",$command);
        $Task{errmess} = "ERROR running 'coordinator'";
	$Task{status} = 1;
	return 1;
    }

    &GetAttitudeATTFLAG($Task{evtattfile}, \$attflag);
    if ($Task{status})
    { 
	goto error_runcoordinator; 
    }

    # Open Output file and perform some checks

    my ($fptr,$status) = (0,0);

    fits_open_file($fptr,$coordinator{eventfile},READWRITE,$status);
    if ($status) {
	$Task{status} = 1;
	$Task{errmess} = "Unable to open fits file : $coordinator{eventfile}\n";
	return 1;
    }

    fits_update_key($fptr,TSTRING,"ATTFLAG",$attflag,"Attitude type flag", $status);
    if ( $status ) {
	$Task{status} = 1;
	$Task{errmess} = "Cannot update keyword 'ATTFLAG' of '$coordinator{eventfile}' file";
	goto error_runcoordinator;
    }
    
    fits_movnam_hdu($fptr,ANY_HDU,"EVENTS",0,$status);
    if ($status) {
	$Task{status} = 1;
	$Task{errmess} = "Cannot move into '$coordinator{eventfile}' file, extension 'EVENTS'";
	goto error_runcoordinator;
    }

    fits_update_key($fptr,TLOGICAL,$Default{'XRTDETXY_KEY_NAME'},$Default{'XRTDETXY_KEY_VAL'},"Are DETX/Y coordinates computed (T/F)?", $status);
    if ( $status ) {
	$Task{status} = 1;
	$Task{errmess} = "Cannot update keyword '$Default{'XRTDETXY_KEY_NAME'}' of '$coordinator{eventfile}' file";
	goto error_runcoordinator;
    }

    fits_update_key($fptr,TLOGICAL,$Default{'XRTSKYXY_KEY_NAME'},$Default{'XRTSKYXY_KEY_VAL'},"Are X/Y coordinates computed (T/F)?", $status);
    if ( $status ) {
	$Task{status} = 1;
	$Task{errmess} = "Cannot update keyword '$Default{'XRTSKYXY_KEY_NAME'}' of '$coordinator{eventfile}' file";
	goto error_runcoordinator;
    }

    fits_update_key($fptr,TSTRING,"ATTFLAG",$attflag,"Attitude type flag", $status);
    if ( $status ) {
	$Task{status} = 1;
	$Task{errmess} = "Cannot update keyword 'ATTFLAG' of '$coordinator{eventfile}' file";
	goto error_runcoordinator;
    }

# Get X,Y column numbers

    my ( $colx, $coly, $comm );

    fits_get_colnum($fptr,0,"X",$colx,$status);
    if ($status) { 
	$Task{status} = 1;
	$Task{errmess} = "Error getting 'X' column number";
	goto error_runcoordinator;
    }

    fits_get_colnum($fptr,0,"Y",$coly,$status);
    if ($status) { 
	$Task{status} = 1;
	$Task{errmess} = "Error getting 'Y' column number";
	goto error_runcoordinator;
    }

    # Add TNULL keywords for X,Y columns with 'skyxnull' and 'skyynull' values
    # this should be done by 'coordinator' (TBD)

    my ( $tnullx, $tnully );

    $tnullx = 0;
    $tnully = 0;

    fits_read_key($fptr,TLONG,"TNULL$colx",$tnullx,$comm,$status);
    if ( $status == KEY_NO_EXIST ) {
	$status = 0;
	fits_update_key($fptr, TLONG, "TNULL$colx", $Default{SKYNULL}, $Default{DUMMY_KEY_COMM}, $status );
	if ( $status ) {
	    $Task{status} = 1;
	    $Task{errmess} = "Cannot update 'TNULL$colx' keyword";
	    goto error_runcoordinator;
	}    
    }
    elsif ( $status ) {
	$Task{status} = 1;
	$Task{errmess} = "Cannot read 'TNULL$colx' keyword";
	goto error_runcoordinator;
    }
    elsif ( $tnullx != $Default{SKYNULL} ) {
	fits_update_key($fptr, TLONG, "TNULL$colx", $Default{SKYNULL}, $Default{DUMMY_KEY_COMM}, $status );
	if ( $status ) {
	    $Task{status} = 1;
	    $Task{errmess} = "Cannot update 'TNULL$colx' keyword";
	    goto error_runcoordinator;
	}    
    }

    fits_read_key($fptr,TLONG,"TNULL$coly",$tnully,$comm,$status);
    if ( $status == KEY_NO_EXIST ) {
	$status = 0;
	fits_update_key($fptr, TLONG, "TNULL$coly", $Default{SKYNULL}, $Default{DUMMY_KEY_COMM}, $status );
	if ( $status ) {
	    $Task{status} = 1;
	    $Task{errmess} = "Cannot update 'TNULL$coly' keyword";
	    goto error_runcoordinator;
	}    
    }
    elsif ( $status ) {
	$Task{status} = 1;
	$Task{errmess} = "Cannot read 'TNULL$coly' keyword";
	goto error_runcoordinator;
    }
    elsif ( $tnully != $Default{SKYNULL} ) {
	fits_update_key($fptr, TLONG, "TNULL$coly", $Default{SKYNULL}, $Default{DUMMY_KEY_COMM}, $status );
	if ( $status ) {
	    $Task{status} = 1;
	    $Task{errmess} = "Cannot update 'TNULL$coly' keyword";
	    goto error_runcoordinator;
	}    
    }

    # end of work: update current HDU checksum
    fits_write_chksum($fptr,$status);
    if ( $status ) {
	 $Task{status} = 1;
	 $Task{errmess} = "Cannot update HDU 'EVENTS' checksum: $status";
	 goto error_runcoordinator;
    }    


    # Update ATTFLAG keyword in all the extensions

    my ($numext);
    fits_get_num_hdus($fptr,$numext,$status);
    if ($status) {
	$Task{status} = 1;
	$Task{errmess} = "Cannot get number of extensions from '$coordinator{eventfile}' file";
	goto error_runcoordinator;
    }

    for (my $i = 1; $i <= $numext; $i++) {

	fits_movabs_hdu($fptr,$i,ANY_HDU,$status);
	if ($status) {
	    $Task{status} = 1;
	    $Task{errmess} = "Cannot move to extensions $i in '$coordinator{eventfile}' file";
	    goto error_runcoordinator;
	}
	
	fits_update_key($fptr,TSTRING,"ATTFLAG",$attflag,"Attitude type flag", $status);
	if ( $status ) {
	    $Task{status} = 1;
	    $Task{errmess} = "Cannot update keyword 'ATTFLAG' of '$coordinator{eventfile}' file";
	    goto error_runcoordinator;
	}

	fits_write_chksum($fptr,$status);
	if ( $status ) {
	    $Task{status} = 1;
	    $Task{errmess} = "Cannot update HDU 'EVENTS' checksum: $status";
	    goto error_runcoordinator;
	}
    }



error_runcoordinator:

    # close fits file
    if ( $fptr ) {
	$status = 0;
	fits_close_file($fptr,$status);
	if ( $status ) { 
	    $Task{status} = 1;
	    $Task{errmess} = "Cannot close '$coordinator{eventfile}' event file";
	    return 1;
	}
	if ( $Task{status} ) { print"$Task{errmess}\n"; return 1; }
    }

    &SuccessSub("RunCoordinator","coordinator","'$coordinator{eventfile}' updated");

    return 0;


    
} # RunCoordinator


sub RunXrtflagpix {

    my ( $evtfile, $mode ) = @_;
    my ( $command, $ret, $Tcdlt4, $dir, $stem, %xrtflagpix );
    my ( $OutBpFile );

    use vars qw ( %Parms_str );

    # set the stem of output files

    if ( &CompUL($Parms_str{stemoutputs},$Default{DEFAULT}) ) {
	$stem = $Parms_str{steminputs}; }
    else { $stem = $Parms_str{stemoutputs}; }

    # Define Output Bad Pixel File Name
    my ( $filenoext ) = substr($evtfile,0,rindex( $evtfile, '.' ));
    my ( $ext ) = substr($evtfile,rindex( $evtfile, '.' ));
    $OutBpFile = $filenoext."bp.fits";

    my $TmpFile = substr($evtfile,0,rindex($evtfile,'.')).".tmp";
    if ( -f $TmpFile ) { unlink ($TmpFile); }

    %xrtflagpix = (
		   infile       => $evtfile,
		   bpfile       => $Parms_str{bpfile},
		   hdfile       => $Task{hkfilecorr},
		   srcfile      => $Parms_str{srcfile},
		   userbpfile   => $Parms_str{userbpfile},
		   bptable      => $Parms_str{bptable},
		   thrfile      => $Parms_str{thrfile},
		   phas1thr     => $Parms_num{phas1thr},
		   maxtemp      => $Parms_num{pcmaxtemp},
		   outbpfile    => $OutBpFile,
		   outfile      => $TmpFile,
		   overstatus   => $Parms_bool{overstatus},
		   chatter      => $Parms_num{chatter},
		   clobber      => $Parms_bool{clobber},
		   history      => $Parms_bool{history},
		   );

    
    $command = "xrtflagpix";
    for $par ( keys %xrtflagpix ) { $command .= " $par=$xrtflagpix{$par}"; } 

    &RunningSub("RunXrtflagpix","xrtflagpix", "on $evtfile");
    &RunningComm("RunXrtflagpix",$command);

    $ret = 0;
    $ret = system( $command );

    if ( $ret != 0 ) {
	&ErrorComm("RunXrtflagpix","xrtflagpix",$command);
        $Task{errmess} = "ERROR running 'xrtflagpix'";
        &PrntChty(2,"$Task{'stem'}: ERROR: running 'xrtflagpix' on '$evtfile'\n");
	$Task{status} = 1;
	return 1;
    }

    if ( &DelAndRename($TmpFile, $evtfile) ) { return 1; }

    &SuccessSub("RunXrtflagpix","xrtflagpix","'$evtfile' updated");

    return 0;

} # RunXrtflagpix

sub RunXrtPcGrade {

    my( $evtfile, $mode ) = @_;
    my ( $command, $ret, %xrtpcgrade );

    my $TmpFile = substr($evtfile,0,rindex($evtfile,'.')).".tmp";
    if ( -f $TmpFile ) { unlink ($TmpFile); }

    %xrtpcgrade = (
		 infile    => $evtfile,
		 outfile   => $TmpFile,
		 thrfile   => $Parms_str{thrfile},
		 split     => $Parms_num{pcsplit},
		 gradefile => $Parms_str{gradefile},
		 ascagrade => $Parms_bool{ascagrade},
		 hdfile    => $Task{hkfilecorr},
		 clobber   => $Parms_bool{clobber},
		 history   => $Parms_bool{history},
		 chatter   => $Parms_num{chatter},
		 );

    $command = "xrtpcgrade";
    for $par ( keys %xrtpcgrade ) { $command .= " $par=$xrtpcgrade{$par}"; } 

    &RunningSub("RunXrtPcGrade","xrtpcgrade","on $evtfile");
    &RunningComm("RunXrtPcGrade",$command);

    $ret = 0;
    $ret = system( $command );

    if ( $ret != 0 ) {
	&ErrorComm("RunXrtPcGrade","xrtpcgrade",$command);
        $Task{errmess} = "ERROR running 'xrtpcgrade'";
	&PrntChty(2,"$Task{'stem'}: ERROR: running 'xrtpcgrade' on '$evtfile'\n");
	$Task{status} = 1;
	return 1;
    }

    if ( &DelAndRename($TmpFile, $evtfile) ) { return 1; }

    &SuccessSub("RunXrtPcGrade","xrtpcgrade","'$evtfile' updated");

    return 0;

} # RunXrtPcGrade

sub RunXrtCalcPi {

    my( $evtfile, $mode ) = @_;
    my ( $command, $ret, %xrtcalcpi );
    my ( $gainfile, $gainnom, $offset );

    if ( $mode eq "pc" ) {
	$gainfile = $Parms_str{pcgainfile};
	$gainnom  = $Parms_num{pcgainnom};
	$offset   = $Parms_num{pcoffset};
    }
    elsif ( $mode eq "wt" ) {
	$gainfile = $Parms_str{wtgainfile};
	$gainnom  = $Parms_num{wtgainnom};
	$offset   = $Parms_num{wtoffset};
    }
    elsif ( $mode eq "lr" || $mode eq "pu" ) {
	$gainfile = $Parms_str{pdgainfile};
	$gainnom  = $Parms_num{pdgainnom};
	$offset   = $Parms_num{pdoffset};
    }

    my $TmpFile = substr($evtfile,0,rindex($evtfile,'.')).".tmp";
    if ( -f $TmpFile ) { unlink ($TmpFile); }

    %xrtcalcpi = (
		  infile       => $evtfile,
		  outfile      => $TmpFile,
		  hdfile       => $Task{hkfilecorr},
		  gainfile     => $gainfile,
		  seed         => $Parms_num{seedxrtcalcpi},
		  randomflag   => $Parms_bool{randomizexrtcalcpi},
		  gainnom      => $gainnom,
		  offset       => $offset,
                  corrtype     => $Parms_str{picorrtype},
		  userctcorrpar=> "no",
		  savepinom    => $Parms_bool{savepinom},
		  clobber      => $Parms_bool{clobber},
		  history      => $Parms_bool{history},
		  chatter      => $Parms_num{chatter},
		  );

    $command = "xrtcalcpi";
    for $par ( keys %xrtcalcpi ) { $command .= " $par=$xrtcalcpi{$par}"; } 

    &RunningSub("RunXrtcalcpi","xrtcalcpi", "on  '$evtfile'");
    &RunningComm("RunXrtcalcpi",$command);

    $ret = 0;
    $ret = system( $command );

    if ( $ret != 0 ) {
	&ErrorComm("RunXrtcalcpi","xrtcalcpi",$command);
	&PrntChty(2,"$Task{'stem'}: ERROR: running 'xrtcalcpi' on '$evtfile'\n");
	$Task{errmess}="Error running 'xrtcalcpi' on '$evtfile'";
	$Task{status} = 1;
	return 1;
    }

    if ( &DelAndRename($TmpFile, $evtfile) ) { return 1; }

    &SuccessSub("RunXrtcalcpi","xrtcalcpi","'$evtfile' updated");

    return 0;

} # RunXrtCalcPi


sub RunXrtfilter {

    my ( $mode, $ranom, $decnom ) = @_;
    my ( $par, $ret );
    my ( $command, %xrtfilter );

    use vars qw ( %Task  %InFiles  %Parms_str  %Parms_num  %Parms_bool  %Default );

    $Parms_str{outfile} = &GetAttOrbFileName($Parms_str{outfile},$Parms_str{stemoutputs},$Parms_str{steminputs} );
    if ( $Task{status} ) {
	&PrntChty(3,"$Task{stem}: Please specify the output Attitude Orbit File Name by 'outfile' input parameter\n");
	return 1;
    }

    # Get output make filter file name

    $Parms_str{mkffile} = &SetFileName( $Parms_str{mkffile} , $Parms_str{stemoutputs}, $Parms_str{steminputs},
					$Default{MKFILEEXTENSION}, $Parms_str{outdir} );


    # Get input orbname file name
    if ( &CompUL( $Parms_str{orbfile} , $Default{DEFAULT} ) ) {
	if ( $#{$InFiles{tle}} == -1 ) {
	    &PrntChty(2,"$Task{stem}: ERROR: No input orbit file fond in '$Parms_str{indir}' directory tree\n");
	    &PrntChty(2,"$Task{stem}: ERROR: with 'SWIFT_TLE_ARCHIVE.txt' stem\n");
	    &PrntChty(2,"$Task{stem}: ERROR: Please set the input parameter 'orbfile' to the observation orbit file\n"); 
	    $Task{errmess} = "Orbit File 'SWIFT_TLE_ARCHIVE.txt' not found";
	    $Task{status} = 1;
	    &AddReport(2,"................. : ERROR orbit file not found\n");
	    return 1;
	}
	elsif ( $#{$InFiles{tle}} > 0 ) {
	    &PrntChty(2,"$Task{stem}: ERROR: Found more than one orbit file in '$Parms_str{indir}' directory tree\n");
	    &PrntChty(2,"$Task{stem}: ERROR: This case is not supported.\n"); 
	    &PrntChty(2,"$Task{stem}: ERROR: Please set the input parameter 'orbfile' to the observation orbit file\n"); 
	    $Task{errmess} = "Found more than one orbit file with 'SWIFT_TLE_ARCHIVE.txt' stem";
	    $Task{status} = 1;
	    &AddReport(2,"................. : ERROR more than one orbit file found\n");
	    return 1;
	}
	else {
	    # unzip the file if needed
	    if ( $InFiles{tle}[0] =~ /(.gz|.Z)$/ ) {

		my ( $filenopath ) = &ErasePath($InFiles{tle}[0]);
		if ( system ( "cp -f  $InFiles{tle}[0] $Parms_str{outdir}/$filenopath") ) {
		    &PrntChty(3, "$Task{stem}: ERROR: copying '$InFiles{tle}[0]' in '$Parms_str{outdir}/$filenopath'\n");
		    $Task{status} = 1;
		    return ;
		}
		if ( system ( "gunzip -fq $Parms_str{outdir}/$filenopath\n" ) ) {
		    if($? != 512){
			&PrntChty(3, "$Task{stem}: ERROR: running 'gunzip -fq $Parms_str{outdir}/$filenopath'\n");
			$Task{status} = 1;
			return ;
		    }
		}

		my ( $filenozip ) = substr($filenopath,0,rindex($filenopath,'.'));
		$InFiles{tle}[0] = "$Parms_str{outdir}/$filenozip";

	    }
	    $Parms_str{orbfile} = "$InFiles{tle}[0]";
	}
    }

    &PrntChty(3,"$Task{stem}: Info: Using TLE file: '$Parms_str{orbfile}'\n");

    if ( !-f $Parms_str{orbfile} ) {
	$Task{status} = 1;
	&PrntChty(3,"$Task{stem}: ERROR: Orbit file '$Parms_str{orbfile}' needed to 'prefilter' not found.\n");
	&PrntChty(3,"$Task{stem}: ERROR: Please set parameter 'orbfile' to a valid TLE File Name\n");
	$Task{errmess} = "TLE file '$Parms_str{orbfile}' not found";
	return 1;
    }

    # ERROR on makefilter 'clobber=yes' does not work
    # delete .mkf file before the 'xrtscreen' call if
    # exists and clobber set

    if ( $Task{clobber} && -f "$Parms_str{mkffile}" ) {
	PrntChty(3,"$Task{stem}: Info: Delete \"$Parms_str{mkffile}\" file\n");
	if ( !unlink("$Parms_str{mkffile}") ) {
	    PrntChty(3,"$Task{stem}: WARNING Cannot Unlink \"$Parms_str{mkffile}\". $!\n");
	}
    }

    %xrtfilter = (
		  hdfile       => $Task{hkfilecorr},
		  enfile       => $Task{enfile},
		  outdir       => $Parms_str{outdir},
		  outfile      => $Parms_str{outfile},
		  outcols      => $Parms_str{outcols},
		  orbmode      => $Parms_str{orbmode},
		  orbfile      => $Parms_str{orbfile},
		  attfile      => $Task{attfilecorr},
		  leapfile     => $Parms_str{leapfile},
		  rigfile      => $Parms_str{rigfile},
		  alignfile    => $Task{scteldef},
		  interval     => $Parms_num{interval},
		  ranom        => $ranom,
		  decnom       => $decnom,
		  origin       => $Parms_str{origin},
		  mkfconfigfile => $Parms_str{mkfconfigfile},
		  configfile    => $Parms_str{configfile},
		  hdstem       => $Default{NONE},
		  mkffile      => "$Parms_str{mkffile}",
#		  tprec        => $Parms_num{tprec},
		  nonulls      => "yes",
		  gtiexpr      => "\"$Parms_str{mkfgtiexpr}\"",
		  chatter      => $Parms_num{chatter},
		  clobber      => $Parms_bool{clobber},
		  history      => $Parms_bool{history}
		  );
    
    
    $command = "xrtfilter";
    for $par ( keys %xrtfilter ) { $command .= " $par=$xrtfilter{$par}"; } 

    &RunningSub("RunXrtfilter","xrtfilter");
    &RunningComm("RunXrtfilter",$command);

    $ret = 0;
    $ret = system( $command );

    if ( $ret != 0 ) {
	&ErrorComm("RunXrtfilter","xrtfilter",$command);
        $Task{errmess} = "ERROR running 'xrtfilter'";
	$Task{status} = 1;
	return 1;
    }
    &AddReport(3,"$mode: .... Created: Attitude Orbit File $Parms_str{outdir}/$Parms_str{outfile}\n");
    &AddReport(3,"$mode: .... Created: Makefilter Configuration File $Parms_str{mkffile}\n");
    &SuccessSub("RunXrtfilter","xrtfilter","'$Parms_str{outdir}/$Parms_str{outfile}' and '$Parms_str{mkffile}' created");
    return 0;

} # RunXrtfilter

sub RunXrtscreen {

# $Task{status} = 2 if xrtscreen do not generate level 2 file but no errors are
#                   generated so probably due to an empty selection

    my ( $EvtFile, $OutEvt, $mode, $CreateAttGti, $CreateInstrGti, 
	 $Gtiscreen,  $Evtscreen, $GtiFileName, $obs_mode) = @_;

    my ( $par, $ret );
    my ( $command, %xrtscreen );

    use vars qw ( %Task  %InFiles  %Parms_str  %Parms_num  %Parms_bool  %Default );

    my ( $UsrGtiFile ) = $Parms_str{usrgtifile};
    if ( $Gtiscreen =~ "no" ) {$UsrGtiFile = $Default{NONE};}

    &RunningSub("RunXrtscreen","xrtscreen"," on '$EvtFile'");

    my ( $expr ) = "none";
    my ( $exprgrade ) = "none";

    if ( $mode ne "im" ) {
	my ( $tmpmode ) = $mode;
	if ( $mode eq "lr" || $mode eq "pu" ) { $tmpmode = "pd"; }
	my ( $str ) = "expr" . $tmpmode;
	$expr = $Parms_str{$str};
	$str .= "grade";
	$exprgrade = $Parms_str{$str};
    }

    if ( $obs_mode ne $Default{POINTVALUE} ) {

	############################################################
	# If the data are coming from slews (SLEW) or in 10 arc min
	# of the source (SETTLING) the data have not to be
	# screened by attitude parameters
	###########################################################
	&AddReport(3,"$mode: .... Stage  II: No GTIs generated on attitude values for '$obs_mode' data\n");
	&PrntChty(3,"$Task{stem}: Info: No GTIs generated on attitude parameters for '$obs_mode' data\n");  
	$CreateAttGti = "no";

    }

    %xrtscreen = (
		  gtiexpr         => "\"$Parms_str{gtiexpr}\"",
		  expr            => $expr,
		  exprgrade       => $exprgrade,
		  infile          => $EvtFile,
		  outdir          => $Parms_str{outdir},
		  createattgti    => $CreateAttGti,
		  createinstrgti  => $CreateInstrGti,
		  gtiscreen       => $Gtiscreen,
		  obsmodescreen   => $Parms_bool{obsmodescreen},
		  acsscreen       => $Parms_bool{acsscreen},
		  evtscreen       => $Evtscreen,
		  hkrangefile     => $Parms_str{hkrangefile},
		  evtrangefile    => $Parms_str{evtrangefile},
		  mkffile         => "$Parms_str{mkffile}",
		  gtifile         => $GtiFileName,
		  usrgtifile      => $UsrGtiFile,
		  gtiext          => $Parms_str{gtiext},
		  chatter         => $Parms_num{chatter},
		  outfile         => $OutEvt,
		  timecol         => $Parms_str{timecol},
		  cleanup      => $Parms_bool{cleanup},
		  history      => $Parms_bool{history},
		  clobber      => $Parms_bool{clobber},
		  );
    
    if ( &CompUL($Gtiscreen,"no") && &CompUL($Evtscreen,"no") ) { 
	&PrntChty(4,"$Task{stem}: WARNING: 'gtiscreen' and 'evtscreen' set to 'no'\n");
	&PrntChty(4,"$Task{stem}: WARNING: No Level 2 Event File will be Created\n");
	$xrtscreen{outfile} = "none"; 
	$OutEvt = "none";
	$Task{status} = 3;
    }

    if ( &CompUL($CreateAttGti,"no") && &CompUL($CreateInstrGti,"no") ) { 
	&PrntChty(2,"$Task{stem}: WARNING: 'createattgti' and 'createinstrgti' set to 'no'\n");
	&PrntChty(2,"$Task{stem}: WARNING: No Hk and Instrument screening made on '$EvtFile' file\n");
	&PrntChty(2,"$Task{stem}: WARNING: and No gti file '$GtiFileName' created\n");
#	$xrtscreen{gtiscreen} = "no"; 
	$xrtscreen{mkffile} = "none"; 
	$xrtscreen{gtifile} = "none"; 
	$xrtscreen{hkrangefile} = "none"; 
    }

    $command = "xrtscreen";
    for $par ( keys %xrtscreen ) { $command .= " $par=$xrtscreen{$par}"; } 

    &RunningComm("RunXrtscreen",$command);

    $ret = 0;
    $ret = system( $command );

    if ( $ret != 0 ) {
	&ErrorComm("RunXrtscreen","xrtscreen",$command);
        $Task{errmess} = "ERROR running 'xrtscreen'";
	$Task{status} = 1;
	return 1;
    }
    if ( -f $OutEvt ) { 
	&AddReport(3,"$mode: .... Stage  II: Created Filtered Level 2 Event File '$OutEvt'\n"); 
    }
    elsif ( !&CompUL($OutEvt,$Default{NONE}) ){
	&AddReport(3,"$mode: .... Stage  II: WARNING: No Filtered Level 2 Event File '$OutEvt' created\n"); 
	$Task{status} = 2;
    }
    &SuccessSub("RunXrtscreen","xrtscreen");

    return 0;

} # RunXrtscreen

sub RunXrttimetag {

    my ( $EvtFile, $mode ) = @_;
    my ( $par, $ret );
    my ( $command, %xrttimetag );
    my ( $ranom, $decnom );

    use vars qw ( %Task  %InFiles  %Parms_str  %Parms_num  %Parms_bool  %Default );

    my $usehkkey = "yes";

    if ( $Task{usesrcdettimetag} != $Task{usesrcdethkproc} ) { $usehkkey = "no"; }

    my $TmpFile = substr($EvtFile,0,rindex($EvtFile,'.')).".tmp";
    if ( -f $TmpFile ) { unlink ($TmpFile); }

    %xrttimetag = (
		  infile       => $EvtFile,
		  outfile      => $TmpFile,
		  hdfile       => $Task{hkfilecorr},
		  trfile       => $Task{trfile},
		  attfile      => $Task{evtattfile},
		  usesrcdet    => $Parms_bool{usesrcdettimetag},
		  usehkkey     => $usehkkey,
                  srcdetx      => $Parms_num{srcdetx},
                  srcdety      => $Parms_num{srcdety},
		  srcra        => $Task{srcra},
		  srcdec       => $Task{srcdec},
		  ranom        => $Task{ranom},
		  decnom       => $Task{decnom},
		  teldef       => $Task{teldef},
		  colfile     => $Parms_str{colfile},
		  npixels      => $Parms_num{npixels},
		  percent      => $Parms_num{percent},
		  aberration   => $Parms_bool{aberration},
		  attinterpol  => $Parms_bool{attinterpol},
		  chatter      => $Parms_num{chatter},
		  history      => $Parms_bool{history},
		  clobber      => $Parms_bool{clobber},
		  );
    
    
    $command = "xrttimetag";
    for $par ( keys %xrttimetag ) { $command .= " $par=$xrttimetag{$par}"; } 

    &RunningSub("RunXrttimetag","xrttimetag");
    &RunningComm("RunXrttimetag",$command);

    $ret = 0;
    $ret = system( $command );

    if ( $ret != 0 ) {
	&ErrorComm("RunXrttimetag","xrttimetag",$command);
        $Task{errmess} = "ERROR running 'xrttimetag'";
	$Task{status} = 1;
	return 1;
    }

    if ( &DelAndRename($TmpFile, $EvtFile) ) { return 1; }

    &SuccessSub("RunXrttimetag","xrttimetag");
    return 0;

} # RunXrttimetag

sub RunXrtPdCorr {

    my ( $EvtFile, $mode ) = @_;
    my ( $par, $ret );
    my ( $command, %xrtpdcorr );

    use vars qw ( %Task  %InFiles  %Parms_str  %Parms_num  %Parms_bool  %Default );

    my $TmpFile = substr($EvtFile,0,rindex($EvtFile,'.')).".tmp";
    if ( -f $TmpFile ) { unlink ($TmpFile); }

    %xrtpdcorr = (
		  infile       => $EvtFile,
		  hdfile       => $Task{hkfilecorr},
		  outfile      => $TmpFile,
		  bias         => $Parms_num{pdbias},
		  nframe       => $Parms_num{pdbiasnframe},
		  nevents      => $Parms_num{pdbiasnevents},
		  nclip        => $Parms_num{pdbiasnclip},
		  nsigma       => $Parms_num{pdbiasnsigma},
		  thrfile      => $Parms_str{thrfile},
                  biasth       => $Parms_num{pdbiasth},
                  biasdiff     => $Parms_num{pdbiasdiff},
		  fittol       => $Parms_num{pdbiasfittol},
		  method       => $Parms_str{pdbiasmethod},
		  biasfile     => $Parms_str{biaspdfile},
		  chatter      => $Parms_num{chatter},
		  history      => $Parms_bool{history},
		  clobber      => $Parms_bool{clobber},
		  );
    
    
    $command = "xrtpdcorr";
    for $par ( keys %xrtpdcorr ) { $command .= " $par=$xrtpdcorr{$par}"; } 

    &RunningSub("RunXrtPdCorr","xrtpdcorr");
    &RunningComm("RunXrtPdCorr",$command);

    $ret = 0;
    $ret = system( $command );

    if ( $ret != 0 ) {
	&ErrorComm("RunXrtPdCorr","xrtpdcorr",$command);
        $Task{errmess} = "ERROR running 'xrtpdcorr'";
	$Task{status} = 1;
	return 1;
    }

    if ( &DelAndRename($TmpFile, $EvtFile) ) { return 1; }

    &SuccessSub("RunXrtPdCorr","xrtpdcorr");
    return 0;

} # RunXrtPdCorr

sub RunXrtWtCorr {

    my ( $EvtFile ) = @_;
    my ( $par, $ret );
    my ( $command, %xrtwtcorr );

    use vars qw ( %Task  %InFiles  %Parms_str  %Parms_num  %Parms_bool  %Default );

    my $TmpFile = substr($EvtFile,0,rindex($EvtFile,'.')).".tmp";
    if ( -f $TmpFile ) { unlink ($TmpFile); }

    %xrtwtcorr = (
		  infile       => $EvtFile,
		  hdfile       => $Task{hkfilecorr},
		  outfile      => $TmpFile,
		  trfile       => $Task{trfile},
		  nevents      => $Parms_num{wtbiasnevents},
		  nframe       => $Parms_num{wtnframe},
                  biasdiff     => $Parms_num{wtbiasdiff},
		  thrfile      => $Parms_str{thrfile},
		  biasth       => $Parms_num{wtbiasth},
                  npixels      => $Parms_num{wtnpixels},
		  biasmode     => $Parms_str{wtbiasmode},
		  colfile      => $Parms_str{colfile},
		  chatter      => $Parms_num{chatter},
		  history      => $Parms_bool{history},
		  clobber      => $Parms_bool{clobber},
		  );
    
    $command = "xrtwtcorr";
    for $par ( keys %xrtwtcorr ) { $command .= " $par=$xrtwtcorr{$par}"; } 

    &RunningSub("RunXrtWtCorr","xrtwtcorr");
    &RunningComm("RunXrtWtCorr",$command);

    $ret = 0;
    $ret = system( $command );

    if ( $ret != 0 ) {
	&ErrorComm("RunXrtWtCorr","xrtwtcorr",$command);
        $Task{errmess} = "ERROR running 'xrtwtcorr'";
	$Task{status} = 1;
	return 1;
    }

    if ( &DelAndRename($TmpFile, $EvtFile) ) { return 1; }

    &SuccessSub("RunXrtWtCorr","xrtwtcorr");
    return 0;

} # RunXrtWtCorr


sub RunXrtPhasCorr {

    my ( $EvtFile ) = @_;
    my ( $par, $ret );
    my ( $command, %xrtphascorr );

    use vars qw ( %Task  %InFiles  %Parms_str  %Parms_num  %Parms_bool  %Default );

    my $TmpFile = substr($EvtFile,0,rindex($EvtFile,'.')).".tmp";
    if ( -f $TmpFile ) { unlink ($TmpFile); }

    %xrtphascorr = (
		  infile       => $EvtFile,
		  outfile      => $TmpFile,
		  phasconffile => $Parms_str{pcphasconffile},
		  chatter      => $Parms_num{chatter},
		  clobber      => $Parms_bool{clobber},
		  history      => $Parms_bool{history},
		  );
    
    $command = "xrtphascorr";
    for $par ( keys %xrtphascorr ) { $command .= " $par=$xrtphascorr{$par}"; } 

    &RunningSub("RunXrtPhasCorr","xrtphascorr");
    &RunningComm("RunXrPhasCorr",$command);

    $ret = 0;
    $ret = system( $command );

    if ( $ret != 0 ) {
	&ErrorComm("RunXrPhasCorr","xrtphascorr",$command);
        $Task{errmess} = "ERROR running 'xrtphascorr'";
	$Task{status} = 1;
	return 1;
    }

    if ( &DelAndRename($TmpFile, $EvtFile) ) { return 1; }

    &SuccessSub("RunXrtPhasCorr","xrtphascorr", "'$EvtFile' updated");
    return 0;

} # RunXrtPhasCorr


sub RunXrtPcBias {

    my ( $EvtFile ) = @_;
    my ( $par, $ret );
    my ( $command, %xrtpcbias );

    use vars qw ( %Task  %InFiles  %Parms_str  %Parms_num  %Parms_bool  %Default );

    my $TmpFile = substr($EvtFile,0,rindex($EvtFile,'.')).".tmp";
    if ( -f $TmpFile ) { unlink ($TmpFile); }

    %xrtpcbias = (
		  infile       => $EvtFile,
		  outfile      => $TmpFile,
		  srcdetx      => -1,
		  srcdety      => -1,
		  srcra        => $Task{srcra},
		  srcdec       => $Task{srcdec},
		  ranom        => $Task{ranom},
		  decnom       => $Task{decnom},
		  teldef       => $Task{teldef},
		  aberration   => $Parms_bool{aberration},
		  attinterpol  => $Parms_bool{attinterpol},
		  attfile      => $Task{evtattfile},
		  mkffile      => $Parms_str{mkffile},
		  subimage     => $Parms_bool{pcbiassubimage},
		  subimgsize   => $Parms_num{pcbiassubimgsize},
		  nevents      => $Parms_num{pcbiasnevents},
		  lessevents   => $Parms_bool{pcbiaslessevents},
		  biasmethod   => $Parms_str{pcbiasmethod},
		  badpix       => $Parms_bool{pcbiasbadpix},
		  grademin     => $Parms_num{pcbiasgrademin},
		  grademax     => $Parms_num{pcbiasgrademax},
		  hdfile       => $Task{hkfilecorr},
		  thrfile      => $Parms_str{thrfile},
		  evtthr       => $Parms_num{pcbiasevtthr},
		  splitthr     => $Parms_num{pcbiassplitthr},
		  biascorr     => $Parms_bool{pcbiascorr},
		  resetcol     => "no",
		  chatter      => $Parms_num{chatter},
		  clobber      => $Parms_bool{clobber},
		  history      => $Parms_bool{history},
		  );
    

    if ( $Task{evtobsmode} eq $Default{SETTLINGVALUE} || $Task{evtobsmode} eq $Default{SLEWVALUE} ) {
	$xrtpcbias{srcdetx} = 300 ;
	$xrtpcbias{srcdety} = 300 ;	
    }


    $command = "xrtpcbias";
    for $par ( keys %xrtpcbias ) { $command .= " $par=$xrtpcbias{$par}"; } 

    &RunningSub("RunXrtPcBias","xrtpcbias");
    &RunningComm("RunXrPcBias",$command);

    $ret = 0;
    $ret = system( $command );

    if ( $ret != 0 ) {
	&ErrorComm("RunXrPcBias","xrtpcbias",$command);
        $Task{errmess} = "ERROR running 'xrtpcbias'";
	$Task{status} = 1;
	return 1;
    }

    if ( &DelAndRename($TmpFile, $EvtFile) ) { return 1; }

    &SuccessSub("RunXrtPcBias","xrtpcbias", "'$EvtFile' updated");
    return 0;

} # RunXrtPcBias


sub RunXrtImage {

    my ( $OutEvtFile, $EvtFile, $GtiFileName) = @_;
    my ( $par, $ret );
    my ( $command, %xrtimage );

    use vars qw ( %Task  %InFiles  %Parms_str  %Parms_num  %Parms_bool  %Default );

    %xrtimage = (
		 infile       => $EvtFile,
		 outfile      => $OutEvtFile,
		 hdfile       => $Task{hkfilecorr},
		 biasfile     => $Parms_str{biasimfile},
		 bias         => $Parms_num{imbias}, 
		 biasdiff     => $Parms_num{imbiasdiff},
		 maxtemp      => $Parms_num{immaxtemp},
		 bpfile       => $Parms_str{bpfile},
		 srcfile      => $Parms_str{srcfile},
		 userbpfile   => $Parms_str{userbpfile},
		 outbpfile    => $Default{DEFAULT},
		 bptable      => $Parms_str{bptable},
		 cleanbp      => $Parms_bool{cleanbp},
		 cleansrc     => $Parms_bool{imcleansrc},
		 subbias      => $Parms_bool{subbias},
		 clobber      => $Parms_bool{clobber},
		 gtiscreen    => $Parms_bool{imgtiscreen},
		 gtifile      => $GtiFileName,
		 chatter      => $Parms_num{chatter},
		 history      => $Parms_bool{history},
		 );
    
    
    $command = "xrtimage";
    for $par ( keys %xrtimage ) { $command .= " $par=$xrtimage{$par}"; } 

    &RunningSub("RunXrtImage","xrtimage");
    &RunningComm("RunXrtImage",$command);

    $ret = 0;
    $ret = system( $command );

    if ( $ret != 0 ) {
	&ErrorComm("RunXrtImage","xrtimage",$command);
        $Task{errmess} = "ERROR running 'xrtimage'";
	$Task{status} = 1;
	return 1;
    }

    &SuccessSub("RunXrtImage","xrtimage");
    return 0;

} # RunXrtImage

sub RunXrtEvtRec {

    my( $evtfile, $outfile, $mode ) = @_;
    my ( $command, $ret, %xrtevtrec );

    my ( $event, $split );

    if ( $mode eq "wt" ) {
	$event = $Parms_num{wtevent};
	$split = $Parms_num{wtsplit};
    }
    else {
	$event = $Parms_num{pdevent};
	$split = $Parms_num{pdsplit};
    }

    $evtfile = $outfile;

    my $TmpFile = substr($evtfile,0,rindex($evtfile,'.')).".tmp";
    if ( -f $TmpFile ) { unlink ($TmpFile); }

    %xrtevtrec = (
		 infile    => $evtfile,
		 hdfile    => $Task{hkfilecorr},
		 outfile   => $TmpFile,
		 gradefile => $Parms_str{gradefile},
		 event     => $event,
		 thrfile   => $Parms_str{thrfile},
		 split     => $split,
		 flagneigh => $Parms_bool{flagneigh},
		 addcol    => $Parms_bool{addcol},
		 delnull   => $Parms_bool{delnull},
		 clobber   => $Parms_bool{clobber},
		 history   => $Parms_bool{history},
		 chatter   => $Parms_num{chatter},
		 );

    $command = "xrtevtrec";
    for $par ( keys %xrtevtrec ) { $command .= " $par=$xrtevtrec{$par}"; } 

    &RunningSub("RunXrtEvtRec","xrtevtrec","on $evtfile");
    &RunningComm("RunXrtEvtRec",$command);

    $ret = 0;
    $ret = system( $command );

    if ( $ret != 0 ) {
	&ErrorComm("RunXrtEvtRec","xrtevtrec",$command);
	&PrntChty(4,"$Task{'stem'}: ERROR: running 'xrtevtrec' on '$evtfile'");
	$Task{errmess} = "Error running 'xrtevtrec' on '$evtfile'";
	$Task{status} = 1;
	return 1;
    }

    if ( &DelAndRename($TmpFile, $evtfile) ) { return 1; }

    &SuccessSub("RunXrtEvtRec","xrtevtrec","'$evtfile' updated");

    return 0;

} # RunXrtEvtRec

sub RunXrtProducts {

    my( $evtfile, $mode ) = @_;
    my ( $command, $ret, %xrtproducts );
    
    my ($regionfile, $rmffile);

    # take the region file name for this mode

    if ( $mode ne "im" ) {
	if ( $mode eq "pc" ) { 
	    %xrtproducts = (
			    binsize      => $Parms_num{pcbinsize},
			    rmffile      => $Parms_str{pcrmffile},
			    regionfile   => $Parms_str{pcregionfile},
			    imagefile    => $Default{DEFAULT},
			    inarffile    => $Parms_str{pcinarffile},
			    expofile     => "NONE",
			    arfboxsize   => $Parms_num{arfboxsize},
			    bkgextract   => "no",
			    );
	    
	    $xrtproducts{transmfile}   = $Parms_str{transmfile};
	    if ( &CompUL($Parms_str{pcregionfile},$Default{DEFAULT} ) ) {
		$xrtproducts{radius} = $Default{XRTPRODUCTS_radius};
		$xrtproducts{ra}     = $Task{srcra};
		$xrtproducts{dec}    = $Task{srcdec};
	    }
	    if ( $Task{useexpomap} ) {
		$xrtproducts{expofile}  = $Task{pcexpofile};
	    }
	}
	elsif ( $mode eq "wt" ) { 
	    %xrtproducts = (
			    binsize    => $Parms_num{wtbinsize},
			    rmffile      => $Parms_str{wtrmffile},
			    regionfile   => $Parms_str{wtregionfile},
			    imagefile    => $Default{DEFAULT},
			    inarffile  => $Parms_str{wtinarffile},
			    expofile     => "NONE",
			    bkgextract   => "no",
			    );


	    if ( $Task{evtobsmode} eq $Default{SETTLINGVALUE} ) {
		$xrtproducts{binsize} =  $Parms_num{stwtbinsize};
	    }

	    if ( &CompUL($Parms_str{wtregionfile},$Default{DEFAULT} ) ) {
#		$xrtproducts{width} = $Default{XRTPRODUCTS_width};
#		$xrtproducts{height} = $Default{XRTPRODUCTS_height};
		$xrtproducts{radius} = $Default{XRTPRODUCTS_radius};
		$xrtproducts{ra}           = $Task{srcra};
		$xrtproducts{dec}          = $Task{srcdec};

#		if ( $Task{rollnom} == $Default{NOTVALIDRADEC} ) {
#		    if ( &CompUL($Parms_str{pntroll},"POINT") || 
#			 ($Parms_str{pntroll}<0 ||  $Parms_str{pntroll}>360)) {
#			&PrntChty(2,"$Task{'stem'}: ERROR: S/C roll angle not correctly set\n");
#			&PrntChty(2,"$Task{'stem'}: ERROR: Please verify 'pntroll' input parameter\n");
#			&PrntChty(4,"$Task{'stem'}: ERROR: 'pntroll' = $Parms_str{pntroll}\n");
#			&PrntChty(4,"$Task{'stem'}: ERROR: 'rollnom' = $Task{rollnom}\n");
#			$Task{errmess} = "S/C roll angle not correctly set";
#			$Task{status} = 1;
#			return 1;
#		    }
#		    else {
#			$xrtproducts{roll} = $Parms_str{pntroll};
#			&PrntChty(3,"$Task{stem}: Info: S/C ROLL from input parameter: $Parms_str{pntroll}(deg)\n");
#			&AddReport(3,"$mode: .... Stage III: Telescope ROLL from input parameter : $Parms_str{pntroll}(deg)\n");
#		    }
#		}
#		else {
#		    $xrtproducts{roll} = $Task{rollnom};
#		}

	    }
	    $xrtproducts{transmfile}   = $Parms_str{transmfile};

	    if ( $Task{useexpomap} ) {
		$xrtproducts{expofile}  = $Task{wtexpofile};
	    }
	}
	elsif ( $mode eq "lr" || $mode eq "pu" ) {
	    %xrtproducts = (
			    binsize    => $Parms_num{pdbinsize},
			    rmffile    => $Parms_str{pdrmffile},
			    inarffile  => $Parms_str{pdinarffile},
			    expofile   => "NONE",
			    );
	    
	    $regionfile = "NONE";
	    $rmffile    = $Parms_str{pdrmffile};
	    $xrtproducts{transmfile}   = $Parms_str{transmfile};
	}

	my ( $headfilename ) ;
	if ( !CompUL($Parms_str{stemoutputs},$Default{DEFAULT}) ) { $headfilename = $Parms_str{stemoutputs}; }
	else { $headfilename = substr(&ErasePath($evtfile),0,20); }

	$xrtproducts{lcfile}       = "${headfilename}sr.lc";
	$xrtproducts{phafile}      = "${headfilename}sr.pha";
	$xrtproducts{arffile}      = "${headfilename}sr.arf";
	$xrtproducts{mirfile}      = $Parms_str{mirfile};
	$xrtproducts{psffile}      = $Parms_str{psffile};
	$xrtproducts{vigfile}      = $Parms_str{vigfile};
	$xrtproducts{psfflag}      = $Parms_bool{psfflag};
	$xrtproducts{gtifile}      = "NONE";
	$xrtproducts{pilow}        = 30;
	$xrtproducts{pihigh}       = 1000;
	$xrtproducts{extended}     = $Parms_bool{extended};

    }
    else {
#	 $xrtproducts{regionfile}       = "NONE";
	 $xrtproducts{expofile}       = "NONE";
    }

    
    $xrtproducts{infile}       = $evtfile;
    $xrtproducts{outdir}       = $Parms_str{outdir};
    $xrtproducts{stemout}      = $Parms_str{stemoutputs};
    $xrtproducts{display}      = $Parms_bool{display};
    $xrtproducts{plotdevice}   = $Parms_str{plotdevice};
    $xrtproducts{correctlc}    = "no";
    $xrtproducts{clobber}      = $Parms_bool{clobber};
    $xrtproducts{chatter}      = $Parms_num{chatter};
    $xrtproducts{history}      = $Parms_bool{history};
    $xrtproducts{cleanup}      = $Parms_bool{cleanup};

    $command = "xrtproducts";
    for $par ( keys %xrtproducts ) { $command .= " $par=$xrtproducts{$par}"; } 

    &RunningSub("RunXrtProducts","xrtproducts","on $evtfile");
    &RunningComm("RunXrtProducts",$command);

    $ret = 0;
    $ret = system( $command );

    if ( $ret != 0 ) {
	&ErrorComm("RunXrtProducts","xrtproducts",$command);
	&PrntChty(2,"$Task{'stem'}: ERROR: running 'xrtproducts' on '$evtfile'");
        $Task{errmess} = "Error running 'xrtproducts' on '$evtfile'";
	$Task{status} = 1;
	return 1;
    }

    if ( $mode ne "im" ) {
	if ( ! -f "$Parms_str{outdir}/$xrtproducts{lcfile}" ) {
	    &AddReport(2,"$mode: .... Stage III: WARNING: Empty Lightcurve\n");
	}
	if ( ! -f "$Parms_str{outdir}/$xrtproducts{phafile}" ) {
	    &AddReport(2,"$mode: .... Stage III: WARNING: Empty Spectrum\n");
	}
	if ( ! -f "$Parms_str{outdir}/$xrtproducts{arffile}" ) {
	    &AddReport(2,"$mode: .... Stage III: WARNING: No Ancillary Response File created\n");
	}
    }


    &SuccessSub("RunXrtProducts","xrtproducts","");

    return 0;

} # RunXrtProducts

sub SetHkfileName {

    use vars qw ( %Parms_str  %Default  %InFiles  %Task %DataFiles);
    my ($HkfileName);

    if ( &CompUL( $Parms_str{hdfile}, $Default{DEFAULT} ) ) {
	if ( $#{$InFiles{hk}} == -1 ) {
	    &PrntChty(2,"$Task{stem}: ERROR: No xhead Files found in '$Parms_str{indir}' directory tree\n");
	    &PrntChty(2,"$Task{stem}: ERROR: Please set the input parameter 'hdfile' to the observation xheader file\n"); 
	    &PrntChty(2,"$Task{stem}: ERROR: Please set the input parameter 'xhead' to the observation xhead file\n"); 
	    $Task{errmess} = "Observation Header File '<yourpath>/swXXXXXXXXXXXxhd.hk' not found";
	    $Task{status} = 1;
	    &AddReport(2,"................. : ERROR hk header file not found\n");
	    return;
	}
	elsif ( $#{$InFiles{hk}} > 0 ) {
	    &PrntChty(2,"$Task{stem}: ERROR: Found more than one xhead file in '$Parms_str{indir}' directory tree.\n"); 
	    &PrntChty(2,"$Task{stem}: ERROR: This case is not supported\n"); 
	    &PrntChty(2,"$Task{stem}: ERROR: Please set the input parameter 'xhead' to the observation xhead file\n"); 
	    $Task{errmess} = "Error finding default observetion header file '<yourpath>/swXXXXXXXXXXXxhd.hk'";
	    $Task{status} = 1;
	    &AddReport(2,"................. : ERROR more than one hk header file found\n");
	    return;
	}
	else {
	    $HkfileName = "$InFiles{hk}[0]";
	}
    }
    else { $HkfileName = $Parms_str{hdfile}; }
    &PrntChty(4,"$Task{stem}: Info: The input Observation Header File will be:\n$Task{stem}: Info: '$HkfileName'\n");
    if ( !-f $HkfileName ) {
	&AddReport(2,"................. : ERROR hk header file not found\n");
	$Task{errmess} = "Observation Header File '$HkfileName' not found";
	$Task{status} = 1;
	return;
    }

    return ($HkfileName);
} # SetHkfileName


sub SetTrfileName {

    use vars qw ( %Parms_str  %Default  %InFiles  %Task %DataFiles);
    my ($TrfileName);

    if ( &CompUL( $Parms_str{trfile}, $Default{DEFAULT} ) ) {
	if ( $#{$InFiles{tr}} == -1 && $EvtFiles{wt}{nfiles} == 0 ) {
	    &PrntChty(2,"$Task{stem}: WARNING: No trailer Files found in '$Parms_str{indir}' directory tree\n");
	    &AddReport(2,"................. : WARNING 'tr.hk' trailer file not found\n");
	    $TrfileName = "none";
	}
	elsif ( $#{$InFiles{tr}} > 0 ) {
	    &PrntChty(2,"$Task{stem}: ERROR: Found more than one xtr.hk file in '$Parms_str{indir}' directory tree.\n"); 
	    &PrntChty(2,"$Task{stem}: ERROR: This case is not supported\n"); 
	    &PrntChty(2,"$Task{stem}: ERROR: Please set the input parameter 'trfile' to the observation trailer file\n"); 
	    $Task{errmess} = "Error finding default observation trailer file '<yourpath>/swXXXXXXXXXXXxtr.hk'";
	    $Task{status} = 1;
	    &AddReport(2,"................. : ERROR more than one xtr.hk trailer file found\n");
	    return;
	}
	elsif($#{$InFiles{tr}} == -1 && $EvtFiles{wt}{nfiles} > 0 )
	{
	    &PrntChty(2,"$Task{stem}: ERROR: No trailer Files found in '$Parms_str{indir}' directory tree\n"); 
	    &PrntChty(2,"$Task{stem}: ERROR: unable to process input WT files\n"); 
	    &PrntChty(2,"$Task{stem}: ERROR: Please set the input parameter 'trfile' to the observation trailer file\n"); 
	    $Task{errmess} = "Error finding default observation trailer file '<yourpath>/swXXXXXXXXXXXxtr.hk'";
	    $Task{status} = 1;
	    &AddReport(2,"................. : ERROR xtr.hk trailer file not found\n");
	    return;
	}
	else {
	    $TrfileName = "$InFiles{tr}[0]";
	}
    }
    else { 
	$TrfileName = $Parms_str{trfile}; 
    }
    &PrntChty(4,"$Task{stem}: Info: The input Observation Trailer File will be:\n$Task{stem}: Info: '$TrfileName'\n");

    return ($TrfileName);
} # SetTrfileName


sub SetEnfileName {

    use vars qw ( %Parms_str  %Default  %InFiles  %Task %DataFiles);
    my ($EnfileName);

    if ( &CompUL( $Parms_str{enfile}, $Default{DEFAULT} ) ) {
	if ( $#{$InFiles{en}} == -1 ) {
	    if($Task{createmkffile}){
		&PrntChty(2,"$Task{stem}: ERROR: No *sen.hk Files found in '$Parms_str{indir}' directory tree\n");
		&PrntChty(2,"$Task{stem}: ERROR: Please set the input parameter 'enfile' to the observation *sen.hk file\n"); 
		$Task{errmess} = "Observation Spacecraft Housekeeping File '<yourpath>/swXXXXXXXXXXXsen.hk' not found";
		$Task{status} = 1;
		&AddReport(2,"................. : ERROR Spacecraft Housekeeping *sen.hk file not found\n");
		return;
	    }
	    else{
		$EnfileName = "none";
	    }
	}
	elsif ( $#{$InFiles{en}} > 0 ) {
	    &PrntChty(2,"$Task{stem}: ERROR: Found more than one *sen.hk file in '$Parms_str{indir}' directory tree.\n"); 
	    &PrntChty(2,"$Task{stem}: ERROR: This case is not supported\n"); 
	    &PrntChty(2,"$Task{stem}: ERROR: Please set the input parameter 'enfile' to the observation *sen.hk file\n"); 
	    $Task{errmess} = "Error finding default Observation Spacecraft Housekeeping File '<yourpath>/swXXXXXXXXXXXsen.hk'";
	    $Task{status} = 1;
	    &AddReport(2,"................. : ERROR more than one Spacecraft Housekeeping *sen.hk file found\n");
	    return;
	}
	else {
	    $EnfileName = "$InFiles{en}[0]";
	}
    }
    else { $EnfileName = $Parms_str{enfile}; }
    &PrntChty(4,"$Task{stem}: Info: The input Observation Spacecraft Housekeeping File will be:\n$Task{stem}: Info: '$EnfileName'\n");
    if ( !-f $EnfileName ) {
	&AddReport(2,"................. : ERROR Spacecraft Housekeeping *sen.hk file not found\n");
	$Task{errmess} = "Observation Spacecraft Housekeeping File '$EnfileName' not found";
	$Task{status} = 1;
	return;
    }

    return ($EnfileName);
} # SetEnfileName


sub SetHkfileCorr {

    #
    # Define 'xrthkproc' output file name;
    #

    my ( $HkfileName ) = @_;
    my ($HkfileCorrName);
    my ( $ind2, $ext );

    my ( $extension ) = "xhdtc.hk";
    my ( $hkstem )    = "tc";

    &PrntChty(3,"$Task{stem}: Info: Get 'xrthkproc' output file name\n");

    if ( &CompUL($Parms_str{stemoutputs},$Default{DEFAULT})) {
	# Add 'tc' before extension
	my $TmpNoPath = &ErasePath($HkfileName);
	$HkfileCorrName = &AddStemBeforeExtension($TmpNoPath, $hkstem);
	if ( $HkfileCorrName =~ /(.gz|.Z)$/ ) {
	    $HkfileCorrName = substr($HkfileCorrName,0,rindex($HkfileCorrName,'.'));
	}
	$HkfileCorrName = "$Parms_str{outdir}/$HkfileCorrName";
    }
    else {
	$HkfileCorrName = "$Parms_str{outdir}/$Parms_str{stemoutputs}".$extension;
    }

    return ($HkfileCorrName);
} # SetHkfileCorr

sub SetAttFileCorr {

    #
    # Define 'xrttam' output file name;
    #

    my ( $AttFileName ) = @_;
    my ($AttFileCorrName);
    my ( $ind2, $ext );

    if ( &CompUL($Parms_str{outdir},$Default{NONE} ) ) {
	if ( &IsCompressed($AttFileName) ) {
	    my ( $ind1 ) = rindex($AttFileName, '.' )-1;
	    $ind2 = rindex(substr( $AttFileName,0, $ind1),'.');
	    $ext = "";
	    if ( $ind2 > 0 ) {
		$ext = substr( $AttFileName, $ind2,$ind1-$ind2+1);
	    }
	}
	else {
	    $ext = "";
	    $ind2 = rindex($AttFileName, '.' )-1;
	    if ( $ind2 > 0 ) {
		$ext = substr( $AttFileName, $ind2);
	    }
	}
	if ( $ind2 > 0 )  {
	    $AttFileCorrName = substr( $AttFileName, 0, $ind2)."tm".$ext ;
	}
	else {
	    $AttFileCorrName = $AttFileName."tm";
	}
    }
    else {
	my ( $extension ) = "tm.fits";
	&PrntChty(3,"$Task{stem}: Info: Get 'xrttam' output file name\n");
	if ( &CompUL($Parms_str{stemoutputs},$Default{DEFAULT})) {
	    my ($nopath, $noext, $nocomp);
	    if ( &IsCompressed($AttFileName) ) {
		my ( $ind1 ) = rindex($AttFileName, '.' );
		$ind2 = rindex(substr( $AttFileName,0, $ind1),'.');
		if ( $ind2 > 0 ) { $nocomp = substr( $AttFileName, 0,$ind2); }
		else { $nocomp = substr( $AttFileName, 0,$ind1); }
	    }
	    else {
		my ( $ind1 ) = rindex($AttFileName, '.' );
		if ( $ind1 > 0 ) { $nocomp = substr( $AttFileName, 0,$ind1); }
		else { $nocomp = $AttFileName;}
	    }
	    $ind2 = rindex($nocomp, '/' )+1;
	    if ( $ind2 > 0 ) { $nopath = substr( $nocomp, $ind2); }
	    else { $nopath = $AttFileName; }

	    $ind2 = rindex($AttFileName, '.' )-1;
	    if ( $ind2 > 0 ) { $noext = substr( $nopath, 0, $ind2); }
	    else { $noext = $nopath; }

	    if ( $Task{status} ) { return 1; }
	    $AttFileCorrName = "$Parms_str{outdir}/$noext$extension";
	}
	else {
	    $AttFileCorrName = "$Parms_str{outdir}/$Parms_str{stemoutputs}" . $extension;
	}
    }

    return ($AttFileCorrName);
} # SetAttFileCorr

sub InitRun {

    use vars qw(%InFiles %Parms_str %EvtFiles %DataFiles %Modes $Report %Default);

    my ( $modes ) = $Parms_str{datamode};

    my ( @modes_array ) = split ( /,/,$modes);
    my ( $thismode );

    foreach $thismode ( @modes_array ) {

	if ( &CompUL($thismode,"ALL") ) {
	    $InFiles{'modelist'} = [ 'im', 'pc', 'wt', 'lr', 'pu' ];
	} 
	elsif ( &CompUL($thismode,"PC") ) {
	    push @{$InFiles{'modelist'}}, 'pc';
	}
	elsif ( &CompUL($thismode,"WT") ) {
	    push @{$InFiles{'modelist'}}, 'wt';
	}
	elsif ( &CompUL($thismode,"PD") ) {
	    push @{$InFiles{'modelist'}}, 'lr';
	    push @{$InFiles{'modelist'}}, 'pu';
	}
	elsif ( &CompUL($thismode,"LR") ) {
	    push @{$InFiles{'modelist'}}, 'lr';
	}
	elsif ( &CompUL($thismode,"PU") ) {
	    push @{$InFiles{'modelist'}}, 'pu';
	}
	elsif ( &CompUL($thismode,"IM") ) {
	    push @{$InFiles{'modelist'}}, 'im';
	}
	else {
	    &PrntChty(3, "$Task{'stem'}: ERROR: input parameter '$thismode' not allowed for parameter 'datamode'\n");
	    &PrntChty(3, "$Task{'emptystem'}  Please specify one of the follows:\n");
	    &PrntChty(3, "$Task{'emptystem'}  ALL - for all modes\n");
	    &PrntChty(3, "$Task{'emptystem'}   PC - for Photon Counting\n");
	    &PrntChty(3, "$Task{'emptystem'}   WT - for Windowed Timing\n");
	    &PrntChty(3, "$Task{'emptystem'}   PU - for Piled Up Photodiode\n");
	    &PrntChty(3, "$Task{'emptystem'}   LR - for Low Rate Photodiode\n");
	    &PrntChty(3, "$Task{'emptystem'}   PD - for Both Photodiode Modes\n");
	    &PrntChty(3, "$Task{'emptystem'}   IM - for Imaging\n");
	    $Task{errmess} = "$Task{'stem'}: Input parameter '$thismode' not allowed for parameter 'datamode'\n";
	    $Task{status} = 1;
	    return 1;
	}

    }

    &AddReport(3,"$Default{SLINE} INPUT/OUTPUT DIRECTORIES $Default{SLINE}\n");
    &AddReport(3,"Input Target Directory                : $Parms_str{indir}\n");
    if ( $Task{evtfromarc} ) {
	&AddReport(3,"Input Events Files Directory          : $Parms_str{indir}\n");
    }
    else {
	&AddReport(3,"Input Events Files Directory          : $Parms_str{outdir}\n");
    }
    &AddReport(3,"Output directory                      : $Parms_str{outdir}\n");
    &AddReport(3,"$Default{SLINE}        INPUT FILES       $Default{SLINE}\n");
    &AddReport(3,"Searching Input Data Files with stem  : $Parms_str{steminputs}\n");

    &PipelineMessage("Retrieving files from Input Target Directory '$Parms_str{indir}'");

    # Read all files from the input directory

    my ( @filelist, @evtlist );

    if (&CheckInclusion($Parms_str{indir},$Parms_str{outdir})) {
	&PrntChty(2, "$Task{'stem'}: ERROR: The output directory cannot be a subdirectory of the input directory\n");
	&PrntChty(2, "$Task{'stem'}: ERROR: Please specify another directory for output\n");
	$Task{errmess} = "'outdir' specification error";
	$Task{status} = 1;
	return 1;
    }

    @filelist = &GetFileList($Parms_str{indir},$Parms_str{steminputs});
    if ( $#filelist == -1 ) {
	&PrntChty(2, "$Task{'stem'}: ERROR: No input files found with '$Parms_str{steminputs}' stem\n");
	&PrntChty(2, "$Task{'stem'}: ERROR: in the '$Parms_str{indir}' directory tree\n");
	$Task{errmess} = "No input files found with '$Parms_str{steminputs}' stem";
	$Task{status} = 1;
	return 1;
    }

    if ( $Task{evtfromarc} ) {
	&PrntChty(2, "$Task{'stem'}: Info: Input parameter 'evtfilesfromarchive' set to 'yes',\n");
	&PrntChty(2, "$Task{'stem'}: Info: getting input event files from the Target Directory:\n");
	&PrntChty(2, "$Task{'stem'}: Info: '$Parms_str{indir}'\n");
	@evtlist = &GetFileList($Parms_str{indir},$Parms_str{steminputs});
	if ( $#evtlist == -1 ) {
	    &PrntChty(2, "$Task{'stem'}: ERROR: No input files found with '$Parms_str{steminputs}' stem\n");
	    &PrntChty(2, "$Task{'stem'}: ERROR: in the '$Parms_str{indir}' directory tree\n");
	    $Task{errmess} = "No input files found with '$Parms_str{steminputs}' stem";
	    $Task{status} = 1;
	    return 1;
	}
    }
    else {
	&PrntChty(2, "$Task{'stem'}: Info: Input parameter 'evtfilesfromarchive' set to 'no',\n");
	&PrntChty(2, "$Task{'stem'}: Info: getting input event files from the Output Directory:\n");
	&PrntChty(2, "$Task{'stem'}: Info: '$Parms_str{outdir}'\n");
	@evtlist = &GetFileList($Parms_str{outdir},$Parms_str{steminputs});
	if ( $#evtlist == -1 ) {
	    &PrntChty(2, "$Task{'stem'}: ERROR: No input files found with '$Parms_str{steminputs}' stem\n");
	    &PrntChty(2, "$Task{'stem'}: ERROR: in the '$Parms_str{outdir}' directory tree\n");
	    $Task{errmess} = "No input files found with '$Parms_str{steminputs}' stem";
	    $Task{status} = 1;
	    return 1;
	}
    }

    my ( $file, $filenopath );

    foreach $file ( @evtlist ) {

	$filenopath = &ErasePath($file);

	# check if it is an event file
	for $mode ( keys %EvtFiles) {

	    $filenopath =~ 
		/($Parms_str{steminputs}$EvtFiles{$mode}{fnamemtc}|$Parms_str{steminputs}$EvtFiles{$mode}{fnamemtc}.gz)$/ 
		    && do { push @{$InFiles{$mode}}, $file; goto NEXTFILE;}
	}

      NEXTFILE:

    }

    foreach $file ( @filelist ) {

	$filenopath = &ErasePath($file);

	# check if it is an event file
	for $mode ( keys %DataFiles) {

	    $filenopath =~ 
		/($Parms_str{steminputs}$DataFiles{$mode}{fnamemtc}|$Parms_str{steminputs}$DataFiles{$mode}{fnamemtc}.gz)$/ 
		    && do { push @{$InFiles{$mode}}, $file; }
	}

      NEXTFILE:

    }


    my (@tlefile, $tle);

    @tlefile = &GetFileList($Parms_str{indir},"SWIFT_TLE_ARCHIVE.txt");
    foreach $tle (@tlefile) {
	$mode = "tle";
	$filenopath = &ErasePath($tle);
	$filenopath =~ 
	    /($DataFiles{$mode}{fnamemtc}|$DataFiles{$mode}{fnamemtc}.gz)$/ 
		&& do { push @{$InFiles{$mode}}, $tle; }
    }


    my ( $foundevt ) = 0 ;
    foreach $mode ( @{$InFiles{'modelist'}} ) {
	if ( $#{$InFiles{$mode}} == -1 ) { next; }
	$foundevt = 1;
    }

    if ( !$foundevt ) {
	&PrntChty(2, "$Task{'stem'}: WARNING: No Event files found under '$Parms_str{indir}' directory tree\n");
	&PrntChty(2, "$Task{'stem'}: WARNING: with '$Parms_str{steminputs}' stem.\n");
	&PrntChty(2, "$Task{'stem'}: WARNING: No data processing neede\n");
	goto ENDPIPELINE;
    }

    # Set common variables needed

    $Task{entrystage} = $Parms_num{entrystage};
    $Task{exitstage} = $Parms_num{exitstage};
    if ( $Task{entrystage} > $Task{exitstage} ) {
	PrntChty(3, "$Task{stem}: ERROR: Input parameter 'entrystage'=$Task{entrystage} larger then 'exitstage'=$Task{exitstage}\n");
	$Task{errmess} = "Input Parameters 'entrystage' and 'exitstage'";
	$Task{status} = 1;
	return 1;
    }
    
    # Get Attitude File Name
    
    $Task{attfile} = &SetAttFileName;
    if ( $Task{status} ) { return 1; };
    &AddReport(3,"Attitude File Name                    : $Task{attfile}\n");

    # Get Attitude File Name (SETTLING obsmode)
    
    $Task{stattfile} = &SetStAttFileName;
    if ( $Task{status} ) { return 1; };
    &AddReport(3,"Attitude File Name for SETTLING data  : $Task{stattfile}\n");

    # Get HK 'xhead' file name
    $Task{hkfile} = &SetHkfileName;    
    if ( $Task{status} ) { return 1 };
    &AddReport(3,"HK Header File Name                   : $Task{hkfile}\n");

    # Get StartDate and StartTime from hd file

    my ( $StartDate, $StartTime );
    &GetHdStartDate($Task{hkfile},\$StartDate,\$StartTime);
    if ( $Task{status} ) { goto EXITWITHERROR; }
    
    $Task{StartDate} = $StartDate;
    $Task{StartTime} = $StartTime;


    # Get Spacecraft 'sen' file name
    $Task{enfile} = &SetEnfileName;    
    if ( $Task{status} ) { return 1 };
    &AddReport(3,"Spacecraft Housekeeping File Name     : $Task{enfile}\n");


    # Get XRT Teldef File
    $Task{teldef} = &SetTeldefFileName;    
    if ( $Task{status} ) { return 1 };
    &PrntChty(3,"$Task{'stem'}: Info: Using Telescope Definition File: \n");
    &PrntChty(3,"$Task{'stem'}: Info: '$Task{teldef}'\n");
    &AddReport(3,"XRT Telescope Definition File          : $Task{teldef}\n");

    # Get XRT Teldef File
    #    if ( $Task{runaspect} ) {
    # Spacecreaft Teldef File
    $Task{scteldef} = &SetScTeldefFileName;    
    if ( $Task{status} ) { return 1 };
    &PrntChty(3,"$Task{'stem'}: Info: Using S/C Alignement Definition File: \n");
    &PrntChty(3,"$Task{'stem'}: Info: '$Task{scteldef}'\n");
    &AddReport(3,"S/C Telescop Definition File          : $Task{scteldef}\n");
    #    }
    
    if ( $Task{display} && !($Viewer = &GetViewer($Parms_str{plotdevice}) ) ) {
	&PrntChty(1,"$Task{'stem'}: WARNING no viewer found to plot images\n");
	&PrntChty(1,"$Task{'stem'}: WARNING no display of images will be done\n");
	$Parms_bool{display}="no";
	$Task{display}=0;
    }

    &AddReport(3,$Default{LLINE});

    foreach $mode ( @{$InFiles{'modelist'}} ) {

	if ( $#{$InFiles{$mode}} == -1 ) {
	    &PrntChty(3,"$Task{'stem'}: Info: No $Modes{$mode} event files found\n");
	    &AddReport(3,"$mode: No $Modes{$mode} event files found\n");
	    $EvtFiles{$mode}{nfiles} = 0;
	    next;
	}

	my ( @filelist, @outfilelist, $outevtfile, $filtfile, $outevtfilel1a, $outevtfilel2, $rec, $recdata, @reclist, %rechash );
	$rec={};
	@reclist = "";
	$#reclist = -1;

	&PrntChty(3,"$Task{'stem'}: Info: Found $Modes{$mode} Event File(s)\n");
	my ( $numfiles ) = $#{$InFiles{$mode}}+1;
	&AddReport(3,"$mode: Found $numfiles $Modes{$mode} Event File(s):\n");
	my ($nfiles) = 0;
	if ( $mode eq "im" ) {
	    foreach $evtfile (@{$InFiles{$mode}}) {
		my $filenopath = &ErasePath($evtfile);

		&AddReport(3,"$mode: ............... $filenopath\n");
		if ( $Task{entrystage} <= 1 && $Task{exitstage} >= 1) {
		    # check input/output run of xrtimage
		    $outevtfile  = &SetLev1EvtFileName($evtfile,$mode);
		    if ( !$outevtfile ) { 
			if ( !$Task{errmess} ) {
			    $Task{errmess} = "'SetLev1EvtFileName' error"; 
			}
			return; 
		    }
		    $nfiles ++;
		    $recdata = "lev1=$evtfile lev2=$outevtfile";
		    %rechash = split /[\s=]+/, $recdata;
		    push @reclist, { %rechash };
		}
	    } # loop onevent files
	    $rec->{filelist} = [ @reclist ];
	    $EvtFiles{$mode} = $rec; 
	    $EvtFiles{$mode}{nfiles} = $nfiles;
	} # image mode 

	if ( $mode eq "pc" ) {
	    foreach $evtfile (@{$InFiles{$mode}}) {
		my $filenopath = &ErasePath($evtfile);
		&AddReport(3,"$mode: ............... $filenopath\n");

		# check input/output run of xrtimage
		$outevtfile  = &SetLev1EvtFileName($evtfile,$mode);
		if ( !$outevtfile ) { 
		    if ( !$Task{errmess} ) {
			$Task{errmess} = "'SetLev1EvtFileName' error"; 
		    }
		    return; 
		}
		$nfiles ++;

		if ( $Task{exitstage} == 2 || $Task{exitstage} == 3) {
		    $filtfile = &SetLev2EvtFileName($outevtfile,$Parms_str{outdir});
		    if ( $Task{status} ) {
			&PrntChty(3,"$Task{stem}: ERROR: Cannot retrieve DEFAULT output Filtered Event File Name");
			&PrntChty(3,"$Task{stem}: ERROR: From '$outevtfile' file");
			$Task{errmess} = "Cannot retrieve DEFAULT output Filtered Event File Name";
			goto EXITWITHERROR;
		    }
		    $recdata = "lev1=$evtfile lev1out=$outevtfile lev2=$filtfile";
		}
		else {
		    $recdata = "lev1=$evtfile lev1out=$outevtfile";
		}

		if ( $Task{evtfromarc} ) {
		    if ( $Task{entrystage} == 2 ) {
			&PrntChty(4,"$Task{stem}: Info: Get Calibrated Level1 PC file from Target Directory\n");
			my $nopath = &ErasePath($outevtfile);
			$outevtfile = "";
			foreach $file ( @evtlist ) {
			    $filenopath = &ErasePath($file);
			    # check if it is an event file
			    $filenopath =~ 
				/$nopath$|$nopath.gz$/ 
				    && do {$outevtfile=$file;goto ENDLOOP1;};
			}
		      ENDLOOP1:
			if ( length($outevtfile) == 0 ) {
			    &PrntChty(2,"$Task{stem}: Error: File '$nopath' not found in the target directory\n");
			    &PrntChty(2,"$Task{stem}: Error: canot process the '$nopath' file\n");
			    &AddReport(2,"$mode: .... ERROR: $nopath not found in the archive directory\n");
			}
		    }
		    elsif ( $Task{entrystage} == 3 ) {
			my $nopath = &ErasePath($filtfile);
			$filtfile = "";
			foreach $file ( @evtlist ) {
			    $filenopath = &ErasePath($file);
			    # check if it is an event file
			    $filenopath =~ 
				/$nopath$|$nopath.gz$/ 
				    && do {$filtfile=$file;goto ENDLOOP2;};
			}
		      ENDLOOP2:
			if ( length($filtfile) == 0 ) {
			    &PrntChty(2,"$Task{stem}: Error: File '$nopath' not found in the target directory\n");
			    &PrntChty(2,"$Task{stem}: Error: canot process the '$nopath' file\n");
			    &AddReport(2,"$mode: .... ERROR: $nopath not found in the archive directory\n");
			}
		    } 
		    $recdata = "lev1=$evtfile lev1out=$outevtfile lev2=$filtfile";
		}
		%rechash = split /[\s=]+/, $recdata;
		push @reclist, { %rechash };
	    } # loop on event files
	    $rec->{filelist} = [ @reclist ];
	    $EvtFiles{$mode} = $rec; 
	    $EvtFiles{$mode}{nfiles} = $nfiles;
	} # photon counting mode 

	if ( $mode eq "wt" || $mode eq "lr" || $mode eq "pu") {
	    foreach $evtfile (@{$InFiles{$mode}}) {
		my $filenopath = &ErasePath($evtfile);
		&AddReport(3,"$mode: .... Input File: $filenopath\n");
		# check input/output run of xrtimage
		&PrntChty(3,"$Task{'stem'}: Info: Checking '$filenopath' Input/Output Files\n");		

		$outevtfile  = &SetLev1EvtFileName($evtfile,$mode);
		if ( !$outevtfile ) { 
		    if ( !$Task{errmess} ) {
			$Task{errmess} = "'SetLev1EvtFileName' error"; 
		    }
		    return; 
		}
		$nfiles ++;
		&PrntChty(3,"$Task{'stem'}: Info: Level 1 input file: '$outevtfile'\n");		

		$outevtfilel1a  = &SetLev1aEvtFileName($outevtfile,$mode);
		if ( -f $outevtfilel1a && !$Task{clobber} && $Task{entrystage} <= 1) {
		    &PrntChty(3, "$Task{stem}: ERROR: cannot overwrite output file '$outevtfilel1a'\n");
		    &PrntChty(3, "$Task{stem}: ERROR: Please set input parameter 'clobber' to yes\n");
		    $Task{errmess} = "Cannot overwrite output file '$outevtfilel1a'";
		    $Task{status} = 1;
		    return;
		}
		&PrntChty(3,"$Task{'stem'}: Info: Level 1a file: '$outevtfilel1a'\n");		
		$recdata = "lev1=$evtfile lev1out=$outevtfile lev1a=$outevtfilel1a";

		if ( $Task{exitstage} == 2 || $Task{exitstage} == 3) {
		    $outevtfilel2  = &SetLev2EvtFileName($outevtfile,$Parms_str{outdir});
		    if ( -f $outevtfilel2 && !$Task{clobber} && &DoStage(2) ) {
			&PrntChty(3, "$Task{stem}: ERROR: cannot overwrite output file '$outevtfilel2'\n");
			&PrntChty(3, "$Task{stem}: ERROR: Please set input parameter 'clobber' to yes\n");
			$Task{errmess} = "Cannot overwrite output file '$outevtfilel2'";
			$Task{status} = 1;
			return;
		    }
		    &PrntChty(3,"$Task{'stem'}: Info: Level 2 file: '$outevtfilel2'\n");
		    $recdata = "lev1=$evtfile lev1out=$outevtfile lev1a=$outevtfilel1a lev2=$outevtfilel2";
		}
		else {
		    $recdata = "lev1=$evtfile lev1out=$outevtfile lev1a=$outevtfilel1a";
		}


		if ( $Task{evtfromarc} ) {
		    if ( $Task{entrystage} == 2 ) {
			&PrntChty(4,"$Task{stem}: Info: Get Calibrated Level1 PC file from Target Directory\n");
			my $nopath = &ErasePath($outevtfilel1a);
			$outevtfilel1a = "";
			foreach $file ( @evtlist ) {
			    $filenopath = &ErasePath($file);
			    # check if it is an event file
			    $filenopath =~ 
				/$nopath$|$nopath.gz$/ 
				    && do {$outevtfilel1a=$file;goto ENDLOOP1;};
			}
		      ENDLOOP1:
			if ( length($outevtfilel1a) == 0 ) {
			    &PrntChty(2,"$Task{stem}: Error: File '$nopath' not found in the target directory\n");
			    &PrntChty(2,"$Task{stem}: Error: canot process the '$nopath' file\n");
			    &AddReport(2,"$mode: .... ERROR: $nopath not found in the archive directory\n");
			}
		    }
		    elsif ( $Task{entrystage} == 3 ) {
			my $nopath = &ErasePath($outevtfilel2);
			$outevtfilel2 = "";
			foreach $file ( @evtlist ) {
			    $filenopath = &ErasePath($file);
			    # check if it is an event file
			    $filenopath =~ 
				/$nopath$|$nopath.gz$/ 
				    && do {$outevtfilel2=$file;goto ENDLOOP2;};
			}
		      ENDLOOP2:
			if ( length($outevtfilel2) == 0 ) {
			    &PrntChty(2,"$Task{stem}: Error: File '$nopath' not found in the target directory\n");
			    &PrntChty(2,"$Task{stem}: Error: canot process the '$nopath' file\n");
			    &AddReport(2,"$mode: .... ERROR: $nopath not found in the archive directory\n");
			}
		    } 
		    $recdata = "lev1=$evtfile lev1out=$outevtfile lev1a=$outevtfilel1a lev2=$outevtfilel2";
		}
		%rechash = split /[\s=]+/, $recdata;
		push @reclist, { %rechash };
	    } # loop on event files
	    $rec->{filelist} = [ @reclist ];
	    $EvtFiles{$mode} = $rec; 
	    $EvtFiles{$mode}{nfiles} = $nfiles;
	} # wt/lr/pu modes

#	    my ( $who );
#	    for $who ( @{ $EvtFiles{$mode}{filelist} } ) {
#		print "$mode LEV1   :  $who->{lev1}\n";
#		print "$mode LEV1OUT:  $who->{lev1out}\n";
#		print "$mode LEV1A  :  $who->{lev1a}\n";
#		print "$mode LEV2   :  $who->{lev2}\n";
#	    }

    } # loop on modes

    # Get HK 'xtr.hk' file name
    $Task{trfile} = &SetTrfileName;    
    if ( $Task{status} ) { return 1 };
    &AddReport(3,"HK Trailer File Name                   : $Task{trfile}\n");

    return 0;

} # InitRun

sub SetLev1aEvtFileName {

    my ( $infile, $mode ) = @_;
    use vars qw (%Task %Parms_str);

    my ( $stemlev1a ) = "re";
    
    my ( $filenoext ) = substr($infile,0,rindex( $infile, '.' ));
    my ( $ext ) = substr($infile,rindex( $infile, '.' ));
    $filenoext =~ s/l1$// ;
    my ( $lev1afilename ) = "$filenoext$stemlev1a$ext";

    return $lev1afilename;
} # SetLev1aEvtFileName

sub AddReport {
    my ( $chatty, $string ) = @_;
    use vars qw ($Report);
    if ( $chatty <= $Task{chatter} ) {
	$Report .= $string;
    }
    return;
} # AddReport

sub SetLev1EvtStem {

    my ( $file, $mode ) = @_;
    use vars qw (%Parms_str);
    
    my ( $filenostem ) = $file;
    $filenostem =~ s/^$Parms_str{steminputs}// ;

    return "$Parms_str{stemoutputs}$filenostem";
} # SetLev1EvtStem


sub DoStage {
    my ( $numstage ) = @_;
    use vars qw (%Task);

    if ( $Task{entrystage} <= $numstage && $Task{exitstage} >= $numstage)
    {return 1;}
    return 0;
} # DoStage

sub DoOnlyStage {
    my ( $numstage ) = @_;
    use vars qw (%Task);

    if ( $Task{entrystage} == $numstage && $Task{exitstage} == $numstage)
    {return 1;}
    return 0;
} # DoOnlyStage


sub RunFselect {

    my ($InEvt, $OutEvt, $ExprFselect) = @_;
    use vars qw( %Task %Parms_str %Parms_num %Parms_bool  %Default );
    my ( $command, $ret, $par, %fselect );

    &RunningSub("RunFselect","fselect", " selecting events with expression '$ExprFselect'");
    
# Build the command line to run 'fselect'
#


    %fselect = (
		infile       => $InEvt,
		outfile      => $OutEvt,
		expr         => "$ExprFselect",
		histkw       => $Parms_bool{history},
		copyall      => "yes",              
		keycopy      => "yes",
		clobber      => $Parms_bool{clobber},
		);

    $command = "fselect";
    for $par ( keys %fselect ) { 
	if ( $par eq "expr" )
	    { $command .= " $par=\"$fselect{$par}\""; } 
	else
	    { $command .= " $par=$fselect{$par}"; } 
    }

    &RunningComm("RunFselect",$command);

    $ret = 0;
    $ret = system( $command );

    if ( $ret != 0 ) {
	&ErrorComm("RunFselect","fselect",$command);
        $Task{errmess} = "ERROR running 'fselect'";
	$Task{status} = 1;
	return 1;
    }

    # update checksum

    if ( system("ftchecksum $OutEvt update=yes chatter=0") ) {
	&PrntChty(1,"$Task{stem}: WARNING Error updating checksum\n"); }

    &SuccessSub("RunFselect","fselect","'$OutEvt' created");

    return 0;

} # RunFselect

sub RunXrtHkProc {

    use vars qw( %Task %Parms_str %Parms_num %Parms_bool  %Default );
    my ( $command, $ret, $par, %xrthkproc );

    &RunningSub("$Task{stem}","xrthkproc", " to calculate timing modes frames exposure times");
    
#
# Build the command line to run 'xrthkproc'
#

    my ( $srcdetx, $srcdety );

    $srcdetx = $Parms_num{srcdetx};
    $srcdety = $Parms_num{srcdety};

    if ( !$Task{usesrcdethkproc} ) {
	&PrntChty(3,"$Task{stem}: Info: 'usrsrcdethkproc' set to 'no'\n");
	&PrntChty(3,"$Task{stem}: Info: using source sky coordinates to timetag the Header Packet frames\n");
	$srcdetx = -999;
	$srcdety = -999;
    }
    else {
	&PrntChty(3,"$Task{stem}: Info: using source detector coordinates to timetag the Header Packet frames\n");
	$srcdetx = $Parms_num{srcdetx};
	$srcdety = $Parms_num{srcdety};
    }


    %xrthkproc = (
		  hdfile       => $Task{hkfile},
		  outfile      => $Task{hkfilecorr},
		  clobber      => $Parms_bool{clobber},
		  history      => $Parms_bool{history},
		  chatter      => $Parms_num{chatter},
		  teldef       => $Task{teldef},
		  attfile      => $Task{attfilecorr},
		  aberration   => $Parms_bool{aberration},
		  attinterpol  => $Parms_bool{attinterpol},
		  srcdetx      => $srcdetx, 
		  srcdety      => $srcdety,
		  srcra        => $Task{srcra},
		  srcdec       => $Task{srcdec},
		  ranom        => $Task{ranom},
		  decnom       => $Task{decnom},
		);

    $command = "xrthkproc";
    for $par ( keys %xrthkproc ) { $command .= " $par=\"$xrthkproc{$par}\""; } 

    &RunningComm("$Task{stem}",$command);

    $ret = 0;
    $ret = system( $command );

    if ( $ret != 0 ) {
	&ErrorComm("$Task{stem}","xrthkproc",$command);
        $Task{errmess} = "ERROR running 'xrthkproc'";
	$Task{status} = 1;
	return 1;
    }

    &SuccessSub("$Task{stem}","xrthkproc","'$Task{hkfilecorr}' created");
    &AddReport(3,"hk: .... HK Header File Correction applied, created: $Task{hkfilecorr}\n");
    return 0;

} # RunXrtHkProc

sub RunSwiftXform {

    my ( $InFile, $OutFile ) = @_;

    use vars qw( %Task %Parms_str %Parms_num %Parms_bool  %Default );
    my ( $command, $ret, $par, %swiftxform, $attflag, @img_list);

    &RunningSub("$Task{stem}","swiftxform", " transforming coordinates into sky");
    
#
# Build the command line to run 'swiftxform'
#

    %swiftxform = (
		   infile       => $InFile,
		   outfile      => $OutFile,
		   attfile      => $Task{evtattfile},
		   alignfile    => "none",
		   method       => $Parms_str{method},
		   to           => "SKY",               
		   ra           => $Task{ranom},
		   dec          => $Task{decnom},
		   roll         => $Task{rollnom},
		   teldeffile   => $Task{teldef},
		   bitpix       => 0,
		   zeronulls    => $Parms_bool{zeronulls},
		   aberration   => $Parms_bool{aberration},
		   seed         => $Parms_num{seedcoordinator},
		   copyall      => "yes",
		   extempty     => "yes",
                   allempty     => "no",
		   skytime      => "DEFAULT",
		   history      => $Parms_bool{history},
		   clobber      => $Parms_bool{clobber},
		   cleanup      => $Parms_bool{cleanup},
		   chatter      => $Parms_num{chatter},
		);

    $command = "swiftxform";
    for $par ( keys %swiftxform ) { $command .= " $par=\"$swiftxform{$par}\""; } 

    &RunningComm("$Task{stem}",$command);

    $ret = 0;
    $ret = system( $command );

    if ( $ret != 0 ) {
	&ErrorComm("$Task{stem}","swiftxform",$command);
        $Task{errmess} = "ERROR running 'swiftxform'";
	$Task{status} = 1;
	return 1;
    }
    
    &GetAttitudeATTFLAG($Task{evtattfile}, \$attflag);
    if ($Task{status})
    { 
	&PrntChty(2,"$Task{stem}: Error: RunSwiftXform: unable to get ATTFLAG from $Task{evtattfile}\n");
	return 1; 
    }
    
    @img_list = &GetImagesHduList($OutFile);
    if ($Task{status})
    { 
	&PrntChty(2,"$Task{stem}: Error: RunSwiftXform: unable to get image hdu list from $OutFile\n");
	return 1; 
    }
    
    for (my $i=0; $i <= $#img_list; $i++)
    {
	if(!&AddKeywordExtNum($OutFile,$img_list[$i],TSTRING,"ATTFLAG",$attflag,"Attitude type flag")) 
	{
	    &PrntChty(2,"$Task{stem}: Error: RunSwiftXform: unable to update ATTFLAG in $OutFile\n");
	    return 1;
	}
    }

    &SuccessSub("$Task{stem}","swiftxform","'$OutFile' created");
    &AddReport(3,"im: .... Stage  I/II: Created '$OutFile' sky images\n");
    return 0;

} # RunSwiftXform

sub RunXrtImage2Cnt {

    my ( $InFile, $OutFile ) = @_;

    use vars qw( %Task %Parms_str %Parms_num %Parms_bool  %Default );
    my ( $command, $ret, $par, %xrtimage2cnt );

    &RunningSub("$Task{stem}","xrtimage2cnt", " generating a sky image in counts");
    
#
# Build the command line to run 'xrtimage2cnt'
#

    %xrtimage2cnt = (
		   infile       => $InFile,
		   outfile      => $OutFile,
		   clobber      => $Parms_bool{clobber},
		   chatter      => $Parms_num{chatter},
		   history      => $Parms_bool{history},
		);

    $command = "xrtimage2cnt";
    for $par ( keys %xrtimage2cnt ) { $command .= " $par=\"$xrtimage2cnt{$par}\""; } 

    &RunningComm("$Task{stem}",$command);

    $ret = 0;
    $ret = system( $command );

    if ( $ret != 0 ) {
	&ErrorComm("$Task{stem}","xrtimage2cnt",$command);
        $Task{errmess} = "ERROR running 'xrtimage2cnt'";
	$Task{status} = 1;
	return 1;
    }

    &SuccessSub("$Task{stem}","xrtimage2cnt","'$OutFile' created");
    &AddReport(3,"im: .... Stage  I/II: '$OutFile' count image\n");
    return 0;

} # RunXrtImage2Cnt

sub RunAspect {

    use vars qw( %Task %Parms_str %Parms_num %Parms_bool  %Default );
    my ( $command, $ret, $par, %aspect, $gtifilename );

    &RunningSub("$Task{stem}","aspect", " to calculate optical axis ra,dec"); 
    &PrntChty(3,"$Task{stem}: Info: from '$Task{evtattfile}' file\n");
    
# probably is better to use 'gti' to do not use
# not apprioriate data for the computation
# we are wating to decide what parameter use
# to do this

#
# Create GTI taking into account only data when the spacecraft  
# is in pointing
#

    if ( &CompUL($Parms_str{aspectgtiexpr},"none" ) ) {
	$gtifilename = "none";
    }
    else {
	my ( $expr ) = $Parms_str{aspectgtiexpr};
	$gtifilename = $Parms_str{outdir} . "/" . $$ . "aspect.gti";
	# Call 'maketime'
	if ( &RunMaketime($expr,$gtifilename) ) { return 1; }
        # Check if the GTI file is empty (not handled by aspect)
	if ( &TableEmpty($gtifilename, $Default{GTI_EXTNAME}) ){
	    &PrntChty(3, "$Task{stem}: ERROR: Empty GTIs created with '$expr' expression\n");
	    &PrntChty(3, "$Task{stem}: ERROR: Cannot run 'aspect' with an empty GTI file\n");
	    &PrntChty(3, "$Task{stem}: ERROR: Please change the input 'aspectgtiexpr' or set it\n");
	    &PrntChty(3, "$Task{stem}: ERROR: to 'none' to run aspect on the full attitude file\n");
	    $Task{status} = 1;
	    $Task{errmess} = "Cannot run aspect";
	    return 1;
	}
    }

#
# Build the command line to run 'aspect'
#

    %aspect = (
	       attfile      => $Task{evtattfile}, 
	       alignfile    => $Task{scteldef},
	       gtis         => $gtifilename,
	       nbins        => 100,
	       binsize      => 0.01,
	       maxrot       => 0.01,
	       iterations   => 100,
	       chatter      => $Parms_num{chatter},
	       );

    $command = "aspect";
    for $par ( keys %aspect ) { $command .= " $par=\"$aspect{$par}\""; } 

    &RunningComm("$Task{stem}",$command);

    # set a temporary file name for command output

    my ($TmpFile) = $Parms_str{outdir}. "/" . $$ . "aspect";

    $command = "$command 1> $TmpFile 2>&1";

    $ret = 0;
    $ret = system( $command );

    if ( $ret != 0 ) {
	&PrntChty(1,"$Task{stem}: Info: 'aspect' run output:\n");
	system ("cat $TmpFile");
	&PrntChty(1,"$Task{stem}: Info: end of 'aspect' run output.\n");
	&ErrorComm("$Task{stem}","aspect",$command);
        $Task{errmess} = "ERROR running 'aspect'";
	$Task{status} = 1;
	return 1;
    }

    if ( $Task{chatter} >= 3 ) {
	&PrntChty(3,"$Task{stem}: Info: 'aspect' run output:\n");
	system ("cat $TmpFile");
	&PrntChty(3,"$Task{stem}: Info: end of 'aspect' run output.\n");
    }

    if ( ! open ( ASPECTLOG, "<$TmpFile" )) {
	&PrntCkty(2,"$Task{'stem'}: ERROR: Cannot open '$TmpFile' file");
        $Task{errmess} = "ERROR running 'aspect'";
	$Task{status} = 1;
	return 1;
    }

    $ret = 0;

    while ( <ASPECTLOG> ) { 
	if ( $_ =~ /Error/i ) {
	    chop;
	    PrntChty(2,"$Task{stem}: ERROR: error message found with 'aspect' run\n");
	    $ret = 2;
	}
	elsif ( $_ =~ /warning/i ) {
	    chop;
	    PrntChty(2,"$Task{stem}: WARNING: warning message found with 'aspect' run\n");
	    if ( !$ret ) {$ret = 1;}
	}
	elsif ( $_ =~ /following results are unreliable/i ) {
	    PrntChty(2,"$Task{stem}: WARNING: not reliable RA,DEC,ROLL computed\n");
	    $ret = 1;
	}
    }
    close ASPECTLOG;
    
    if ( $ret == 2 ) {
        $Task{errmess} = "ERROR: running 'aspect'";
	$Task{status} = 1;
	return 1;
    }
    # get ra,dec values from parameter list

    my ( $ra, $dec, $roll );
    chop($ra        = qx(pquery2 aspect ra));
    chop($dec       = qx(pquery2 aspect dec));
    chop($roll       = qx(pquery2 aspect roll));

    $ra =~ s/^\s+//; # remove leading spaces
    $ra =~ s/\s+$//; # remove trailing spaces	
    $ra =~ s/^'//g;; #Remove apex
    $ra =~ s/'$//g;; #Remove apex
    $ra =~ s/\s+$//g;; #Remove right space
    
    if ( $ra >= 0.0 && $ra <= 1.0e-12 ) { $ra = 0.0; }
    $Task{ranom}=$ra;

    $dec =~ s/^\s+//; # remove leading spaces
    $dec =~ s/\s+$//; # remove trailing spaces	
    $dec =~ s/^'//g;; #Remove apex
    $dec =~ s/'$//g;; #Remove apex
    $dec =~ s/\s+$//g;; #Remove right space

    if ( $dec >= 0.0 && $dec <= 1.0e-12 ) { $dec = 0.0; }
    $Task{decnom}=$dec;

    $roll =~ s/^\s+//; # remove leading spaces
    $roll =~ s/\s+$//; # remove trailing spaces	
    $roll =~ s/^'//g;; #Remove apex
    $roll =~ s/'$//g;; #Remove apex
    $roll =~ s/\s+$//g;; #Remove right space

    $Task{rollnom}=$roll;
    
    &PrntChty(3,"$Task{stem}: Info: Computed   RA : $Task{ranom}(deg)\n"); 
    &PrntChty(3,"$Task{stem}: Info: Computed  DEC : $Task{decnom}(deg)\n"); 
    &PrntChty(3,"$Task{stem}: Info: Computed ROLL : $Task{rollnom}(deg)\n");

    &AddReport(3,"hk: .... Telescope   RA computed from attitude : $Task{ranom}(deg)\n"); 
    &AddReport(3,"hk: .... Telescope  DEC computed from attitude : $Task{decnom}(deg)\n"); 
    &AddReport(3,"hk: .... Telescope ROLL computed from attitude : $Task{rollnom}(deg)\n");

    if ( $ret ) {
	&AddReport(3,"hk: .... WARNING: 'runaspect' warnings:\n");
	&AddReport(3,"hk: .... WARNING: RA,DEC and ROLL are unreliable\n");
    }

    if ( $Task{cleanup} ) {
	if ( !unlink($gtifilename) ) {
	    PrntChty(4,"RunAspect: WARNING: Cannot Unlink $gtifilename. $!\n");
	}
	if ( !unlink($TmpFile) ) {
	    PrntChty(4,"RunAspect: WARNING: Cannot Unlink $TmpFile. $!\n");
	}
    }

    &SuccessSub("$Task{stem}","aspect");

    return 0;
} # RunAspect

sub RunMaketime {

    my ( $expr, $gtifile ) = @_;
    use vars qw( %Task %Default );

    my ( $command, $ret, $par, %maketime );

    my ($tmpext ) = &GetNumExtName( "$Task{hkfile}", "FRAME");
    if ( $tmpext == -1 ) {
	$Task{status} = 1;
	$Task{errmess} = "Format of '$Task{hkfile}' not supported\n";
	&PrntChty(2,"$Task{stem}: ERROR: Format of '$Task{hkfile}' not supported\n");
	&PrntChty(2,"$Task{stem}: ERROR: Not found extension with EXTNAME = FRAME\n");
	return 1;
    }
    elsif ( $Task{status} ) {
	return 1;
    }

    my ( $TmpHkfile ) = "$Parms_str{outdir}/".$$.".xhdtmp" ;
    if ( -f $TmpHkfile ) {
	if ( !unlink ($TmpHkfile) ) {
	    &PrntChty(2,"$Task{stem}: Error: Cannot delete $TmpHkfile file\n");
	    $Task{status} = 1;
	    $Task{errmess} = "Cannot delete the $TmpHkfile  temporary file\n";
	    return 1;
	}
    }

    if ( &CleanHkfile($Task{hkfile},$TmpHkfile) ) { return 1; }

    my $NumRows;
    &GetKeyword ($TmpHkfile, "FRAME", undef, "NAXIS2",\$NumRows );
    
    if ( $Task{status} ) { return 1; }

    if ( $NumRows == 1 ) {
	# Cannot create GTIs file from $Task{hkfile} with maketime 
        # if only one row is available!
	# Check if the record is good ( Pointing==1 )
	&PrntChty(2,"$Task{stem}: WARNING: The '$TmpHkfile' file has only one row\n");
	&PrntChty(2,"$Task{stem}: WARNING: Cannot use 'maketime' to generate GTIs\n");
	&PrntChty(2,"$Task{stem}: WARNING: try to check the row available against expression provided\n");
	&PrntChty(2,"$Task{stem}: WARNING: only '&&' allowed in the expression (no '||')\n");

	&CheckRow( $TmpHkfile, $tmpext, $gtifile, $expr, $Default{GTI_EXTNAME});
	if ( $Task{status} ) { goto EXITWITHERROR; }

	return 0;
    }

    &PrntChty(3,"$Task{stem}: Info: 'maketime' input: '$TmpHkfile'\n");
    &PrntChty(3,"$Task{stem}: Info: 'maketime' output: '$gtifile'\n");
    &RunningSub("RunMaketime","maketime",".\n$Task{stem}: Info: Creating $gtifile file using $expr expression");

#
# Build the command line to run 'maketime'
#

    %maketime = (
		 infile   =>  $TmpHkfile,
		 outfile  =>  $gtifile,
		 expr     =>  "\"$expr\"",
		 time     =>  "TIME",
		 prefr    =>  0.0,
		 postfr   =>  1.0,
		 compact  =>  "no",
		 clobber  =>  $Parms_bool{clobber},
		 );

    $command = "maketime";
    for $par ( keys %maketime ) { $command .= " $par=$maketime{$par}"; } 

    &RunningComm("RunMaketime",$command);

    $ret = 0;
    $ret = system( $command );

    if ( $ret != 0 ) {
	&ErrorComm("RunMaketime","maketime",$command);
        $Task{errmess} = "ERROR running 'maketime'";
	$Task{status} = 1;
	return 1;
    }
    
    if ( &TableEmpty($gtifile, $Default{GTI_EXTNAME} ) ) {
	&PrntChty(1,"$Task{stem}: ERROR: Empty '$gtifile' GTIs\n");
	&PrntChty(1,"$Task{stem}: ERROR: No XRT Pointing Data found\n");
	$Task{errmess} = "Empty GTIs, no pointing data found";
	$Task{status} = 1;
	return 1;
    }

    if ( -f $TmpHkfile  && $Task{cleanup} ) {
	if ( !unlink ( $TmpHkfile ) ) {
	    &PrntChty(2,"$Task{stem}: Warning: Cannot delete '$TmpHkfile' file. $!\n");
	}
    }
    
    &SuccessSub("RunMaketime","maketime","'$gtifile' created");
    return 0;

} # RunMaketime

sub RunXrtTam {

    use vars qw( %Task %Parms_str %Parms_num %Parms_bool  %Default );
    my ( $command, $ret, $par, %xrttam );

    &RunningSub("$Task{stem}","xrttam", " to correct the attitude file with TAM values");
    
    my ( $outattfile ) = $Task{attfilecorr};
    my ( $ind ) = rindex($Task{attfilecorr}, '/' )+1;
    if ( $ind > 0 ) { $outattfile = substr( $Task{attfilecorr}, $ind); }

    my ( $outtamfile );
    if ( &CompUL($Parms_str{stemoutputs},$Default{DEFAULT}) ) {
	$outtamfile = "DEFAULT"
    }
    else {
	$outtamfile = $Parms_str{stemoutputs}."xtmdtcr.fits";
    }


#
# Build the command line to run 'xrttam'
#


    %xrttam = (
	       attfile         => $Task{attfile},
	       hdfile          => $Task{hkfile},
	       outdir          => $Parms_str{outdir},
	       tamfile         => $Parms_str{tamfile},
	       outattfile      => $outattfile,
	       teldef          => $Task{teldef},
	       outtamfile      => $outtamfile,
	       tamrefx1        => $Parms_num{tamrefx1},
	       tamrefy1        => $Parms_num{tamrefy1},
	       tamrefx2        => $Parms_num{tamrefx2},
	       tamrefy2        => $Parms_num{tamrefy2},
	       alignfile       => $Task{scteldef},
	       interpolation   => $Task{interpolation},
	       clobber         => $Parms_bool{clobber},
	       cleanup         => $Parms_bool{cleanup},
	       history         => $Parms_bool{history},
	       chatter         => $Parms_num{chatter},
	       );

    $command = "xrttam";
    for $par ( keys %xrttam ) { $command .= " $par=\"$xrttam{$par}\""; } 

    &RunningComm("$Task{stem}",$command);

    $ret = 0;
    $ret = system( $command );

    if ( $ret != 0 ) {
	&ErrorComm("$Task{stem}","xrttam",$command);
        $Task{errmess} = "ERROR running 'xrttam'";
	$Task{status} = 1;
	return 1;
    }

    &SuccessSub("$Task{stem}","xrttam","'$Task{attfilecorr}' created");
    &AddReport(3,"hk: .... TAM Correction applied, created: $Task{attfilecorr}\n");

    return 0;

} # RunXrtTam

sub RunXrtHotPix {

    my( $evtfile, $mode ) = @_;
    my ( $command, $ret, %xrthotpix );

    my $TmpFile = substr($evtfile,0,rindex($evtfile,'.')).".tmp";
    if ( -f $TmpFile ) { unlink ($TmpFile); }

    %xrthotpix = (
		 infile    => $evtfile,
		 outfile   => $TmpFile,
		 outbpfile => $Default{DEFAULT},
		 overstatus=> "yes ",
		 usegoodevt => "yes",
		 gradeiterate => $Parms_bool{gradeiterate},
		 cellsize  => $Parms_num{cellsize},  
		 impfac    => $Parms_num{impfac},    
		 logpos    => $Parms_num{logpos},    
		 bthresh   => $Parms_num{bthresh}, 
		 phamin    => $Parms_num{phamin}, 
		 phamax    => $Parms_num{phamax}, 
		 cleanflick=> $Parms_bool{cleanflick},
		 iterate   => $Parms_bool{iterate},
		 hotneigh  => $Parms_bool{hotneigh},
		 clobber   => $Parms_bool{clobber},
		 history   => $Parms_bool{history},
		 chatter   => $Parms_num{chatter},
		 );

    $command = "xrthotpix";
    for $par ( keys %xrthotpix ) { $command .= " $par=$xrthotpix{$par}"; } 

    &RunningSub("RunXrtHotPix","xrthotpix","on $evtfile");
    &RunningComm("RunXrtHotPix",$command);

    $ret = 0;
    $ret = system( $command );

    if ( $ret != 0 ) {
	&ErrorComm("RunXrtHotPix","xrthotpix",$command);
        $Task{errmess} = "ERROR running 'xrthotpix'";
	$Task{errmess} = "$Task{'stem'}: Error running 'xrthotpix' on '$evtfile'";
	$Task{status} = 1;
	return 1;
    }

    if ( &DelAndRename($TmpFile, $evtfile) ) { return 1; }

    &SuccessSub("RunXrtHotPix","xrthotpix","'$evtfile' updated");

    return 0;

} # RunXrtHotPix

sub SetPointingAndSourceInfo {

    use vars qw( %Task %Parms_str );
    &PipelineMessage("Setting Optical Axis Direction");
    
    if ( &CompUL($Parms_str{pntra},"POINT") || 
	 &CompUL($Parms_str{pntdec},"POINT") ) {
	&PrntChty(3,"$Task{stem}: Info: 'pntra' and/or 'pntdec' input parameter set to POINT\n");
	&PrntChty(3,"$Task{stem}: Info: getting default S/C direction\n"); 
	if ( $Task{runaspect} ) {
	    
	    ##############################################
	    # Calculate $Task{ranom} and $Task{decnom} and 
	    # $Task{rollnom} from attitude
	    ##############################################
		 
	    &RunAspect();
	    if ( $Task{status} == 1 ) { goto EXITWITHERROR; }
	    
	}
	else {
	    
	    ##############################################
	    # Get $Task{ranom} and $Task{decnom} and 
	    # $Task{rollnom} from the Hk header file
	    ##############################################
	    
	    &GetPntFromExt($Task{hkfile},"FRAME",undef,\$Task{ranom},
			   \$Task{decnom}, \$Task{rollnom});
	    if ( $Task{status} ) { return -1; }
	    
	    &PrntChty(3,"$Task{stem}: Info: Optical Axis   RA : $Task{ranom}(deg)\n"); 
	    &PrntChty(3,"$Task{stem}: Info: Optical Axis  DEC : $Task{decnom}(deg)\n"); 
	    &PrntChty(3,"$Task{stem}: Info: Optical Axis ROLL : $Task{rollnom}(deg)\n");
	    
	    &AddReport(3,"hk: .... Optical Axis   RA from  RA_PNT keyword : $Task{ranom}(deg)\n"); 
	    &AddReport(3,"hk: .... Optical Axis  DEC from DEC_PNT keyword : $Task{decnom}(deg)\n"); 
	    &AddReport(3,"hk: .... Optical Axis ROLL from  PA_PNT keyword : $Task{rollnom}(deg)\n");
	    
	}
    }
    else {
	&PrntChty(3,"$Task{stem}: Info: 'pntra' and 'pntdec' set by input parameter\n");
	&PrntChty(3,"$Task{stem}: Info: using: 'pntra' = '$Parms_str{pntra}' and 'pntdec' = '$Parms_str{pntdec}'\n");
	&PrntChty(3,"$Task{stem}: Info: as S/C Pointing Direction\n");
	if (!&CheckRa("RA",$Parms_str{pntra})) { 
	    &PrntChty(1,"$Task{stem}: ERROR: error on 'srcra' input: '$Parms_str{srcra}'\n");
	    goto EXITWITHERROR;
	}
	if (!&CheckDec("DEC",$Parms_str{pntdec})) { 
	    &PrntChty(1,"$Task{stem}: ERROR: error on 'srcdec' input: '$Parms_str{srcdec}'\n");
	    goto EXITWITHERROR;
	}
	
	########################################
	# Perform convertion to degree if needed
	########################################
	
	$Task{ranom} = &Ra2Deg($Parms_str{pntra});
	$Task{decnom} = &Dec2Deg($Parms_str{pntdec});

	&PrntChty(3,"$Task{stem}: Info: Input  S/C RA Direction : $Task{ranom}\n");
	&PrntChty(3,"$Task{stem}: Info: Input DEC Direction : $Task{decnom}\n");
	&AddReport(3,"................. : S/C RA Direction from input parameter 'pntra': $Task{ranom}\n");
	&AddReport(3,"................. : S/C DEC Direction from input parameter 'pntdec': $Task{decnom}\n");

    }
    
    #######################################
    # Set srcra and srcdec position
    #######################################

    &PipelineMessage("Setting source RA and DEC position");

    &PrntChty(3,"$Task{stem}: Info: Check Input 'srcra' and 'srcdec' parameters\n");

    if ( &CompUL($Parms_str{srcra},$Default{POINTING}) || &CompUL($Parms_str{srcdec},$Default{POINTING}) ) {
	$Task{srcra} = $Task{ranom};
	$Task{srcdec} = $Task{decnom};
	&PrntChty(2,"$Task{stem}: WARNING Input parameters 'srcra' and/or 'srcdec' set to 'POINT'\n");
	&PrntChty(2,"$Task{stem}: WARNING Using Optcal Axis Direction as Source Position\n");
	&AddReport(2,"hk: .... WARNING: Input parameters 'srcra' and/or 'srcdec' set to 'POINT'\n");
	&AddReport(2,"hk: .... WARNING: Using Optical Axis Direction as Source Position\n"); 
	&AddReport(3,"hk: .... Object   RA set equal to Optical Axis : $Task{srcra}(deg)\n"); 
	&AddReport(3,"hk: .... Object  DEC set equal to Optical Axis : $Task{srcdec}(deg)\n"); 
    }
    elsif ( &CompUL($Parms_str{srcra},$Default{OBJECT}) || &CompUL($Parms_str{srcdec},$Default{OBJECT}) ) {
	&GetObjFromExt($Task{hkfile},"FRAME",undef,\$Task{srcra},\$Task{srcdec});
	&PrntChty(2,"$Task{stem}: Info: Input parameters 'srcra' and/or 'srcdec' set to 'OBJECT'\n");
	&PrntChty(2,"$Task{stem}: Info: Using OBJECT keywords from $Task{khfile} file\n");
	&AddReport(2,"hk: .... Input parameters 'srcra' and/or 'srcdec' set to 'OBJECT'\n");
	&AddReport(2,"hk: .... Using OBJECT keywords from $Task{khfile} file\n");
	&AddReport(3,"hk: .... Object   RA from  RA_OBJ : $Task{srcra}(deg)\n"); 
	&AddReport(3,"hk: .... Object  DEC from DEC_OBJ : $Task{srcdec}(deg)\n"); 
    }
    else {
	
	###########################
	# Check srcra/srcdec inputs
	###########################
	
	if (!&CheckRa("RA",$Parms_str{srcra})) { 
	    &PrntChty(1,"$Task{stem}: ERROR: error on 'srcra' input: '$Parms_str{srcra}'\n");
	    goto EXITWITHERROR;
	}
	if (!&CheckDec("DEC",$Parms_str{srcdec})) { 
	    &PrntChty(1,"$Task{stem}: ERROR: error on 'srcdec' input: '$Parms_str{srcdec}'\n");
	    goto EXITWITHERROR;
	}
	
	########################################
	# Perform convertion to degree if needed
	########################################
	
	$Task{srcra} = &Ra2Deg($Parms_str{srcra});
	$Task{srcdec} = &Dec2Deg($Parms_str{srcdec});
	
	&PrntChty(3,"$Task{stem}: Info: Input  RA Source Position : $Task{srcra}\n");
	&PrntChty(3,"$Task{stem}: Info: Input DEC Source Position : $Task{srcdec}\n");
	&AddReport(3,"................. : Input  RA Source Position : $Task{srcra}\n");
	&AddReport(3,"................. : Input DEC Source Position : $Task{srcdec}\n");
    }

} # SetPointingAndSourceInfo

sub CheckObsMode {

    my ( $evtfile, $mode, $obs_mode, $next ) = @_;

    ##############################################################
    # No checks performed on images (this check will be made by
    # the xrtimage task discharging images taken during SLEWS)
    ##############################################################


    if ( $mode eq "im" ) { return 0; }
    else {

	&GetKeyword ($evtfile, "EVENTS", undef, "OBS_MODE", $obs_mode);
	if ( $Task{status} ) { return 1; }

	&PrntChty(3,"$Task{stem}: Info: Data OBS_MODE: '$$obs_mode',\n");
	&AddReport(3,"$mode: .... Data Mode: '$mode'\n");
	&AddReport(3,"$mode: ....  Obs Mode: '$$obs_mode'\n");
	
	if ( !&CompUL($Parms_str{obsmode},"ALL") && !&CompUL($$obs_mode,$Parms_str{obsmode}) ) {
	    &PrntChty(3,"$Task{stem}: Info: Process not requested by user,\n");
	    &AddReport(3,"$mode: ....          : Process not requested by user\n");
	    $$next = 1;
	    return 0;
	} 


	if ( ($$obs_mode eq  $Default{POINTVALUE}) ||  
# 20/12/2004 - FT:
#	     ($$obs_mode eq $Default{SETTLINGVALUE} && $mode eq "lr" ) ) {
	     ($$obs_mode eq $Default{SETTLINGVALUE} ) ) {
	    &PrntChty(3,"$Task{stem}: Info: performing a full processing\n");
#	    &AddReport(3,"$mode: ....          : performing a full processing\n");
	}
#	 elsif ( ($$obs_mode eq $Default{SLEWVALUE} || $$obs_mode eq $Default{SETTLINGVALUE}) 
#		 && $mode ne "lr" ) {
#	     &PrntChty(3,"$Task{stem}: Info: No processing foreseen for '$mode' data taken\n");
#	     &PrntChty(3,"$Task{stem}: Info: during 'SLEW' or 'SETTLING'\n");
#	     &AddReport(3,"$mode: ....          : No processing foreseen for '$mode' data taken\n");
#	     &AddReport(3,"$mode: ....          : during 'SLEW' or 'SETTLING'\n");
#	     $$next = 1;
#	 }
#	 elsif ( $$obs_mode eq $Default{SLEWVALUE} && $mode eq "lr" ) {
	elsif ( $$obs_mode eq $Default{SLEWVALUE} ) {
	    &PrntChty(3,"$Task{stem}: Info: Partial processing foreseen for '$mode' data taken\n");
	    &PrntChty(3,"$Task{stem}: Info: during 'SLEW'\n");
	    &AddReport(3,"$mode: ....          : Partial processing foreseen for '$mode' data taken\n");
	    &AddReport(3,"$mode: ....          : during 'SLEW'\n");
	}
	elsif ($$obs_mode ne $Default{SLEWVALUE} && $$obs_mode ne $Default{SETTLINGVALUE})  {
	    &PrntChty(3,"$Task{stem}: ERROR: Unable to process data with keyword OBS_MODE set to '$$obs_mode'\n");
	    &PrntChty(3,"$Task{stem}: ERROR: Not Allowed 'OBS_MODE' value\n");
	    &AddReport(3,"$mode: ....     ERROR: Unable to process data with 'OBS_MODE' keyword set to $$obs_mode'\n");
	    &AddReport(3,"$mode: ....     ERROR: Not Allowed 'OBS_MODE' value\n");
	    $$next = 1;
	}
    }

    return 0;

} # CheckObsMode

sub PipelineMessage {

    my ( $message ) = @_;

    &PrntChty(2, "$Default{LLINE}               $message\n$Default{LLINE}");

} # Pipeline Message 

######################################
# common section for GetFileList task
######################################
{

    my (@list, $indir, $stem);

    sub GetFileList {
	( $indir, $stem ) = @_;
	@list = {};
	$#list = -1;
	&File::Find::find({wanted => \&Wanted, follow => 1, follow_skip => 2}, $indir);
	return @list;
    }

    sub Wanted {
    	 /^.*$stem.*\z/s &&
	 ! /^\..*/s &&  # ignore files starting with a dot
         -f $_ &&
    	 push @list, $File::Find::name;
    } # Wanted

} # GetFileList 

###############################################
# Common section for CheckInclusion subroutine
###############################################
{
    my ($indir, $outdir);
    # build a hash of the subdirectories of $outdir
    my %suboutdirs;
    my $found = 0;
    
    sub CheckInclusion {
	($indir, $outdir) = @_;
	# Traverse the $outdir filesystems, noting the subdirs
	File::Find::find({wanted=>\&buildsub, follow=>1, follow_skip=>2}, $outdir);
	# Traverse the $indir filesystems
	File::Find::find({wanted => \&lookout, follow => 1, follow_skip => 2}, $indir);
	return $found;
    }

    sub  buildsub{
	my ($dev, $ino);
	if (-d $_ || -d $File::Find::fullname) {
	    ($dev, $ino) = stat _;
	    $suboutdirs{$File::Find::fullname}=[$_,$dev,$ino];
	}
    }

    sub lookout {
	my ($dev, $ino);
	if (-d $_ || -d $File::Find::fullname) {
	    if ($suboutdirs{$File::Find::fullname}) {
		(($dev, $ino) = stat _);
		if (($dev == $suboutdirs{$File::Find::fullname}->[1]) &&
		    ($ino == $suboutdirs{$File::Find::fullname}->[2])) {
		    $File::Find::prune = 1;
		    $found = 1;
		}
	    }
	}
    }
}  # CheckInclusion subroutine section


sub SetScTeldefFileName {

    my ( $scteldeffile ) = @_;

    use vars qw ( %Task  %InFiles  %Default  %Parms_str );

    if ( &CompUL($Parms_str{scteldef},$Default{CALDB}) ) {

	my ($refa,$refb) = &CallScQuzcif("ALIGNMENT","NOW","-","-",1);
	if ( $Task{status} ) {
	    &PrntChty(2,"$Task{stem}: ERROR: cannot retrieve S/C Alignment file name from CALDB\n");
	    return;
	}
	if ( @$refb[0] != 0 ) {
	    &PrntChty(2,"$Task{stem}: ERROR: on 'scteldef' file format\n");
	    $Task{status} = 1;
	    return;
	}
	$scteldeffile = @$refa[0];
    }
    else {
	$scteldeffile = $Parms_str{scteldef};
    }

    if ( !-f $scteldeffile ) {
	&AddReport(2,"................. : ERROR S/C Alignment file '$scteldeffile' not found\n");
	$Task{errmess} = "S/C Alignment Telescope Definition File '$scteldeffile' not found";
	$Task{status} = 1;
	return;
    }

    return $scteldeffile;

} # SetScTeldefFileName

sub CleanHkfile {

    my ( $File, $Tmpfile ) = @_;

    use vars qw( %Task %Default );
    my ( $command, $ret, $par, %fselect );

    if (&CleanTimeNulls($File, $Tmpfile,"FRAME")) {
	if ( $Task{status} ) {return 1;}
    }
    else {
	if ( system("cp -f $File $Tmpfile\n") ) {
	    &PrntChty(2,"$Task{stem}: ERROR: Cannot copy '$File' in '$Tmpfile'\n");
	    &PrntChty(2,"$Task{stem}: ERROR: Command run: 'cp -f $File $Tmpfile' Error: $!\n");
	    $Task{errmess} = "Error: cannot create the '$Tmpfile' file: $!\n";
	    $Task{status} = 1;
	}
    }

    return 0;

} # CleanHkffile

sub OnlyImages {

    my $mode;
    my $only = 1;

    foreach $mode ( 'pc', 'wt', 'lr', 'pu' ) {
	if ($EvtFiles{$mode}{nfiles} != 0) { $only=0; }
    }

    return $only;
} # OnlyImages

sub DelAndRename {

    my ( $file1, $file2 ) = @_;

    &PrntChty(4,"$Task{stem}: Info: Renaming $file1 in\n");
    &PrntChty(4,"$Task{stem}: Info: $file2.\n");

    if ( -f $file1 ) {
	if ( !unlink ($file2) ) {
	    &PrntChty(2,"$Task{stem}: Error: Cannot delete '$file2' file: $!\n");
	    $Task{errmess} = "Cannot overwrite '$file2' file";
	    $Task{status} = 1;
	    return 1;
	}
    
	if ( &RenameFile($file1, $file2) ) {
	    $Task{status} = 1;
	    return 1;
	}
    }
    else {
	&PrntChty(4,"$Task{stem}: WARNING: No Output File Generated by the Task\n");
    }

    return 0;

} # DelAndRename

sub RunXrtExpoMap {

    my ( $EvtFile, $mode) = @_;

    my ( $par, $ret, $ExpoMap, $InstrMap);
    my ( $command, %xrtexpomap );

    use vars qw ( %Task  %InFiles  %Parms_str  %Parms_num  %Parms_bool  %Default );

    my ($DefStemIn);

    &RunningSub("RunXrtExpoMap","xrtexpomap"," on '$EvtFile'");

    %xrtexpomap = (
		  infile          => $EvtFile,
		  attfile         => $Task{evtattfile},
		  hdfile          => $Task{hkfilecorr},
		  stemout         => $Parms_str{stemoutputs},
		  fovfile         => $Parms_str{srcfile},
		  vigfile         => $Parms_str{vigfile},
		  vigflag         => $Parms_bool{vigflag},
		  energy          => $Parms_num{energy},
		  pcnframe        => $Parms_num{expopcnframe},
		  wtnframe        => $Parms_num{expowtnframe},
		  checkattitude   => $Parms_bool{checkattitude},
		  outdir          => $Parms_str{outdir},
		  teldef          => $Task{teldef},
		  cleanup         => $Parms_bool{cleanup},
		  chatter         => $Parms_num{chatter},
		  history         => $Parms_bool{history},
		  clobber         => $Parms_bool{clobber},
		  );


    $command = "xrtexpomap";
    for $par ( keys %xrtexpomap ) { $command .= " $par=$xrtexpomap{$par}"; } 

    &RunningComm("RunXrtExpoMap",$command);

    $ret = 0;
    $ret = system( $command );

    if ( $ret != 0 ) {
	&ErrorComm("RunXrtExpoMap","xrtexpomap",$command);
        $Task{errmess} = "ERROR running 'xrtexpomap'";
	$Task{status} = 1;
	return 1;
    }

    if (!CompUL($Parms_str{stemoutputs},$Default{DEFAULT})) {
	$DefStemIn = $Parms_str{stemoutputs};
	$ExpoMap = &GetValPar("outdir"). "/$DefStemIn" . "_ex.img";
	$InstrMap = &GetValPar("outdir"). "/$DefStemIn" . "_rawinstr.img";
    }
    else
    {
	$DefStemIn = &GetSwXRTDefaultStem($EvtFile);
	if($Task{status})
	{
	    &PrntChty(2,"$Task{stem}: Error: Use 'stemout' input parameter'\n");
	    
	    return 1;
	}

	($ExpoMap, $InstrMap) = &SetExpoMapFileName($EvtFile, $Parms_str{outdir});
    }

    
    if ( -f $ExpoMap ) { 
	&AddReport(3,"$mode: .... Stage  II: Created Exposure Map File '$ExpoMap'\n"); 
    }
    else {
	&AddReport(3,"$mode: .... Stage  II: WARNING: No Exposure Map File '$ExpoMap' created\n"); 
	$Task{status} = 2;
    }
    $InstrMap = $InstrMap.".gz";
    if ( -f $InstrMap ) { 
	&AddReport(3,"$mode: .... Stage  II: Created Raw Instrument Map File '$InstrMap'\n"); 
    }
    else {
	&AddReport(3,"$mode: .... Stage  II: WARNING: No Raw Instrument Map File '$InstrMap' created\n"); 
	$Task{status} = 2;
    }

    &SuccessSub("RunXrtExpoMap","xrtexpomap");
    
    return $ExpoMap,$InstrMap ;

} # RunXrtExpoMap


sub RunXrtLcCorr {

    my ( $EvtFile, $mode) = @_;

    my ( $par, $ret);
    my ( $command, %xrtlccorr );

    use vars qw ( %Task  %InFiles  %Parms_str  %Parms_num  %Parms_bool  %Default );

    my ($DefStemIn);

    my ( $headfilename ) ;
    if ( !CompUL($Parms_str{stemoutputs},$Default{DEFAULT}) ) 
    { $headfilename = $Parms_str{stemoutputs}; }
    else { $headfilename = substr(&ErasePath($EvtFile),0,20); }

    my ( $lcfile ) = "$Parms_str{outdir}/${headfilename}sr.lc";

    %xrtlccorr = (
		  lcfile          => $lcfile,
		  regionfile      => "none",
		  outfile         => "$Parms_str{outdir}/${headfilename}sr_corr.lc",
		  corrfile        => "$Parms_str{outdir}/${headfilename}sr_corrfact.fits",
		  teldef          => $Task{teldef},
		  aberration      => $Parms_bool{aberration},
		  attinterpol     => $Parms_bool{attinterpol},
		  attfile         => $Task{evtattfile},
		  srcx            => -1,
		  srcy            => -1,
		  psffile         => $Parms_str{psffile},
		  psfflag         => "yes",
		  energy          => $Parms_num{energy},
		  createinstrmap  => "yes",
		  outinstrfile    => "$Parms_str{outdir}/${headfilename}_srawinstr.img",
		  infile          => $EvtFile,
		  hdfile          => $Task{hkfilecorr},
		  fovfile         => $Parms_str{srcfile},
		  wtnframe        => $Parms_num{lcwtnframe},
		  pcnframe        => $Parms_num{lcpcnframe},
		  chatter         => $Parms_num{chatter},
		  history         => $Parms_bool{history},
		  clobber         => $Parms_bool{clobber},
		  );


    $command = "xrtlccorr";
    for $par ( keys %xrtlccorr ) { $command .= " $par=$xrtlccorr{$par}"; } 


    if(! -f "$Parms_str{outdir}/${headfilename}sr.lc"){
	&PrntChty(2,"$Task{stem}: Info: No input light curve, cannot run 'xrtlccorr'\n");
	&AddReport(3,"$mode: .... Stage III: WARNING no input light curve, no corrected light curve generated for '$EvtFile'\n");
	return 0;
    }

    &RunningSub("RunXrtLcCorr","xrtlccorr"," on '$lcfile'");
    &RunningComm("RunXrtLcCorr",$command);

    $ret = 0;
    $ret = system( $command );

    if ( $ret != 0 ) {
	&ErrorComm("RunXrtLcCorr","xrtlccorr",$command);
        $Task{errmess} = "ERROR running 'xrtlccorr'";
	$Task{status} = 1;
	return 1;
    }


    if(!$Task{createexpomap}){
	if(system ("gzip -f $xrtlccorr{outinstrfile}")){
	    &PrntChty(2,"$Task{stem}: Warning: Unable to zip $xrtlccorr{outinstrfile} fits file\n");
	}
    }

    &AddReport(3,"$mode: .... Stage III: Corrected Light Curve\n");

    &SuccessSub("RunXrtLcCorr","xrtlccorr");
    return 0;

} # RunXrtLcCorr

sub ResetStatusAndBp {

    my ( $L1file, $mode ) = @_;

    my ( $command, $ret );

    my $tmpfile = substr($L1file,0,rindex($L1file,'.'))."$$.tmp";

    if ( $mode =~ 'pc' || $mode =~ 'wt' ) {

	&PrntChty(3,"$Task{stem}: Info: Reset to 0 the STATUS column\n");

	$command = "ftcalc infile=\'${L1file}\[EVENTS\]\' outfile=$tmpfile column=STATUS expression=0 clobber=$Parms_bool{clobber} chatter=$Parms_num{chatter} history=$Parms_bool{history}";

	&RunningComm("$Task{stem}",$command);

	$ret = 0;
	$ret = system( $command );
	if ( $ret != 0 ) {
	    &ErrorComm("ResetStatusAndBp","ftcalc",$command);
	    $Task{errmess} = "Error: running 'ftcalc'";
	    $Task{status} = 1;
	    return 1;
	}

	if ( &RenameFile($tmpfile,$L1file) ) {
	    $Task{status} = 1;
	    return 1;
	}

	&PrntChty(3,"$Task{stem}: Info: Remove the BADPIX extension written by a previous run\n");

	$command = "ftdelhdu infile=\'${L1file}\[BADPIX\]\' outfile=$tmpfile confirm=no clobber=$Parms_bool{clobber} chatter=$Parms_num{chatter}";

	&RunningComm("$Task{stem}",$command);

	$ret = 0;
	$ret = system( $command );
	if ( $ret != 0 ) {
	    &PrntChty(3,"$Task{stem}: WARNING: error deleting the BADPIX HDU extension\n");
	    &PrntChty(3,"$Task{stem}: WARNING: the $L1file file,\n");
	    &PrntChty(3,"$Task{stem}: WARNING: could not have been previously processed.\n");
	}
	elsif ( &RenameFile($tmpfile,$L1file) ) {
	    $Task{status} = 1;
	    return 1;
	}
    }

    return 0;

} # ResetStatusAndBp


sub UpdateEvtPipeKeys {
    my ($mode,$EvtFile) = @_;
   
    my ($fptr,$status) = (0,0);
    my ($softver,$xrtver,$caldbver);

    chop( $xrtver=`xrtversion`);
    chop( $softver=`fversion`);
    $softver = "Hea_${softver}_${xrtver}";
 

    # retrieve CALDB version
    if( &GetCaldbVersion(\$caldbver) ) {
	$caldbver = "-";
	&PrntChty(2,"$Task{stem}: Warning: unable to retrieve CALDB version, 'CALDBVER' keyword will be set to '$caldbver'\n");
	&PrntChty(4,"$Task{stem}: Warning: '$Task{errmess}'\n");
	$Task{errmess} = "";
	$Task{status} = 0;
    }
    else{
	$caldbver = "x$caldbver";
    }

    # open fits file
    fits_open_file($fptr,$EvtFile,READWRITE,$status);
    if ($status) {
	&PrntChty(3, "$Task{stem}: Error: unable to open '$EvtFile' file.");
	return 1;
    }

    # update 'SOFTVER' keyword
    fits_update_key($fptr,TSTRING,'SOFTVER',$softver,"HEASoft and XRTDAS versions used", $status);
    if ( $status ) {
	&PrntChty(3, "$Task{stem}: Error: cannot update keyword 'SOFTVER' of '$EvtFile' file");
	goto UpdateEvtPipeKeys_end;
    }

    # update 'CALDBVER' keyword
    fits_update_key($fptr,TSTRING,'CALDBVER',$caldbver,"CALDB index version", $status);
    if ( $status ) {
	&PrntChty(3, "$Task{stem}: Error: cannot update keyword 'CALDBVER' of '$EvtFile' file");
	goto UpdateEvtPipeKeys_end;
    }

    # update current HDU checksum
    fits_write_chksum($fptr,$status);
    if ( $status ) {
	&PrntChty(3, "$Task{stem}: Error: cannot update HDU checksum of file '$EvtFile'");
	 goto UpdateEvtPipeKeys_end;
    }
    

    if ( $mode ne "im" ){

	# move to 'EVENTS' extension
	fits_movnam_hdu($fptr,ANY_HDU,"EVENTS",0,$status);
	if ($status) {
	    &PrntChty(3, "$Task{stem}: Error: cannot move into '$EvtFile' file, extension 'EVENTS'");
	    goto UpdateEvtPipeKeys_end;    
	}

	# update 'SOFTVER' keyword
	fits_update_key($fptr,TSTRING,'SOFTVER',$softver,"HEASoft and XRTDAS versions used", $status);
	if ( $status ) {
	    &PrntChty(3, "$Task{stem}: Error: cannot update keyword 'SOFTVER' of '$EvtFile' file");
	    goto UpdateEvtPipeKeys_end;
	}
	
	# update 'CALDBVER' keyword
	fits_update_key($fptr,TSTRING,'CALDBVER',$caldbver,"CALDB index version", $status);
	if ( $status ) {
	    &PrntChty(3, "$Task{stem}: Error: cannot update keyword 'CALDBVER' of '$EvtFile' file");
	    goto UpdateEvtPipeKeys_end;
	}

	# update current HDU checksum
	fits_write_chksum($fptr,$status);
	if ( $status ) {
	    &PrntChty(3, "$Task{stem}: Error: cannot update HDU checksum of file '$EvtFile'");
	    goto UpdateEvtPipeKeys_end;
	}

    }
    else{

	my ($numext);
	fits_get_num_hdus($fptr,$numext,$status);
	if ($status) {
	    $Task{status} = 1;
	    $Task{errmess} = "Cannot get number of extensions from '$EvtFile' file";
	    goto UpdateEvtPipeKeys_end; 
	}

	for (my $i = 2; $i <= $numext; $i++) {
	    fits_movabs_hdu($fptr,$i,ANY_HDU,$status);
	    if ($status) {
		&PrntChty(3, "$Task{stem}: Error: cannot move into '$EvtFile' file, image extension");
		goto UpdateEvtPipeKeys_end;    
	    }

	    # update 'SOFTVER' keyword
	    fits_update_key($fptr,TSTRING,'SOFTVER',$softver,"HEASoft and XRTDAS versions used", $status);
	    if ( $status ) {
		&PrntChty(3, "$Task{stem}: Error: cannot update keyword 'SOFTVER' of '$EvtFile' file");
		goto UpdateEvtPipeKeys_end;
	    }

	    # update 'CALDBVER' keyword
	    fits_update_key($fptr,TSTRING,'CALDBVER',$caldbver,"CALDB index version", $status);
	    if ( $status ) {
		&PrntChty(3, "$Task{stem}: Error: cannot update keyword 'CALDBVER' of '$EvtFile' file");
		goto UpdateEvtPipeKeys_end;
	    }
	    
	    # update current HDU checksum
	    fits_write_chksum($fptr,$status);
	    if ( $status ) {
		&PrntChty(3, "$Task{stem}: Error: cannot update HDU checksum of file '$EvtFile'");
		goto UpdateEvtPipeKeys_end;
	    }
	}

    }


    # close fits file
    if ( $fptr ) {
	$status = 0;
	fits_close_file($fptr,$status);
	if ( $status ) { 
	    &PrntChty(3, "$Task{stem}: Error: cannot close '$EvtFile' event file");
	    return 1;
	}
    }

    return 0;


  UpdateEvtPipeKeys_end:

    # close fits file
    if ( $fptr ) {
	$status = 0;
	fits_close_file($fptr,$status);
    }

    return 1;


} # UpdateEvtPipeKeys
