#! /usr/bin/perl
# File name: xrtproducts
# 
# Task name: xrtproducts
# 
# Description:  
#                  
# 
# Author/Date: Italian Swift Archive Center (Frascati)
# 
# History:
# 
#      0.1.0 :  RP 21/07/2003 - First version
#      0.1.1 :  FT 03/08/2003 - Added 'chatter', 'clobber' 
#                               'display' and 'plotdevice' handle.
#      0.1.2 :  FT 05/08/2003 - Changed Region File Format
#      0.1.3 :  RP 06/08/2003 - Added sort Parms_num
#      0.1.3 :  RP 21/08/2003 - Added filelc,filespectrum,filepha,regionfile parameter
#      0.1.4 :  RP 21/10/2003 - Change parameter name filespectrum in fileimage
#                               Use xselect instead of extractor
#                               If binlc parameter < 0 read set value = 2.5   
#      0.1.5 :  RP 5/11/2003 -  Added windowed and lowrate datamode
#                               Added new parameter pcbinsize,lrbinsize,wtpinsize,height,width           
#                               Check keyword XRTTIMES if datamode = wt or lr
#                               Check keyword XRTPI and XRTDETXY for all datamode 
#                               Check XRTSKYXY for photon datamode
#      0.1.6 : RP 13/11/2003 -  Added new function : SetDetRegion to read detx and detx in a region file
#                                    GetRmfFile and GetGrade 
#                               Added call to xspec and lcurve
#     0.1.7:  RP 18/11/2003  -  Filter rmf file with only datamode 
#     0.1.8:  RP 18/11/2003  - Added control keyword naxis if <= 0   
#     0.1.9:  BS 20/11/2003  - Bug fixed                       
#     0.1.10: RP 21/11/2003  - Bugs fixed
#     0.1.11: RP 24/11/2003  - Bugs fixed
#     0.1.12: RP 24/11/2003  - Minor changes
#     0.1.13: RP 25/11/2003  - Added datamode piled-up
#                              Modify parameter lrbinsize name in pdbinsize
#     0.1.14: BS 25/11/2003  - Minor changes  
#     0.1.15: FT 25/11/2003  - Bug fixed on .xco temporary file
#                              Minor changes
#     0.1.16: RP 26/11/2003  - Added open display for all images
#                              Bugs fixed 
#     0.1.17: FT 26/11/2003  - Bug Fixed
#     0.1.18: RP 27/11/2003  - Bug Fixed
#     0.1.19: RP 19/12/2003  - Added function RequestParameter, change GetInputParameters
#                              add call GetParameterList, LoadParameterFromCmdLine,LoadParameter
#     0.1.20: RP 26/01/2004  - Added call function WriteParameterList to write history Parameter 
#     0.1.21: RP 16/03/2004  - Added parameter RA and DEC
#                              Update file *xselect.xco
#                              Calculate DETX and DETX with fstatistic
#                              Convertsion Ra-Dec in X-Y
#     0.1.22: FT 17/03/2004 -  Minor changes on messag errors
#     0.1.23: RP 19/03/2004 -  Added roll parameter
#                              Remove CheckRa,CheckDec,Ra2Deg,Dec2Deg,RaDec2XY function move into library
#     0.1.24: FT 19/03/2004 -  Added Chatter level to Xspec and lcurve commands (GetXspecChatter subroutine)
#                           -  Added 'clanup' input parameter to allow user to
#                              decide if the temporary scripts should be deleted or not
#                           -  Bug fixed on empty lightcurves check 
#     0.1.25: RP 01/04/2004 -  Added check if column counts in output file pha is empty
#     0.1.26: RP 19/04/2004  - Change call GetKeyword
#                            - Added check binsize
#     0.1.27: RP 21/04/2004  - Bug fixed
#     0.1.28: FT 27/04/2004  -  Added cleanup of xselect temporary files
#     0.1.29: RP 05/05/2004  - Merge (pc-pd-wt)binsize in "binsize" parameter
#                              Change parameter name stemproduct in stemout, evtfile in infile
#                              filelc in lcfile, filepha in phafile, fileimage in imagefile 
#                              Added control datamode = SHORTIMA or LONGIMA 
#                             Increase stem characters  (19 -> 20)\
#    0.1.30 : RP 12/05/2004  - Bugs fixed
#    0.1.31 : RP 12/05/2004 - Change request parameter 
#                             Change stem char if datamode is image
#                             Bug fixed
#    0.1.32 : RP 13/05/2004 - Added check is phafile=NONE and lcfile=NONE
#                             Remove temporary file
#    0.1.33 : RP 13/05/2004 - Bug fixed
#    0.2.0  : FT 19/05/2004 - Bug Fixed on 'fstatistic' run check
#    0.2.1  : BS 20/05/2004 - Minor change
#    0.2.2  : FT 20/05/2004 - Bug fixed: Modified some '=~ /<>/i' with 'eq "<>"'
#    0.2.3  : RP 28/05/2004 - Delete call to read keyword MJDREF
#    0.2.4  : RP 19/07/2004 - Added check value keyword CTYPE1 and CTYPE2 for datamode=imaging
#                             Delete request parameter phafile if datamode is not equal to imaging
#                             Don't delete temporary file of lcurve in case of problem
#                             Check column RATE if is empty for file .lc
#                             Change stem string to lcurve
#                             Added check if exposure is greater than binsize for light curve file
#                             Added new parameter pilow,pihigh gtifile
#                             Added for selection file rmf grade filter
#    0.2.5  : FT 28/07/2004 - Minor change to avoid an odd error message
#                           - Added check on file existence in DeleteFile subroutine
#    0.2.6  : FT 29/07/2004 - inverted check on X/Y and DETX/DETY
#                           - minor bug on array number of elements fixed
#    0.2.7  : RP 03/08/2004 - Move getArrayExtensionImage,trimValue to library
#    0.2.8  : RP 03/08/2004-  Control if arffile parameter is not DEFAULT
#                             Minor change to get grade caldb file
#    0.2.9  : RP 04/08/2004- Minor change to name of temporary lcfile 
#                            Added check if not found skyimage extensions
#    0.2.10 : RP 06/08/2004 - Delete file when light curve is empty
#                             Minor changes
#    0.2.11 : RP 22/09/2004 - Added check if lcfile is deleted when call WriteParameterList
#    0.2.12 : RP 30/09/2004 - Delete function getArrayExtensionImage
#    0.2.13 : MP & MC 04/10/2004 - Deleted message "Image generated" for Photodiode modes (lr and pu)
#    0.2.14 : RP 28/01/2005 - Bug fixed on Request Parameter
#                             Added TNULL check if value is empty for column X,Y,DETX,DETX
#    0.2.15 : RP 02/02/2005 - Bug fixed parameter regionfile
#    0.2.16 : BS 10/02/2005 - Modified to use new 'xrtmkarf' task
#    0.2.17 : BS 15/02/2005 - Added new input parameter 'inarffile'
#    0.2.18 : MP 17/03/2005 - Set PC Image plot energy band to 0.5-10 keV (PI=50-1000)
#    0.2.19 : FT 23/03/2005 - Gives only a warning message if the X/Y coulns are filled 
#                             by NULLs
#    0.2.20 : BS 24/03/2005 - Replaces xspec with xspec11
#                           - Added check on 'ra' and 'dec' input pars if 'regionfile' is not default
#    0.3.0  : BS 25/03/2005 - Modified GetRmfFile return string
#    0.3.1  :    01/07/2005 - set emin to 30 instead of 50 when run ximage  
#    0.3.2  :    19/10/2005 - Added new input parameter 'expofile'
#    0.3.3  :    10/03/2006 - Used expofile also for WT mode                  
#    0.3.4  : FT 15/03/2006 - Do not convert into integers srcx and srcy in the xrtmkarf call
#    0.3.5  : NS 06/07/2007 - Query to CALDB for rmffile depending on time and 'XRTVSUB' of input evt
#    0.3.6  :    05/05/2008 - Changed default region for WT mode from BOX to CIRCLE
#    0.3.7  : NS 14/10/2008 - Changed default 'binsize' value for PC mode
#    0.3.8  :    09/03/2009 - Uses PID in session name when calling xselect
#    0.3.9  :    10/07/2009 - Replaces xspec11 with xspec
#    0.4.0  :    15/10/2009 - Added "scr white" in xselect command file
#                           - Modified xspec command from "ignore **-0.1 10.2-**" to "ignore **-0.3 10.2-**"
#    0.4.1  :    01/07/2010 - Added 'extended' and 'arfboxsize' input parameters
#                           - Changed default 'binsize' value for WT in SETTLING mode
#    0.4.2  :    06/06/2014 - Added extraction of background products for PC and WT mode
#                           - Added correction of the source light curve
#                           - Modified default naming convention of output IM file
#        
#                         
##X
# Notes:        
# 
#   type "fhelp xrtproducts" for parameters description
#
# Usage:     
# 
#   xrtproducts infile=<level1 evt file> outdir=<output-dir> [parameter=value ... ]
#
# Input files:  
#
#   
# Output files: 
#
#
#
# HEADAS tasks needed:
#        pquery2 
#
# LHEASOFT tasks needed:
#        xselect
#        ximage
#        xspec
#        lcurve
#        fstatistic

#============================================================#

use Astro::FITS::CFITSIO qw(:longnames :constants);

require "libswxrtperl.pl";
#require "/home/primavera/src/xrt/lib/xrtperl/libswxrtperl.pl";
#require "/home/tamburelli/src/xrt/lib/xrtperl/libswxrtperl.pl";

#use diagnostics -verbose;
#enable  diagnostics;

use strict;

use Math::Trig;

use vars qw( %Task %Default @filelist $datamode @Par %Ind $obsmode);

my($regionfile,$stemchar, $stemcharimg, $headfilename, $phafile,$phafileshort,$lcfile);


$regionfile = "";
$phafile = "";

my $PI =  3.14159265358979323846;
my $PIS =  3.141592653;
my $EPSR4 =    1E-7;
my $MAXR4 =  1E38;
my $MAX_INTEG = 2147483647;

my $binsize;

$stemchar = 20;
$stemcharimg = 18;

$Task{status} = 0;
#
# Specific of the task
#
%Task = (
         start   => `date`,
         name    => "xrtproducts",
         version => "0.4.2",
         releasedate => "2014-06-06",
         stem    => "xrtproducts_0.4.2",
         emptystem => "               ",
         clobber => 0,  # it means 'clobber=no'
         chatter => 3,
         status  => 0,
         errmess => ""
         );

#
#  Defaults
#

%Default = (
            DEFAULT => "DEFAULT",
            NONE    => "NONE",
#            CCDCENTERDETX   => 300,
#            CCDCENTERDETY   => 300,
            PCBINSIZE => 2.51,
	    WTBINSIZE => 1.0,
	    STWTBINSIZE => 0.1,
	    PDBINSIZE => 1.0
	    );

#  
#   Keywords name
#

&RunningTask;

#
# Get Input Parameters 
#


if ( &GetInputParameters ) {
    $Task{errmess} = "Error parsing input parameters";
    goto EXITWITHERROR;
}

if (( uc(&GetValPar("lcfile")) eq $Default{NONE} ) && 
    ( uc(&GetValPar("phafile")) eq $Default{NONE} ) &&  (&GetValPar("imagefile") =~ /$Default{NONE}/i ))  {

    $Task{errmess} = "lcfile,phafile and imagefile set to false. At least one should be true";
    $Task{status} = 1;
    goto EXITWITHERROR;
}


if (&GetValPar("binsize") < 0) {
    if ($datamode eq "pc") { 
	&SetValPar("binsize", $Default{PCBINSIZE});
    }
    if ($datamode eq "wt") {

	if($obsmode eq "SETTLING"){
	    &SetValPar("binsize", $Default{STWTBINSIZE});
	}
	else{
	    &SetValPar("binsize", $Default{WTBINSIZE});
	}
    }
    if (($datamode eq "lr") || ($datamode eq "pu") ) { 
	&SetValPar("binsize", $Default{PDBINSIZE});
    }

}

$binsize =  &GetValPar("binsize");

#$datamode = &GetEventDataMode($filelist[0]);

for (my $i=0; $i <= $#filelist; $i++) {
    my ($mode) = &GetEventDataMode($filelist[$i]);
	
    if ($mode !~ /(lr|pu|wt|pc|im)/)  {
	$Task{errmess} = "Data mode incorrect: '$mode' ";
	goto EXITWITHERROR;
    }
    if ($datamode !~ $mode) {
	$Task{errmess} = "All files of the 'infile' list should be of the same data mode";
	goto EXITWITHERROR;
    }
    
    
    if ($mode ne "im") {
	my $val;
	&GetKeyword($filelist[$i],"EVENTS", undef,"TIMEDEL",\$val);
	if ( $Task{status} ) { goto EXITWITHERROR; }
	if ($binsize < $val) {
	    $Task{errmess} = "The input bin size ($binsize) should be greater than $val";
	    goto EXITWITHERROR;
	}
    }
}	 


# cut off the last '/'

my $ous = &GetValPar("outdir");

$ous =~ s/\/$// ;

&SetValPar("outdir",$ous);

if ( &GetValPar("clobber") =~ /[yY]/ ) {
    $Task{clobber} = 1;
}


&SetValPar("display",&SetBool(&GetValPar("display")));
if ( $Task{status} ) {
    &PrntChty(2,"$Task{'stem'}: Error: Please check 'display' parameter specification\n");
    goto EXITWITHERROR;
}

if ( &GetValPar("display") && !($Task{viewer} = &GetViewer(&GetValPar("plotdevice")) ) ) {
    &PrntChty(2,"$Task{'stem'}: Warning: no viewer found to plot images\n");
    &PrntChty(2,"$Task{'stem'}: Warning: no display of images will be done\n");
    &SetValPar("display",0);
}

if ( &CreateDir(&GetValPar("outdir")) ) {goto EXITWITHERROR;}

#Check existence of region file

if ($datamode ne "im") {
    
    if (($datamode !~ /(lr|pu|im)/i)) {
	if (!&CompUL(&GetValPar("regionfile"),$Default{DEFAULT})) {
	    if (! -f &GetValPar("regionfile") ) {
		$Task{errmess} = "Region File: '" . &GetValPar("regionfile") . "' not found";
		goto EXITWITHERROR;
	    }
	}
    }
    
    
    if (!&CompUL(&GetValPar("rmffile"),"CALDB") ) {
	if (! -f &GetValPar("rmffile") ) {
	    $Task{errmess} = "Rmf File: '" . &GetValPar("rmffile") . "' not found";
	    goto EXITWITHERROR;
	}
    }
    

    if (!&CompUL(&GetValPar("inarffile"),"CALDB") && !&CompUL(&GetValPar("inarffile"),"NONE")) {
	if (! -f &GetValPar("inarffile") ) {
	    $Task{errmess} = "Input ARF File: '" . &GetValPar("inarffile") . "' not found";
	    goto EXITWITHERROR;
	}
    }

    if ($datamode eq "pc" || $datamode eq "wt") { 
	if (!&CompUL(&GetValPar("expofile"),"NONE")) {
	    if (! -f &GetValPar("expofile") ) {
		$Task{errmess} = "Input exposure map File: '" . &GetValPar("expofile") . "' not found";
		goto EXITWITHERROR;
	    }
    	}
    }
    (@filelist) = &SortArrayTStart(@filelist);
}

if (($datamode ne "pc" && $datamode ne "wt") && (!&CompUL(&GetValPar("expofile"),"NONE")))
{
    &PrntChty(2, "$Task{stem}: Error: Cannot use exposure map for $datamode datamode\n");
    &PrntChty(2, "$Task{stem}: Error: please set 'expofile' input parameter to 'NONE'\n");
    $Task{errmess} = "problem with 'expofile' input parameter set";
    goto EXITWITHERROR;   
}

#Check exist gti file 
if (!&CompUL(&GetValPar("gtifile"),$Default{NONE})) {
    if (! -f &GetValPar("gtifile") ) {
	$Task{errmess} = "GTI File: '" . &GetValPar("gtifile") . "' not found";
	goto EXITWITHERROR;
    }
}

 my ($x,$y);

#Check if stem file is the same is stemout=DEFAULT

  
    for (my $i = 0; $i <= $#filelist; $i++) {
	my ( @XselTmpFiles ) = ( "xsel_timefile.asc", "xselect.log", "xautosav.xcm" );
	my ($type,$val);
	
	&PrntChty(3,"$Task{stem}: Info: Processing $filelist[$i] \n");
	       
	if (!CompUL(&GetValPar("stemout"),$Default{DEFAULT})) {
	    $headfilename = &GetValPar("stemout");
	} else {
	    if ($datamode eq "im") {
		$headfilename = substr(&getFileName($filelist[$i]),0,$stemcharimg);
	    } else { 
	       $headfilename = substr(&getFileName($filelist[$i]),0,$stemchar);
	   }
	}
	

#	if ($datamode eq "im") {	    
#	    
	#    &GetKeyword($filelist[$i], "EVENTS" , undef ,"CTYPE1" ,\$val);
	#    if ( $Task{status} ) { goto EXITWITHERROR; }
	#    if ($val ne "RA---TAN") {
	#	&PrntChty(2,"$Task{stem}: Error: Expected value of keyword CTYP1 = RA---TAN on file '$filelist[$i]')\ n");
	#	$Task{errmess} = "Not expected value of CTYPE1 on '$filelist[$i]' file";
	#	goto EXITWITHERROR;
	#    }
	#    
	#    &GetKeyword($filelist[$i], "EVENTS" , undef, "CTYPE2" ,\$val);
	#    if ( $Task{status} ) { goto EXITWITHERROR; }
	#    if ($val ne "DEC---TAN") {
	#	&PrntChty(2,"$Task{stem}: Error: Expected value of keyword CTYPE2 = RA---TAN on file '$filelist[$i]')\ n");
	#	$Task{errmess} = "Not expected value of CTYPE2 on '$filelist[$i]' file";
	#	goto EXITWITHERROR;
	#    }
	#}



	if (($datamode !~ /(lr|pu)/i) && ( uc(&GetValPar("imagefile")) ne "$Default{NONE}")) {
	    &RunXimage($filelist[$i]);
	}
	
	
	if ($datamode ne "im") {
	    $lcfile = $Default{NONE};
	    $phafile = $Default{NONE};
	    $phafileshort = $Default{NONE};
	    
	    my $imagefile = $Default{NONE};
	    


	   if ( uc(&GetValPar("phafile")) ne $Default{NONE} ) {
	       if ( uc(&GetValPar("phafile")) eq $Default{DEFAULT} ) {
		   $phafile =  &GetValPar("outdir") ."/" . $headfilename . "sr.pha";
		   $phafileshort = $headfilename . "sr.pha";
	       } else { 
		   $phafile = &GetValPar("outdir") ."/" . &GetValPar("phafile"); 
		   $phafileshort =&GetValPar("phafile"); 
	       }
	   }
	   
	   if ( -f $phafile ) {
	       if (!$Task{clobber} ) {
		   &PrntChty(2, "$Task{stem}: Error: the '$phafile' exists\n");
		   &PrntChty(2, "$Task{stem}: Error: please delete '$phafile' or\n");
		   &PrntChty(2, "$Task{stem}: Error: set the input parameter 'clobber' to 'yes'\n");
		   $Task{errmess} = "Cannot overwrite '$phafile' file";
		   $Task{status} = 1;
		   goto EXITWITHERROR;
		   } else { 
		       &DeleteFile($phafile);
		   }
	       
	       &PrntChty(3,"$Task{stem}: Info: The Spectrum File will be '$phafile'\n");
	   }
	   
	   
	   if ( uc(&GetValPar("lcfile")) ne $Default{NONE} ) {
	       if ( uc(&GetValPar("lcfile")) eq $Default{DEFAULT}) {
		   $lcfile =   &GetValPar("outdir") ."/" . $headfilename . "sr.lc";
	       } else { $lcfile = &GetValPar("outdir") ."/" . &GetValPar("lcfile"); }
	       
	       if ( -f $lcfile) {
		   if (!$Task{clobber} ) {
		       &PrntChty(2, "$Task{stem}: Error: the '$lcfile' exists\n");
		       &PrntChty(2, "$Task{stem}: Error: please delete '$lcfile' or\n");
		       &PrntChty(2, "$Task{stem}: Error: set the input parameter 'clobber' to 'yes'\n");
		       $Task{errmess} = "Cannot overwrite '$lcfile' file";
		       $Task{status} = 1;
		       goto EXITWITHERROR;
		   }
		   else { 
		       &DeleteFile($lcfile);
		   }
	       }
	       &PrntChty(3,"$Task{stem}: Info: The Light Curve will be '$lcfile'\n");
	   }



 
	   if (!(( uc(&GetValPar("phafile")) eq $Default{NONE}) && ( uc(&GetValPar("lcfile")) eq $Default{NONE} ))) {

	       #if ( &GetValPar("phafile") !~ /$Default{NONE}/i) {
	       
	       #Check key XRTDETXY
	       if (&CheckCol($filelist[$i],"EVENTS","DETX",undef)) {
		   $Task{errmess} = "file: $filelist[$i] - Column DETX is empty";
		   goto EXITWITHERROR;
		   
	       }
	       if (&CheckCol($filelist[$i],"EVENTS","DETY",undef)) {
		   $Task{errmess} = "file: $filelist[$i] - Columns DETY is empty";
		   goto EXITWITHERROR;
	       }
	       

	       if (($datamode eq "pc") || ($datamode eq "wt")) {
		   
		   #Check key XRTSKYXY
		   if (&CheckCol($filelist[$i],"EVENTS","X",undef)) {
		       if ( $Task{status} == 2 ) { 
			   $Task{errmess} = "file: $filelist[$i] - Column X set to NULLs"; goto EXITWITHWARNING; }
		       else { $Task{errmess} = "file: $filelist[$i] - Column X empty"; goto EXITWITHERROR; }
		   }
		   if (&CheckCol($filelist[$i],"EVENTS","Y",undef)) {
		       if ( $Task{status} == 2 ) { 
			   $Task{errmess} = "file: $filelist[$i] - Column Y set to NULLs"; goto EXITWITHWARNING; }
		       else { $Task{errmess} = "file: $filelist[$i] - Column Y empty"; goto EXITWITHERROR; }
		   }

	       }
	       if ($datamode =~ /(lr|pu|wt)/i){
		   #Check key XRTTIMES
		   &GetKeyword($filelist[$i], "EVENTS" , undef ,"XRTTIMES" ,\$val);
		   if ( $Task{status} ) { goto EXITWITHERROR; }
		   if ($val !~ /t/i) {
		       &PrntChty(2,"$Task{stem}: Error: The '$filelist[$i]' photon are not time tagged\n");
		       &PrntChty(2,"$Task{stem}: Error: Please run 'xrttimetag'\n");
		       $Task{errmess} = "'xrttimetag' task not run on '$filelist[$i]' file";
		       goto EXITWITHERROR;
		   }
	       }
	       
	       
	       if ($datamode !~ /(lr|pu)/) { 

		       

		   if (!CompUL( &GetValPar("regionfile"),$Default{DEFAULT})) {
		       
		       $regionfile =  &GetValPar("regionfile");
		       &PrntChty(4,"$Task{stem}: Info: Region File '$regionfile'\n");
		       
		   }
		   else {
		       $regionfile =  &GetValPar("outdir") . "/" . $headfilename . ".reg";
		       &PrntChty(4,"$Task{stem}: Info: Temporary Region File '$regionfile'\n");
		       if ( ! open(REGFILE,">$regionfile" ) ) {
			   $Task{errmess} = "Unable to write '" .  &GetValPar("regionfile") . "' file";
			   goto EXITWITHERROR;
		       }
		       
		       my $rag = &Ra2Deg(&GetValPar("ra"));
		       my $decg = &Dec2Deg(&GetValPar("dec"));
		      		      		   
		       if (!&RaDec2XY($filelist[$i],$rag,$decg,\$x,\$y)) {goto EXITWITHERROR;}
		       
		       if ($datamode eq "pc") {
			   print REGFILE "CIRCLE ($x,$y," .&GetValPar("radius") .")\n";
			   &PrntChty(3,"$Task{stem}: Info: Extraction Region: CIRCLE( $x,$y," .  &GetValPar("radius") . ")\n");
		       }else {

			   print REGFILE "CIRCLE ($x,$y," .&GetValPar("radius") .")\n";
			   &PrntChty(3,"$Task{stem}: Info: Extraction Region: CIRCLE( $x,$y," .  &GetValPar("radius") . ")\n");	   
			   
#			   my $roll;			
#			   if (($roll = &GetValPar("roll"))<= -999) {
#			       &GetKeyword($filelist[$i],"EVENTS",undef,"PA_PNT",\$roll);
#			       if ( $Task{status} ) { goto EXITWITHERROR; }
#			   }			   
#			   
#			   my $angle = $roll - 90;
#			   
#			   print REGFILE "BOX ($x,$y," . &GetValPar("width") . "," .
#			       &GetValPar("height") . ",$angle )\n";
#			   &PrntChty(3,"$Task{stem}: Info: Extraction Region: BOX($x,$y," . &GetValPar("width") . "," .  &GetValPar("height") . ",$angle)\n");
#


		       }
		       close REGFILE;
		   }
	       }
	   
	       
       
#	       $phafile = "NONE";
#	       $phafileshort = "NONE";
	       
#	       my $imagefile = "NONE";

	       
	       # Open a temporary file with xselect commands;
	       my ( $XselectFile ) =  &GetValPar("outdir") . "/$headfilename" . "_xselect.xco";
	       unlink ($XselectFile );
	       push  @XselTmpFiles , $XselectFile;
	       
	       my ( $pid ) = getppid();
	       
       
	       if ( ! open(XSELFILE, ">$XselectFile" )) {
		   $Task{errmess} = "Unable to create '$XselectFile' file";
		   $Task{status} = 1;
		   goto EXITWITHERROR; 
	       }
	       
	       
	       
	       my $filenopath = substr($filelist[$i],rindex($filelist[$i], '/' )+1);
	       my $onlypath = &GetPath($filelist[$i]);
	       
	       
	       #  print XSELFILE "\n";
	       print XSELFILE "xsel${pid}\n";
	       print XSELFILE  "read eve $filenopath\n";
	       print XSELFILE "$onlypath/\n";
	       print XSELFILE "\n";
	       
	       if ($datamode eq "pc") {
		   if ( uc(&GetValPar("imagefile")) ne $Default{NONE} ) {
		       if (uc(&GetValPar("imagefile")) eq $Default{DEFAULT} ) {
			   $imagefile =  &GetValPar("outdir") . "/$headfilename" . "_sk.img";
		       } else { 
			   $imagefile =   &GetValPar("outdir") ."/" . &GetValPar("imagefile");
		       }
		       
		       if ( &GetValPar("imagefile") !~ /$Default{NONE}/i) {
	                $imagefile =  &GetValPar("outdir") . "/$headfilename" . "_sk.img";
		        if ( -f $imagefile) {
			   if (!$Task{clobber} ) {
			       &PrntChty(2, "$Task{stem}: Error: the '$imagefile' exists\n");
			       &PrntChty(2, "$Task{stem}: Error: please delete '$imagefile' or\n");
			       &PrntChty(2, "$Task{stem}: Error: set the input parameter 'clobber' to 'yes'\n");
			       $Task{errmess} = "Unable to overwrite '$imagefile' file";
			       $Task{status} = 1;
			       goto EXITWITHERROR;
			   } else { 
			       &DeleteFile($imagefile);
			   }
		        }
		       &PrntChty(3,"$Task{stem}: Info: The Image File will be '$imagefile'\n");
		       
		       print XSELFILE "extract image\n";
		       print XSELFILE "save image $imagefile\n";
		       
		      }
		   }   
	       }

	       if (( uc(&GetValPar("phafile")) ne $Default{NONE}) ||( uc(&GetValPar("lcfile")) ne $Default{NONE}))  {
		   if ($datamode eq "wt") {	
		       print XSELFILE "set wmapname X Y\n";
		       print XSELFILE "set xyname X Y\n";
		   } elsif ($datamode eq "pc") {
		       print XSELFILE "set wmapname X Y\n";
		       print XSELFILE "set xyname X Y\n";
		   }
		   if ($regionfile ne "") {
		       print XSELFILE "filter region $regionfile\n";
		   }
	       }
	       if ( uc(&GetValPar("lcfile")) ne $Default{NONE}) {
		   print  XSELFILE "set binsize $binsize\n";    
	       }
	       
	       my ($swgtifile);
	       $swgtifile = 0;

	       if ( uc(&GetValPar("phafile")) ne $Default{NONE}) {
		   if ( uc(&GetValPar("gtifile")) ne $Default{NONE}) {
		       if ($datamode =~ /(pc|lr|wt|pu)/) {
			   print XSELFILE "filter time file " . &GetValPar("gtifile") ."\n";
			   $swgtifile=1;
		       }
		   }
		   print XSELFILE "extract spectrum\n";
		   print XSELFILE "save spectrum $phafile\n";
	       }
	       
	       if ( uc(&GetValPar("lcfile")) ne $Default{NONE}) {
		   if ($datamode =~ /(pc|lr|wt|pu)/i) {
		       print XSELFILE "filter pha_cutoff " . &GetValPar("pilow") . " " . &GetValPar("pihigh") . "\n";
		   }
		   if (( uc(&GetValPar("gtifile")) ne $Default{NONE}) && ($swgtifile ==0))  {
		       if ($datamode =~ /(pc|lr|wt|pu)/) {
			   print XSELFILE "filter time file " . &GetValPar("gtifile") ."\n";
		       }
		   }
		   print XSELFILE "extract curve exposure=0.0\n";
		   print XSELFILE "save curve $lcfile\n";
	       }
	   
	       
	       print XSELFILE "quit\n";
	       print XSELFILE "no\n";
	       
	       close XSELFILE;
	       
   
	       if ( &RunXselect($XselectFile,$filelist[$i]) ) {goto EXITWITHERROR;}    

	       #Check if column rate is empty(all value is equal to 0)
	       if ( uc(&GetValPar("lcfile")) ne $Default{NONE}) {
		   if (&CheckCol($lcfile,"RATE","RATE",0)) {
		       &PrntChty(2,"$Task{stem}: Warning: Light curve file empty (file=$lcfile)'\n");
		       &DeleteFile($lcfile);
		   }
	       }


	       if ( uc(&GetValPar("lcfile")) ne $Default{NONE}) {
		   if (-f $lcfile) {
		       if (&WriteParameterList($lcfile,-1,@Par)) {goto EXITWITHERROR;}
		   }
	       }
	       if ( uc(&GetValPar("phafile")) ne $Default{NONE}) {
		   if (-f $phafile) {
		       if ( &WriteParameterList($phafile,-1,@Par)) {goto EXITWITHERROR};
		   }
	       }
	       if ( &CompUL( &GetValPar("cleanup"), "yes" ) ) {
		   &DeleteFile($XselectFile);
	       }
	   
	       if ( uc(&GetValPar("phafile")) ne $Default{NONE}) { 
		   my ($numaxis);
		   &GetKeyword($phafile,undef,undef,"NAXIS" ,\$numaxis);
		   if ( $Task{status} ) { goto EXITWITHERROR; }
	       
	       }	   
	          
	       if (&CompUL( &GetValPar("regionfile"),$Default{DEFAULT}) && $datamode !~ /(lr|pu)/i) {  
		   if ( &CompUL( &GetValPar("cleanup"), "yes" ) ) {
		       &DeleteFile($regionfile);
		   }
	       }
	   
	   }


 	   if ( &GetValPar("phafile") !~ /$Default{NONE}/i) {


	    if( !($datamode =~ /pc/i) && ( &GetValPar("extended") =~ /[yY]/ ) ){
	       &PrntChty(2,"$Task{stem}: Warning: Generation of ARF for extended sources not supported for datamode='$datamode'\n");
            }
	    else{
       
	       my $arffile = "NONE";
	       my ($numaxis);
	       &GetKeyword($phafile,undef,undef,"NAXIS" ,\$numaxis);
	       if ( $Task{status} ) { goto EXITWITHERROR; }
	       
	       
	       if (($numaxis <= 0) || (&CheckCol($phafile,"SPECTRUM","COUNTS",0))) {
		   &PrntChty(2,"$Task{stem}: Warning: Spectrum file empty'\n");
		   &DeleteFile($phafile);
	       } else {
		   
		   my ($rmffile,$command,$ret) ;
		   
		   
		   if (&CompUL( &GetValPar("rmffile"),"CALDB")) { 
		       $rmffile = &GetRmfFile($filelist[$i]);
		   }else { $rmffile =  &GetValPar("rmffile");}
		   
		   if ($Task{status}) { goto EXITWITHERROR;}

		   
		   &PrntChty(4,"$Task{stem}: Info: RMF file : '$rmffile'\n");
		   
		   if (!$Task{status}) { 
		       

		       my ($dx,$dy);

		       if (uc(&GetValPar("arffile")) eq $Default{DEFAULT} ) {
			   $arffile =  &GetValPar("outdir") . "/$headfilename" . "sr.arf";
		       } else { 
			   $arffile =   &GetValPar("outdir") ."/" . &GetValPar("arffile");
		       }


		       if ( -f $arffile ) {
			   if (!$Task{clobber} ) {
			       &PrntChty(2, "$Task{stem}: Error: the '$arffile' exists\n");
			       &PrntChty(2, "$Task{stem}: Error: please delete '$arffile' or\n");
			       &PrntChty(2, "$Task{stem}: Error: set the input parameter 'clobber' to 'yes'\n");
			       $Task{errmess} = "Cannot overwrite 'arffile' file";
			       $Task{status} = 1;
			       goto EXITWITHERROR;
			   } else { 
			       &DeleteFile($arffile);
			   }
			   
		       }

		       
		       if ($datamode =~ /pc|wt/i) {
			   if ( $x ) { $dx = $x; } else {$dx = 0;}
			   if ( $y ) { $dy = $y; } else {$dy = 0;}
			   
		       } else {
			   my $ret = 0;
			   $ret = system("fstatistic $filelist[$i] colname=detx rows=-");
			   
			   if ($ret) {
			       &ErrorComm("$Task{stem}","fstatistic","fstatistic $filelist[$i] colname=detx rows=- >& /dev/null");
			       $Task{errmess} = "Error running 'fstatistic'";
			       $Task{status} = 1;
			       goto EXITWITHERROR;
			   }
			   
			   chop($dx = `pquery2 fstatistic mean`);
			   if ( !$dx && $dx!=0) {
			       $Task{errmess} = "Error running 'pquery2 fstatistic mean'";
			       $Task{status} = 1;
			       goto EXITWITHERROR; 
			   }
			   $ret = system("fstatistic $filelist[$i] colname=dety rows=-");
			   if ( $ret) {
			       &ErrorComm("$Task{stem}","fstatistic","fstatistic $filelist[$i] colname=dety rows=- >& /dev/null");
			       $Task{errmess} = "Error running 'fstatistic'";
			       $Task{status} = 1;
			       goto EXITWITHERROR;
			   }
			   chop($dy = `pquery2 fstatistic mean`);
			   if ( !$dy && $dy!=0) {
			       $Task{errmess} = "Error running: 'pquery2 fstatistic mean'";
			       $Task{status} = 1;
			       goto EXITWITHERROR;
			   }
			
		       }

		       $command= "xrtmkarf phafile=$phafile outfile=$arffile rmffile=$rmffile offaxis=-99" .
			         " mirfile=" .  &GetValPar("mirfile") . " transmfile=" .  &GetValPar("transmfile") . " psffile=" . 
			         &GetValPar("psffile") . " vigfile=" .  &GetValPar("vigfile") . " psfflag=" .  &GetValPar("psfflag") .
				 " extended=" . &GetValPar("extended") . " boxsize=" . &GetValPar("arfboxsize") .
				 " srcx=" . $dx . " srcy=" . $dy . " clobber=" .  &GetValPar("clobber") . " chatter=" .  
				 &GetValPar("chatter") . " history=" . &GetValPar("history")." inarffile=" . &GetValPar("inarffile")." expofile=" . &GetValPar("expofile").
				 " cleanup=".&GetValPar("cleanup");


		       &RunningSub("$Task{stem}","xrtmkarf");
		       &RunningComm("$Task{stem}",$command);

		       $ret = system( $command);
		       if ($ret != 0) {
			   &PrntChty(2,"$Task{stem}: Error: command: $command\n");
			   $Task{errmess} = "Unable to execute xrtmkarf";
			   $Task{status} = 1;
			   goto EXITWITHERROR;  
		       }
		   
			 
		   
		       # Open a temporary file with xselect commands;
		       my ( $xcmfile ) =  &GetValPar("outdir") . "/$headfilename" . "_xspec.xcm";
		       unlink ($xcmfile );
		       
		       if ( ! open ( XCMFILE, ">$xcmfile" )) {
			   $Task{errmess} = "Unable to create '$xcmfile' file";
			   $Task{status} = 1;
			   goto EXITWITHERROR; 
		       }
		       
		       my $file =  &GetValPar("outdir") . "/" . $headfilename . "ph." .  &GetValPar("plotdevice"); 
		       my $dev =  &GetValPar("plotdevice");
		       if ( $dev eq "ps" ) { $dev = "cps"; }
		       
		       # set xspec chatter
		       my ( $xspecchat ) = &GetXspecChatter($Task{chatter});
		       #  print XSELFILE "\n";
		       print XCMFILE "chatter $xspecchat\n";
		       print XCMFILE "data $phafile\n";
		       print XCMFILE "response $rmffile\n";
		       print XCMFILE "arf $arffile\n";
		       print XCMFILE "setplot energy\n";
		       print XCMFILE "ignore **-0.3 10.2-**\n";
		       print XCMFILE "setplot rebin 2 200\n";
		       print XCMFILE "setplot command \" cpd $file/$dev\"\n";
		       print XCMFILE "setplot command \"time off\"\n";
		       print XCMFILE "setplot command \"la t Energy spectrum($phafileshort)\"\n";
		       print XCMFILE "setplot command \"la f\"\n"; 
		       print XCMFILE "plot ldata\n";
		       print XCMFILE "quit\n";
		       print XCMFILE "y\n";
		       
		       close(XCMFILE);
		   
		       $command = "xspec - $xcmfile\n";
		       $ret = system($command);
		       
		       if ($ret != 0) {
			   $Task{errmess} = "Error running xspec - $xcmfile\n";
			   $Task{status} = 1;
			   goto EXITWITHERROR; 
		       }
		       if ( &CompUL( &GetValPar("cleanup"), "yes" ) ) {
			   &DeleteFile($xcmfile);
		       }


		       if (  &GetValPar("display") ) {
			   if (&PlotImage( $Task{viewer}, $file )) {
			       &PrntChty(3,"$Task{stem}: Warning: cannot display '$file' image\n"); 
			   }
		       }
		   }
		   
	       }
	    
	     } #

	   }

	   if ((&GetValPar("lcfile") !~ /$Default{NONE}/i) && (-f $lcfile)) {

	       my ($numaxis);
	       &GetKeyword("$lcfile","RATE",undef,"NAXIS2",\$numaxis);
	       if ( $Task{status} ) { goto EXITWITHERROR; }
	       
	       my ($expo);
	       &GetKeyword("$lcfile","RATE",undef,"EXPOSURE",\$expo);
	       if ( $Task{status} ) { goto EXITWITHERROR; }
	       if ($expo < $binsize) {
		    &PrntChty(2,"$Task{stem}: Warning: Unable to create gif file for light curve\n");
		    &PrntChty(2,"$Task{stem}: Warning: set binsize greater than $expo - $binsize\n");
		}
	       elsif ($numaxis <= 0) {
		   &PrntChty(2,"$Task{stem}: Warning: Light curve file empty '\n");
		   &DeleteFile($lcfile);
	       } else {
		   my ( $lcurvefile ) =  &GetValPar("outdir") . "/$headfilename" . "sr.pco";
		   my ( $lcurvefileshort ) = "$headfilename" . "sr.lc";
		   unlink ($lcurvefile );
		   
		       if ( ! open ( LCUFILE, ">$lcurvefile" )) {
			   $Task{errmess} = "Unable to create '$lcurvefile' file";
			   $Task{status} = 1;
			   goto EXITWITHERROR; 
		       }
		   
		   my $file =  &GetValPar("outdir") ."/" . $headfilename . "lc." .  &GetValPar("plotdevice"); 
		   my $dev =  &GetValPar("plotdevice");
		   if ( $dev eq "ps" ) { $dev = "cps"; }
		   
		   #  print XSELFILE "\n";
		   print LCUFILE "la t Light curve ($lcurvefileshort)\n";
		   print LCUFILE "scr white\n";
		   print LCUFILE "pl\n";
		   print LCUFILE "quit\n";
		   
		   close(LCUFILE);
		   
		       
		   my ( $xspecchat ) = &GetXspecChatter($Task{chatter});	       
		   my $tmplcfile = "$headfilename.flc";
		   my $command = "lcurve nser=1 cfile1=$lcfile window=- dtnb=INDEF nbint=INDEF outfile=$tmplcfile plot=yes plotdev=$file/$dev plotfile=$lcurvefile tchat=$xspecchat";
		   my $ret = system ($command);
		   if ($ret != 0) {
		       &PrntChty(2,"$Task{stem}: Error: command: $command\n");
		       $Task{errmess} = "Error running lcurve";
		       $Task{status} = 1;
		       goto EXITWITHERROR; 
		   }
		   if ( &CompUL( &GetValPar("cleanup"), "yes" ) ) {	       
		       &DeleteFile($lcurvefile);
		       &DeleteFile("$tmplcfile");
		   }
		   
		   if (  &GetValPar("display") ) {
		       if (&PlotImage( $Task{viewer}, $file )) {
			   &PrntChty(3,"$Task{stem}: Warning: Unable to display '$file' image\n"); 
		       }
		   }

		   #  Correct source light curve
		   if ( &CompUL( &GetValPar("correctlc"),"yes") ) {
		       if ( &RunXrtLcCorr($lcfile,$filelist[$i],$headfilename) ) {goto EXITWITHERROR;} 
		   }

	       }
	   }


	   if ( &CompUL( &GetValPar("cleanup"), "yes" ) ) {
	       my $tmpfile;
	       foreach $tmpfile (@XselTmpFiles) {
		   if ( -f $tmpfile ) {
		       if ( !unlink ( $tmpfile ) ) {
			   &PrntChty(2,"$Task{stem}: Warning: Unable to delete '$tmpfile' file\n");
		       }
		   }
	       }
	   }
       }


       if ( &CompUL( &GetValPar("bkgextract"),"yes") ) {

       if (($datamode eq "pc")||($datamode eq "wt")) {

	   my $bkglcfile = $Default{NONE};
	   my $bkgphafile = $Default{NONE};
	   my $bkgregionfile = &GetValPar("bkgregionfile");


	   if ( uc(&GetValPar("bkgphafile")) ne $Default{NONE} ) {
	       if ( uc(&GetValPar("bkgphafile")) eq $Default{DEFAULT} ) {
		   $bkgphafile =  &GetValPar("outdir") ."/" . $headfilename . "bkg.pha";
	       } 
	       else { 
		   $bkgphafile = &GetValPar("outdir") ."/" . &GetValPar("bkgphafile"); 
	       }
	   }
	   
	   if ( -f $bkgphafile ) {
	       if (!$Task{clobber} ) {
		   &PrntChty(2, "$Task{stem}: Error: the '$bkgphafile' exists\n");
		   &PrntChty(2, "$Task{stem}: Error: please delete '$bkgphafile' or\n");
		   &PrntChty(2, "$Task{stem}: Error: set the input parameter 'clobber' to 'yes'\n");
		   $Task{errmess} = "Cannot overwrite '$bkgphafile' file";
		   $Task{status} = 1;
		   goto EXITWITHERROR;
		   } else { 
		       &DeleteFile($bkgphafile);
		   }
	       
	       &PrntChty(3,"$Task{stem}: Info: The Background Spectrum File will be '$bkgphafile'\n");
	   }
	   
	   
	   if ( uc(&GetValPar("bkglcfile")) ne $Default{NONE} ) {
	       if ( uc(&GetValPar("bkglcfile")) eq $Default{DEFAULT}) {
		   $bkglcfile =   &GetValPar("outdir") ."/" . $headfilename . "bkg.lc";
	       } 
	       else { 
		   $bkglcfile = &GetValPar("outdir") ."/" . &GetValPar("bkglcfile"); 
	       }
	       
	       if ( -f $bkglcfile) {
		   if (!$Task{clobber} ) {
		       &PrntChty(2, "$Task{stem}: Error: the '$bkglcfile' exists\n");
		       &PrntChty(2, "$Task{stem}: Error: please delete '$bkglcfile' or\n");
		       &PrntChty(2, "$Task{stem}: Error: set the input parameter 'clobber' to 'yes'\n");
		       $Task{errmess} = "Cannot overwrite '$bkglcfile' file";
		       $Task{status} = 1;
		       goto EXITWITHERROR;
		   }
		   else { 
		       &DeleteFile($bkglcfile);
		   }
	       }
	       &PrntChty(3,"$Task{stem}: Info: The Background Light Curve will be '$bkglcfile'\n");
	   }

	   if (!(( uc(&GetValPar("bkgphafile")) eq $Default{NONE}) && ( uc(&GetValPar("bkglcfile")) eq $Default{NONE} )) ) {

	       # Open a temporary file with xselect commands;
	       my ( $XselectFile ) =  &GetValPar("outdir") . "/$headfilename" . "_xselect_bkg.xco";
	       unlink ($XselectFile );
	       push  @XselTmpFiles , $XselectFile;
	       
	       my ( $pid ) = getppid();
	       
       
	       if ( ! open(XSELFILE, ">$XselectFile" )) {
		   $Task{errmess} = "Unable to create '$XselectFile' file";
		   $Task{status} = 1;
		   goto EXITWITHERROR; 
	       }
	       
	       	       
	       my $filenopath = substr($filelist[$i],rindex($filelist[$i], '/' )+1);
	       my $onlypath = &GetPath($filelist[$i]);
	       
	       
	       #  print XSELFILE "\n";
	       print XSELFILE "xsel${pid}\n";
	       print XSELFILE  "read eve $filenopath\n";
	       print XSELFILE "$onlypath/\n";
	       print XSELFILE "\n";
	       print XSELFILE "set wmapname X Y\n";
	       print XSELFILE "set xyname X Y\n";
	       print XSELFILE "filter region $bkgregionfile\n";

	       if ( uc(&GetValPar("bkglcfile")) ne $Default{NONE}) {
		   print  XSELFILE "set binsize $binsize\n";    
	       }

	       if ( uc(&GetValPar("bkgphafile")) ne $Default{NONE}) {
		   print XSELFILE "extract spectrum\n";
		   print XSELFILE "save spectrum $bkgphafile\n";
	       }

	       if ( uc(&GetValPar("bkglcfile")) ne $Default{NONE}) {
		   print XSELFILE "filter pha_cutoff " . &GetValPar("pilow") . " " . &GetValPar("pihigh") . "\n";
		   print XSELFILE "extract curve exposure=0.0\n";
		   print XSELFILE "save curve $bkglcfile\n";
	       }

	       print XSELFILE "quit\n";
	       print XSELFILE "no\n";
	       
	       close XSELFILE;


	       if ( &RunXselect($XselectFile,$filelist[$i]) ) {goto EXITWITHERROR;} 	       


	       if ( uc(&GetValPar("bkglcfile")) ne $Default{NONE}) {
		   if (-f $bkglcfile) {
		       if (&WriteParameterList($bkglcfile,-1,@Par)) {goto EXITWITHERROR;}
		   }
	       }
	       if ( uc(&GetValPar("bkgphafile")) ne $Default{NONE}) {
		   if (-f $bkgphafile) {
		       if ( &WriteParameterList($bkgphafile,-1,@Par)) {goto EXITWITHERROR;}
		   }
	       }

	       if ( &CompUL( &GetValPar("cleanup"), "yes" ) ) {
		   my $tmpfile;
		   foreach $tmpfile (@XselTmpFiles) {
		       if ( -f $tmpfile ) {
			   if ( !unlink ( $tmpfile ) ) {
			       &PrntChty(2,"$Task{stem}: Warning: Unable to delete '$tmpfile' file\n");
			   }
		       }
		   }
	       }

	   }

       }
       else{
	   &PrntChty(2, "$Task{stem}: Error: extraction of background data products not supported for '$datamode' mode.\n");
	   $Task{errmess} = "Extraction of background data products not supported for '$datamode' mode.";
	   $Task{status} = 1;
	   goto EXITWITHERROR;  
       }
       }


	&Success("Processed '" .  &GetValPar("infile") . "'");
   }


exit (0);

 EXITWITHERROR:
    &Error;

exit (1);

 EXITWITHWARNING:
    &PrntChty(2,"$Task{stem}: Warning: Cannot generate products, SKY coordinates out of CCD\n");
    &PrntChty(2,"-------------------- xrtproducts  warning -----------------------\n");
    &PrntChty(2,"$Task{stem}: Warning: $Task{errmess}\n");
    &PrntChty(2,"--------------------------------------------------------------\n");

exit (0);
       

sub DeleteFile(){
    my ($namefile) = @_;
    if (-f $namefile && ! unlink($namefile)) {
    	 $Task{errmess} = "Unable to delete expected temporary $namefile. $!";
     $Task{status} = 1;
    goto EXITWITHERROR;
     }
    #}    
}


#------------------------------------------------------------
# subroutines section
#-----------------------------------------------------------

#
# Get Input Parameters 
#

sub RunXimage(){

	my($filename) = @_;

	use vars qw($headfilename $datamode);
	
	my $ImgFile;
	if ($datamode =~ /pc/i) {
	    $ImgFile =  &GetValPar("outdir") . "/" . $headfilename . "_sk." .  &GetValPar("plotdevice"); 
	} else {
	    $ImgFile =  &GetValPar("outdir") . "/" . $headfilename . "im." .  &GetValPar("plotdevice"); 
	}  


	if ( -f $ImgFile) {
	    if (!$Task{clobber} ) {
		&PrntChty(2, "$Task{stem}: Error: the '$ImgFile' exists\n");
		&PrntChty(2, "$Task{stem}: Error: please delete '$ImgFile' or\n");
		&PrntChty(2, "$Task{stem}: Error: set the input parameter 'clobber' to 'yes'\n");
		$Task{errmess} = "Unable to overwrite '$ImgFile' file";
		$Task{status} = 1;
		goto EXITWITHERROR;
	    } else { 
		&DeleteFile($ImgFile);
	    }
	}
	


	my ($dev) =  &GetValPar("plotdevice");
	if ( $dev eq "ps" ) { $dev = "cps"; }
	
	&RunningSub("$Task{stem}","ximage", " on '$filename'");

	# Open a temporary file with ximage commands;
         my ( $XimageFile ) =  &GetValPar("outdir") . "/" . $headfilename . ".xco";
         unlink ( $XimageFile );

         if ( ! open ( XIMFILE, ">$XimageFile" )) {
	     $Task{errmess} = "Unable to create '$XimageFile' file";
	     $Task{status} = 1;
	     goto EXITWITHERROR; 
         }

	 if (  &GetValPar("chatter") <= 4 ) {
	     print XIMFILE "chat 0\n";
	 }
        if ($datamode =~ /pc/i) {
	    print XIMFILE "read/size=600/ecol=pi/emin=30/emax=1000 $filename\n";
	    print XIMFILE "cey 2000\n";
	    print XIMFILE "smo\n";
	    print XIMFILE "cpd $ImgFile/$dev\n";
	    print XIMFILE "disp;grid\n";
	    print XIMFILE "cpd /xs\n";
	    print XIMFILE "quit";
	}elsif ($datamode =~ /im/i) {
	    my($fptr,$status,$numext,@listext);

	    @listext = &getArrayExtensionImage($filename);
	    if ($Task{status}) { goto EXITWITHERROR;}
	    
	    if ($#listext == -1) { 
		$Task{errmess} = "The $filename file is in raw coordinates. Unable to produce a sky coordinate image";
		goto EXITWITHERROR;
	    }

	    if ($#listext >= 0) {
		print XIMFILE "read/size=600 $filename+$listext[0];save_ima\n";
	    }
	    for (my $i = 1; $i <= $#listext; $i++) {
		 print XIMFILE "read/size=600 $filename+" . +$listext[$i] . ";sum_ima;save_ima\n"
	    }
	    print XIMFILE "cey 2000\n";
	    print XIMFILE "smo\n";
	    print XIMFILE "cpd $ImgFile/$dev\n";
	    print XIMFILE "disp;grid\n";
	    print XIMFILE "cpd /null\n";
	    print XIMFILE "quit\n";

	       
	} else {
	    print XIMFILE "read/size=600/xcol=detx/ycol=rawy/xpix=300/ypix=300 $filename\n";
	    print XIMFILE "cpd $ImgFile/$dev\n";
	    print XIMFILE "disp\n";
	    print XIMFILE "vplabel/bottom/margin=2.5/color=0 \"X Pixels\"\n";	    
	    print XIMFILE "vplabel/bottom/margin=2.5 \"DETX Pixels\"\n";	    
	    print XIMFILE "vplabel/left/margin=0.7/color=0/lwidth=10/position=0.33 '200'\n";	    	   
	    print XIMFILE "vplabel/left/margin=0.7/color=0/lwidth=10/position=0.67 '400'\n";	    	   
	    print XIMFILE "vplabel/left/margin=0.7/color=0/lwidth=10/position=1 \"600\"\n";	    	   
	    print XIMFILE "vplabel/left/margin=2.2/color=0 \"Y Pixels\"\n";	    	  
 	    print XIMFILE "vplabel/left/margin=2.2 \"Folded Time\"\n";	    	   
	    print XIMFILE "cpd /xs\n";
	    print XIMFILE "quit\n";
	}
	
	close ( XIMFILE );

	my ( $command ) = "ximage \@$XimageFile";
	&RunningComm("$Task{stem}",$command);
	if (  system( "ximage \@$XimageFile" ) ) {
	    &ErrorComm("RunExtractor","ximage",$command);
	    &PrntChty(2,"$Task{stem}: Error: running command: 'ximage \@$XimageFile'\n");
	    $Task{errmess} = "Error Running 'ximage'";
	    $Task{status} = 1;
	    goto EXITWITHERROR;
	}

	if ( &CompUL( &GetValPar("cleanup"), "yes" ) ) {
	    &DeleteFile($XimageFile);
	}

	 if (  &GetValPar("display") ) {
	     if (&PlotImage( $Task{viewer}, $ImgFile )) {
		 &PrntChty(2,"$Task{stem}: Warning: cannot display '$ImgFile' image\n"); 
	     }
	 }
	&SuccessSub("$Task{stem}","ximage","Created  '$ImgFile' image");
	return ;
}


sub GetInputParameters {

    use vars qw( %Task $datamode @Par %Ind);
  
    my ( $name, $indref, $p);

    ($indref,@Par) = &GetParameterList();

    $Task{chatter} = 3;

    if ($Task{status}) { goto EXITWITHERROR;}

    
    %Ind = %$indref;

    if (! &LoadParameterFromCmdLine(@ARGV)) {
	&PrntChty(2,"$Task{stem}: Error: $Task{errmess}\n");
	return 1;
    }
    

    if (&GetValPar("infile","set") == 0 )  {
	my $Stringa = "";
	chop($Stringa = `pquery2 xrtproducts infile`);
	if ( !$Stringa) {
	    &PrntChty(2,"$Task{stem}: Error: running: 'pquery2 xrtproducts infile'\n");
	    return 1;
	}
	&SetValPar("infile",$Stringa);
	&SetValPar("infile",2,"set");
    }



    #Check if it is a list of files

      
    if (&GetValPar("infile") =~ /^@/) {
	my($fv) = substr(&GetValPar("infile"),1);
	
	if( ! -f $fv ) {
	    $Task{status} = 0;
	    $Task{errmess} = "Input Event File List: '$fv' not found";
	    goto EXITWITHERROR;
	}
	
	if ( ! open(FILELIST,$fv ) ) {
	    $Task{errmess} = "Cannot open '$fv' file";
	    goto EXITWITHERROR;
	}

	while (<FILELIST>) {
	    chop();
	    push(@filelist,$_);
	    if (! -f $_) {  
		$Task{errmess} = "Input Event File: '$_' not found";
		goto EXITWITHERROR;
	    }
	}
	close(FILELIST);
    }
    else {
	$filelist[0] = &GetValPar("infile");
	if( ! -f  &GetValPar("infile") ) {
	    $Task{errmess} = "Input Event File: '" . &GetValPar("infile") . "' not found";
	    goto EXITWITHERROR;
	}
    }

    $datamode = &GetEventDataMode($filelist[0]);
    if ( $Task{status} ) {
	goto EXITWITHERROR;
    }

    if ($datamode !~ /(lr|pu|wt|pc|im)/)  {
	$Task{errmess} = "Incorrect Data Mode: '$datamode' ; '$filelist[0]' event file";
	goto EXITWITHERROR;
    }


    if ($datamode !~ /(lr|pu|im)/) { 
	if ( &GetValPar("regionfile","set") == 0 ) {
	    my $Stringa = "";
	    chop($Stringa = qx(pquery2 xrtproducts regionfile));
	    if ( !$Stringa ) {
		print "ERROR: error running: 'pquery2 xrtproducts regionfile'\n";
		return 1;
	    }
	    &SetValPar("regionfile", $Stringa);
	    &SetValPar("regionfile",2,"set");
	}
    }

    if ($datamode ne "im") {

	&GetKeyword($filelist[0], "EVENTS", undef, "OBS_MODE", \$obsmode);
	if ( $Task{status} ) {
	    goto EXITWITHERROR;
	}

	if ( &GetValPar("phafile","set") == 0 ) {
	    my $Stringa = "";
	    chop($Stringa = qx(pquery2 xrtproducts phafile));
	    if ( !$Stringa ) {
		&PrntChty(2,"$Task{stem}: Error: running: 'pquery2 xrtproducts phafile'\n");
		return 1;
	    }
	    &SetValPar("phafile", $Stringa);
	    &SetValPar("phafile",2,"set");
	}
    }

    #filelc
    if ( &GetValPar("lcfile","set") == 0 ) {
	my $Stringa = "";
	chop($Stringa = qx(pquery2 xrtproducts lcfile));
	if ( !$Stringa ) {
	    print "ERROR: error running: 'pquery2 xrtproducts lcfile'\n";
	    return 1;
	}
	&SetValPar("lcfile", $Stringa);
	&SetValPar("lcfile",2,"set");
    }

    #expofile
    if ( &GetValPar("expofile","set") == 0 ) {
	my $Stringa = "";
	chop($Stringa = qx(pquery2 xrtproducts expofile));
	if ( !$Stringa ) {
	    print "ERROR: error running: 'pquery2 xrtproducts expofile'\n";
	    return 1;
	}
	&SetValPar("expofile", $Stringa);
	&SetValPar("expofile",2,"set");
    }

    if ( &GetValPar("bkgextract","set") == 0 ) {
	my $Stringa = "";
	chop($Stringa = qx(pquery2 xrtproducts bkgextract));
	if ( !$Stringa ) {
	    print "ERROR: error running: 'pquery2 xrtproducts bkgextract'\n";
	    return 1;
	}
	&SetValPar("bkgextract", $Stringa);
	&SetValPar("bkgextract",2,"set");
    }

    if ( &GetValPar("correctlc","set") == 0 ) {
	my $Stringa = "";
	chop($Stringa = qx(pquery2 xrtproducts correctlc));
	if ( !$Stringa ) {
	    print "ERROR: error running: 'pquery2 xrtproducts correctlc'\n";
	    return 1;
	}
	&SetValPar("correctlc", $Stringa);
	&SetValPar("correctlc",2,"set");
    }


    foreach $p (@Par) {
	if (($p->{set} == 1) && (!&RequestParameter($p->{name}))) {
	    &PrntChty(2,"$Task{stem}: Error: $Task{errmess}\n");
	    return 1;
	}
    }

    $Task{errmess} = "";
   if (! &LoadParameter()) {
       &PrntChty(2,"$Task{stem}: Error: $Task{errmess}\n");
       return 1;
   }

    $Task{chatter} = &GetValPar("chatter");

    if (&GetValPar("ra","set") != 0 )  {
	if (!&CheckRa("RA",&GetValPar("ra"))) { goto EXITWITHERROR;}
    }
    if (&GetValPar("dec","set") != 0 )  {
	if (!&CheckDec("DEC",&GetValPar("dec"))) { goto EXITWITHERROR;}
	
    }

    if( (&GetValPar("lcfile") =~ /$Default{NONE}/i) && (&CompUL( &GetValPar("correctlc"),"yes")) ){ 
	&PrntChty(2,"$Task{stem}: Error: Parameter lcfile set to NONE, cannot correct source light-curve.\n");
	goto EXITWITHERROR;
    }


    return 0;
} # GetInputParameters



sub RunXselect {

    my ($xcofile,$evtfile) = @_;
    use vars qw( %Task );
    my ( $command, $ret, $par, %extractor );


    &RunningSub("$Task{stem}","xselect", " on '$xcofile'");

    # set expression specific the the datamode
    #
    # Build the command line to run 'extractor'
    #

   $command = "xselect @" . $xcofile;
  

    &RunningComm("$Task{stem}",$command);
    
    $ret = 0;
    $ret = system( $command );
    
    if ( $ret != 0 ) {
	&ErrorComm("$Task{stem}","xselect",$command);
        $Task{errmess} = "Error running 'xselect'";
	$Task{status} = 1;
	goto EXITWITHERROR;
    }

    # check errors from 'xselect.log' file
    $ret = 0;
    $ret = &CheckXselectLog();

    if ( $ret != 0 ) {
	&ErrorComm("$Task{stem}","xselect",$command);
        $Task{errmess} = "Error running 'xselect'";
	$Task{status} = 1;
	return 1;
    }

    my $strmsg = "";

    if (&GetValPar("lcfile") !~ /$Default{NONE}/i) { $strmsg = "Light Curve ";}
    if (&GetValPar("phafile") !~ /$Default{NONE}/i) {$strmsg =  $strmsg eq "" ? "Spectrum " : $strmsg . ",Spectrum ";}


    if ($datamode !~ /(lr|pu)/i) {
      if (&GetValPar("imagefile") !~ /$Default{NONE}/i) { $strmsg = $strmsg eq "" ? "Image" : $strmsg . "and Image ";}
    }

    &SuccessSub("$Task{stem}","xselect","$strmsg generated for '$evtfile'");
    return 0;
    
} # RunExtractor


#Return value of a specific extension

sub GetValue(){
        my ($filename,$key,$extension) = @_;
        my ($row,$val);
	
	$row = `fkeyprint $filename+$extension $key | grep -i "$key\[ \]*="`;
        chop($row);
        my ($p,$comment) = split(/\//,$row);
        ($p,$val) = split(/=/,$p);
        $val = trim($val);
	chomp($val);  # get rid of \n
	$val =~ s/^\s+//; # remove leading spaces
	$val =~ s/\s+$//; # remove trailing spaces	
	$val =~ s/^'//g;; #Remove apex
        $val =~ s/'$//g;; #Remove apex
	$val =~ s/\s+$//g;; #Remove right space
        return $val;
}

#----------------------------------------------------------------------#
#  FUNCTION:  hashValueAscendingNum                                    #
#                                                                      #
#  PURPOSE:   Help sort a hash by the hash 'value', not the 'key'.     #
#             Values are returned in ascending numeric order (lowest   #
#             to highest).                                             #
#----------------------------------------------------------------------#


sub hashValueAscendingNum {
    use vars qw(%htstart);
   $htstart{$a} <=> $htstart{$b};   
}

#Sort file for TSTART : parameter array of file
sub SortArrayTStart {
	
	my (@file) = @_;
	my ($i,@f,$key,$tstart);

	for ($i=0; $i <= $#file ; $i++) {
	    &GetKeyword($file[$i],"EVENTS",undef, "TSTART", \$tstart);
	    if ( $Task{status} ) { goto EXITWITHERROR; }
	    $htstart{$i} = $tstart;
	}

	$i = -1;
	foreach $key (sort hashValueAscendingNum (keys(%htstart))) {
   		$i++;
   		$f[$i] = $file[$key];

	}

	return @f;

}
	

#Return name file without path

sub getFileName() {

	my ($fn) = @_;
	my $pos = rindex($fn,"/");
	if ($pos == -1) {return $fn;}
	else {return substr($fn,$pos+1);}
} 




sub RequestParameter(){
    use vars qw ($datamode %Default %Task);
    my ($par_name) = @_;
   
    $Task{errmess} = "Input parameters not compatible with datamode: $datamode";

    if ($datamode eq "im") {
	if ((uc(&GetValPar("gtifile")) ne "$Default{NONE}") && ($par_name eq "gtifile")) {
	    $Task{errmess} = "Cannot insert $par_name when datamode=IMAGING";
	    return 0;
	}
	if ((uc(&GetValPar("expofile")) ne "$Default{NONE}") && ($par_name eq "expofile")) {
	    $Task{errmess} = "Cannot insert $par_name when datamode=IMAGING";
	    return 0;
	}
	if (($par_name eq "pilow") || ($par_name eq "pihigh")) {
	    $Task{errmess} = "Cannot insert $par_name when datamode=IMAGING";
	    return 0;
	}	
	if (($par_name eq "infile") || ($par_name eq "outdir") || 
	    ($par_name eq "stemout") || ($par_name eq "display") || ($par_name eq "plotdevice") || ($par_name eq "chatter") ||  
	    ($par_name eq "history")  || ($par_name eq "cleanup")|| ($par_name eq "clobber") || ($par_name eq "correctlc") || ($par_name eq "expofile") ){ 
	    return 1;
	}
	else { return 0;}
    }

    if (($par_name eq "regionfile") && &CompUL(&GetValPar("regionfile"),$Default{NONE}) ) {
	&PrntChty(2,"$Task{stem}: Error: Cannot specify '$par_name=NONE'\n");
	&PrntChty(2,"$Task{stem}: Error: Please set '$par_name' to 'DEFAULT' or supply an extraction region file\n");
	$Task{errmess} = "Cannot insert $par_name=NONE";
	return 0;
    }

    if ( (($par_name eq "ra") || ($par_name eq "dec") || ($par_name eq "radius"))
	 && ((&GetValPar("phafile") =~ /$Default{NONE}/i) && (&GetValPar("lcfile") =~ /$Default{NONE}/i)))
    {
	$Task{errmess} = "Cannot insert $par_name when phafile=NONE and lcfile=NONE";
	return 0;
    } 
	
    if (($par_name eq "rmffile") || ($par_name eq "mirfile") || ($par_name eq "psfflag") || 
	($par_name eq "fitsfile") ||  ($par_name eq "psffile") || ($par_name eq "vigfile") || ($par_name eq "inarffile") || ($par_name eq "expofile")) {
	if (&GetValPar("phafile") !~ /$Default{NONE}/i) {
	    return 1;
	} else { 
	    $Task{errmess} = "Cannot insert $par_name when phafile=NONE";
	    return 0;
	}
    }
	
    if ((&GetValPar("lcfile") =~ /$Default{NONE}/i) && (($par_name eq "binsize") || ($par_name eq "pilow") || ($par_name eq "pihigh"))) {
	 $Task{errmess} = "Cannot insert $par_name when lcfile=NONE";
	return 0;
    }

    if ( (&CompUL( &GetValPar("bkgextract"),"no")) && (($par_name eq "bkgregionfile") || ($par_name eq "bkglcfile") || ($par_name eq "bkgphafile"))) {
	 $Task{errmess} = "Cannot insert $par_name when bkgextract=no";
	return 0;
    }

    if ( (&CompUL( &GetValPar("correctlc"),"no")) && (($par_name eq "attfile") || ($par_name eq "hdfile")) ) {
	 $Task{errmess} = "Cannot insert $par_name when correctlc=no";
	return 0;
    }

    if ($datamode eq "pc") {

	if (($par_name eq "ra") && !&CompUL(&GetValPar("regionfile"),$Default{DEFAULT}) ) { 
	     $Task{errmess} = "Cannot insert $par_name when input region file name is specified";
	    return 0;
	 }

	if (($par_name eq "dec") && !&CompUL(&GetValPar("regionfile"),$Default{DEFAULT}) ) { 
	     $Task{errmess} = "Cannot insert $par_name when input region file name is specified";
	    return 0;
	 }

	if (($par_name eq "radius") && !&CompUL(&GetValPar("regionfile"),$Default{DEFAULT}) ) { 
	     $Task{errmess} = "Cannot insert $par_name when input region file name is specified";
	    return 0;
	 }
    
	return 1;
    }

    if ($datamode eq "wt") {

	if (($par_name eq "ra") && !&CompUL(&GetValPar("regionfile"),$Default{DEFAULT}) ) { 
	     $Task{errmess} = "Cannot insert $par_name when input region file name is specified";
	    return 0;
	 }

	if (($par_name eq "dec") && !&CompUL(&GetValPar("regionfile"),$Default{DEFAULT}) ) { 
	     $Task{errmess} = "Cannot insert $par_name when input region file name is specified";
	    return 0;
	 }

	if (($par_name eq "radius") && !&CompUL(&GetValPar("regionfile"),$Default{DEFAULT}) ) { 
	     $Task{errmess} = "Cannot insert $par_name when input region file name is specified";
	    return 0;
	 }
	
	return 1;
    }
    
    if ($datamode =~ /(lr|pu)/i) {
	if (($par_name eq "radius") || ($par_name eq "regionfile") || 
	    ($par_name eq "imagefile") || (($par_name eq "ra") || ($par_name eq "dec"))){ 
	    return 0;
	}
	return 1;
    }

    $Task{errmess} = "";
    return 1;
} # RequestParameter


#Return filename of rmf file
# return empty string if file not found or if there are more rmf file 
sub GetRmfFile(){

    
    my ($filename,$reffile,$refext,@rmffile,@extfile) = @_;

    use vars qw($datamode);

    my ($strmode,$grade,$rmffile);
    my ($StartDate, $StartTime, $xrtvsub);


    # Get Observation Start Date
    &GetEventStartDate($filename, \$StartDate, \$StartTime);
    if ( $Task{status} ) { return "";}

    # Get XRTVSUB
    &GetKeyword ($filename, "EVENTS", undef, "XRTVSUB", \$xrtvsub, 1);
    if ( $Task{status} ) {
	if ($Task{status} == KEY_NO_EXIST){
	    $xrtvsub="0";
	    &PrntChty(2,"$Task{stem}: Warning: 'XRTVSUB' keyword not found in '$filename'\n");
	    &PrntChty(2,"$Task{stem}: Warning: using default value '0'\n");
	    $Task{status}=0;
	}
	else{
	    &PrntChty(2,"$Task{stem}: Error: cannot read 'XRTVSUB' keyword in file '$filename'\n");
	    return "";
	}
    }

    # Get Grade
    $grade = &GetGrade($filename);
    if ($Task{status}) { return "";}

#    if ($grade <0) {return "";}

    if ($datamode =~ /pc/i) {$strmode = "datamode.eq.photon"}
    elsif ($datamode =~ /wt/i) { $strmode = "datamode.eq.windowed";}
    else { $strmode = "datamode.eq.lowrate";}
    
    $strmode = $strmode . ".and.grade.eq.G$grade";
    $strmode = $strmode . ".and.XRTVSUB.eq.$xrtvsub";

   ($reffile,$refext) = &CallQuzcif ("matrix", $StartDate, $StartTime,"$strmode",1);

    @rmffile = @$reffile;
    @extfile = @$refext;

    if ($Task{status}) {
	$Task{errmess} = "Unable to get rmf file from CALDB";
	return "";
    } else {
	return $rmffile[0];
    }
}




#Return value of DSVALn keyword
#return -1 in case of errors
sub GetGrade() {
    my ($filename) =  @_;

    my ($i,$numext,$val);

    #Get extension EVENTS
    $numext = &GetNumExtName($filename,"EVENTS");
     if ($numext < 0) {
	 $Task{status} = 1;
	 return -1;
    }  
    
    for ($i = 1; $i <= 99; $i++) {
	&GetKeyword($filename,"EVENTS", undef,"DSTYP$i",\$val);
	&PrntChty(5,"$Task{stem}:Get keyword DSTYP$i ($numext) value: $val\n");
	if ( $Task{status} ) {return -1; }
	

	if ($val =~ /GRADE/i) {
	    &GetKeyword($filename,"EVENTS", undef,"DSVAL$i",\$val);
	    if ($Task{status}) { return -1;}
	    return $val;
	}
    }

    $Task{status} = "Cannot find DSTYPm keyword in $filename"; 
    return -1;
}


sub RunXrtLcCorr {

    my ( $lcfile, $infile, $stemout ) = @_;

    my ( $par, $ret );
    my ( $command, %xrtlccorr );

    my ( $outinstrfile, $corrfile, $outfile );

    use vars qw ( %Task %Default );


    # Set DEFAULT name of the output files
    if ( uc(&GetValPar("outinstrfile")) eq $Default{DEFAULT} ) {
	$outinstrfile =  &GetValPar("outdir") ."/" . $stemout . "_srawinstr.img";
    } 
    else { 
	$outinstrfile = &GetValPar("outdir") ."/" . &GetValPar("outinstrfile"); 
    }

    if ( uc(&GetValPar("corrfile")) eq $Default{DEFAULT} ) {
	$corrfile =  &GetValPar("outdir") ."/" . $stemout . "sr_corrfact.fits";
    } 
    else { 
	$corrfile = &GetValPar("outdir") ."/" . &GetValPar("corrfile"); 
    }

    if ( uc(&GetValPar("lccorrfile")) eq $Default{DEFAULT} ) {
	$outfile =  &GetValPar("outdir") ."/" . $stemout . "sr_corr.lc";
    } 
    else { 
	$outfile = &GetValPar("outdir") ."/" . &GetValPar("lccorrfile"); 
    }


    %xrtlccorr = (
		  lcfile          => $lcfile,
		  regionfile      => "NONE",
		  outfile         => $outfile,
		  corrfile        => $corrfile,
		  teldef          => "CALDB",
		  aberration      => "no",
		  attinterpol     => "no",
		  attfile         => &GetValPar("attfile"),
		  srcx            => -1,
		  srcy            => -1,
		  psffile         => "CALDB",
		  psfflag         => "yes",
		  energy          => &GetValPar("lcenergy"),
		  createinstrmap  => "yes",
		  outinstrfile    => $outinstrfile,
		  infile          => $infile,
		  hdfile          => &GetValPar("hdfile"),
		  fovfile         => "CALDB",
		  vigfile         => "CALDB",
		  wtnframe        => &GetValPar("wtnframe"),
		  pcnframe        => &GetValPar("pcnframe"),
		  chatter         => &GetValPar("chatter"),
		  history         => &GetValPar("history"),
		  clobber         => &GetValPar("clobber"),
		  );


    $command = "xrtlccorr";
    for $par ( keys %xrtlccorr ) { $command .= " $par=$xrtlccorr{$par}"; } 


    &RunningSub("RunXrtLcCorr","xrtlccorr"," on '$lcfile'");
    &RunningComm("RunXrtLcCorr",$command);

    $ret = 0;
    $ret = system( $command );

    if ( $ret != 0 ) {
	&ErrorComm("RunXrtLcCorr","xrtlccorr",$command);
        $Task{errmess} = "ERROR running 'xrtlccorr'";
	$Task{status} = 1;
	return 1;
    }

    &SuccessSub("RunXrtLcCorr","xrtlccorr");
    return 0;

} # RunXrtLcCorr
